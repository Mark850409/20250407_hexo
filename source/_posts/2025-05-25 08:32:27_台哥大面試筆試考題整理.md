---
title: Java 全端考前小抄筆記
date: 2025-05-25
tags:
- SQL
- 資料庫設計
- 正規化
- Java
- 物件導向
- GC
- Spring Boot
- RESTful API
- Web 資安
- 程式實作
categories:
- Java
- 後端開發
- 資料庫
- 資安
- 筆試題
---

```
# Java 全端考前小抄筆記

---

# 一、SQL 語法重點整理

## 重點摘要
SQL (Structured Query Language) 是操作關聯式資料庫的標準語言。掌握核心的查詢語法（SELECT, FROM, WHERE, JOIN, GROUP BY, HAVING, ORDER BY）以及子查詢、聚合函數等概念，是進行後端開發不可或缺的能力。面試中常透過撰寫或解釋 SQL 語句來考察對資料庫操作的理解。

## 常用語法與說明

### 📌 SELECT + FROM + WHERE + ORDER BY
- **用途：** 用於從資料庫中查詢資料、指定來源表格、設定條件過濾、對結果進行排序。

#### 範例：
```sql
SELECT name, age
FROM users
WHERE age > 30
ORDER BY age DESC;
```

#### 解說：
- `SELECT name, age`: 指定要查詢的欄位為 `name` 和 `age`。
- `FROM users`: 指定從 `users` 資料表查詢。
- `WHERE age > 30`: 設定過濾條件，只選擇 `age` 大於 30 的紀錄。
- `ORDER BY age DESC`: 依據 `age` 欄位進行排序，`DESC` 表示降冪（從大到小），`ASC` 表示升冪（從小到大，預設值）。

---

### 📌 JOIN（INNER / LEFT / RIGHT / FULL）
- **用途：** 用於根據兩個或多個表格中的相關欄位，將這些表格中的行組合起來。

#### 範例（INNER JOIN）：
```sql
SELECT users.name, orders.id AS order_id
FROM users
INNER JOIN orders ON users.id = orders.user_id;
```

#### 解說：
- `INNER JOIN orders ON users.id = orders.user_id`: 使用 `INNER JOIN` 連接 `users` 表和 `orders` 表。連接條件是 `users` 表的 `id` 欄位等於 `orders` 表的 `user_id` 欄位。
- `INNER JOIN` 只會回傳在兩個表中都找到匹配的行。
- `LEFT JOIN` (或 `LEFT OUTER JOIN`): 回傳左表 (users) 的所有行，即使右表 (orders) 中沒有匹配。右表中沒有匹配的欄位會顯示 NULL。
- `RIGHT JOIN` (或 `RIGHT OUTER JOIN`): 回傳右表 (orders) 的所有行，即使左表 (users) 中沒有匹配。左表中沒有匹配的欄位會顯示 NULL。
- `FULL JOIN` (或 `FULL OUTER JOIN`): 回傳當左表或右表中有匹配時的所有行。沒有匹配的欄位會顯示 NULL。

---

### 📌 GROUP BY + HAVING
- **用途：** `GROUP BY` 用於根據一個或多個欄位的相同值將結果集分組。`HAVING` 用於在分組後過濾這些組（類似於 `WHERE` 用於過濾行）。常用於搭配聚合函數。

#### 範例：
```sql
SELECT department, COUNT(employee_id) AS employee_count
FROM employees
GROUP BY department
HAVING COUNT(employee_id) > 5;
```

#### 解說：
- `GROUP BY department`: 根據 `department` 欄位將 `employees` 表中的行分組。
- `COUNT(employee_id)`: 對每個分組計算員工數量。
- `HAVING COUNT(employee_id) > 5`: 過濾分組結果，只保留員工數量大於 5 的部門。注意 `HAVING` 後可以使用聚合函數，`WHERE` 後不能直接使用聚合函數（除非用子查詢）。

---

### 📌 LIMIT / OFFSET
- **用途：** `LIMIT` 用於限制查詢結果回傳的行數。`OFFSET` 用於指定從哪一行開始回傳結果。常用於分頁。

#### 範例：
```sql
SELECT name
FROM users
ORDER BY id
LIMIT 10 OFFSET 20;
```

#### 解說：
- `LIMIT 10`: 限制最多回傳 10 行結果。
- `OFFSET 20`: 跳過前 20 行結果，從第 21 行開始回傳。
- 這個語句會回傳按照 `id` 排序的第 21 到 30 行的使用者姓名。

---

### 📌 子查詢（Subquery）
- **用途：** 將一個查詢（內部查詢）嵌套在另一個 SQL 語句（外部查詢）中。子查詢可以用在 `WHERE` 子句中進行條件過濾、`FROM` 子句中作為臨時表、或 `SELECT` 子句中計算單個值等。

#### 範例：
```sql
SELECT name, age
FROM users
WHERE age > (SELECT AVG(age) FROM users);
```

#### 解說：
- `(SELECT AVG(age) FROM users)` 是一個子查詢。它會先計算所有使用者的平均年齡。
- 外部查詢 `SELECT name, age FROM users WHERE age > ...` 使用這個平均年齡作為條件，找出年齡大於平均年齡的使用者。

---

### 📌 COUNT(), AVG(), SUM(), MAX(), MIN() 聚合函數
- **用途：** 這些函數用於對一組行的值執行計算，通常與 `GROUP BY` 一起使用。

#### 範例：
```sql
SELECT
    COUNT(*) AS total_users,
    AVG(age) AS average_age,
    SUM(salary) AS total_salary
FROM employees;
```

#### 解說：
- `COUNT(*)`: 計算表中的總行數。
- `AVG(age)`: 計算 `age` 欄位的平均值。
- `SUM(salary)`: 計算 `salary` 欄位的總和。
- `MAX(column)`: 找出某欄位的最大值。
- `MIN(column)`: 找出某欄位的最小值。
- 這些函數可以直接用於整個表，或與 `GROUP BY` 一起用於每個分組。

---

### 📌 資料更新/刪除語法（UPDATE, DELETE）
- **用途：** `UPDATE` 用於修改表中現有的數據。`DELETE` 用於從表中刪除數據。

#### 範例（UPDATE）：
```sql
UPDATE users
SET email = 'new.email@example.com', age = 35
WHERE id = 101;
```

#### 解說：
- `UPDATE users`: 指定要更新 `users` 表。
- `SET email = 'new.email@example.com', age = 35`: 設定要修改的欄位及其新值。
- `WHERE id = 101`: 指定要更新哪些行，只更新 `id` 為 101 的使用者。**重要：** 執行 `UPDATE` 或 `DELETE` 時，務必包含 `WHERE` 子句，否則會修改/刪除表中的所有紀錄！

#### 範例（DELETE）：
```sql
DELETE FROM orders
WHERE status = 'cancelled';
```

#### 解說：
- `DELETE FROM orders`: 指定要從 `orders` 表中刪除數據。
- `WHERE status = 'cancelled'`: 指定要刪除哪些行，刪除所有 `status` 為 'cancelled' 的訂單。

<!-- more -->

# 二、資料庫設計與正規化

## 重點摘要
資料正規化是關聯式資料庫設計中的一項重要技術，目標是透過分解表格、建立關聯，來減少資料冗餘（重複）、避免資料更新異常，並提升資料的一致性和完整性。理解正規化的概念和不同等級（1NF, 2NF, 3NF 等）有助於設計出結構良好、易於維護的資料庫。

## 定義
- 資料正規化：一個系統化的過程，用於設計關聯式資料庫的結構，以減少資料冗餘和提高資料完整性。
- 目的：
    - 減少資料的重複存儲。
    - 避免更新異常 (Insertion, Update, Deletion Anomaly)。
    - 提高資料的一致性。
    - 使資料庫結構更易於維護和修改。
- 更新異常：
    - 插入異常 (Insertion Anomaly)：無法在不輸入某個相關資訊的情況下插入新資料。
    - 更新異常 (Update Anomaly)：修改一個資料需要在多處進行，否則會導致不一致。
    - 刪除異常 (Deletion Anomaly)：刪除某個資料時，不小心刪除了其他不應被刪除的相關資訊。
- 正規形式 (Normal Forms, NF)：衡量資料庫表格正規化程度的標準，越高階的正規形式要求越嚴格。

## 正規化說明（1NF～3NF）
- **1NF (First Normal Form)**：
    - **定義：** 每個表格必須有主鍵 (Primary Key)，每個欄位的值都必須是原子的（不可再分割）。不允許欄位中包含多個值或重複的群組。
    - **範例（不符合 1NF）：**
        | OrderID | Customer | Products          |
        | :------ | :------- | :---------------- |
        | 1       | Alice    | 'Apple, Banana'   |
        | 2       | Bob      | 'Orange, Grape'   |
    - **範例（符合 1NF）：**
        | OrderID | Customer | Product |
        | :------ | :------- | :------ |
        | 1       | Alice    | Apple   |
        | 1       | Alice    | Banana  |
        | 2       | Bob      | Orange  |
        | 2       | Bob      | Grape   |
- **2NF (Second Normal Form)**：
    - **定義：** 滿足 1NF，且所有非主鍵欄位都必須完全依賴於主鍵（針對複合主鍵）。如果主鍵只有一個欄位，則 2NF 與 1NF 相同。
    - **範例（不符合 2NF，假設 OrderID+ProductID 是複合主鍵）：**
        | OrderID | ProductID | ProductName | Price | CustomerID | CustomerName |
        | :------ | :-------- | :---------- | :---- | :--------- | :----------- |
        | 1       | 101       | Apple       | 10    | 1          | Alice        |
        | 1       | 102       | Banana      | 5     | 1          | Alice        |
        | 2       | 103       | Orange      | 12    | 2          | Bob          |
        - `ProductName` 和 `Price` 只依賴於 `ProductID` (主鍵的一部分)，`CustomerName` 只依賴於 `CustomerID` (非主鍵，但可能在其他表中是主鍵)。
    - **範例（符合 2NF）：**
        | OrderID | ProductID | CustomerID |
        | :------ | :-------- | :--------- |
        | 1       | 101       | 1          |
        | 1       | 102       | 1          |
        | 2       | 103       | 2          |
        | :-------| :-------- | :--------- |
        | `Products` 表: |           |            |
        | ProductID | ProductName | Price      |
        | :-------- | :---------- | :--------- |
        | 101       | Apple       | 10         |
        | 102       | Banana      | 5          |
        | 103       | Orange      | 12         |
        | :-------| :---------- | :--------- |
        | `Customers` 表: |           |            |
        | CustomerID | CustomerName |
        | :--------- | :----------- |
        | 1          | Alice |
        | 2          | Bob |
- **3NF (Third Normal Form)**：
    - **定義：** 滿足 2NF，且所有非主鍵欄位不能透過其他非主鍵欄位來依賴主鍵（消除傳遞依賴）。
    - **範例（不符合 3NF，使用符合 2NF 的訂單/客戶表，但客戶表包含客戶城市名和城市郵遞區號）：**
        | CustomerID | CustomerName | CustomerCity | CityZipCode |
        | :--------- | :----------- | :----------- | :---------- |
        | 1          | Alice | New York | 10001 |
        | 2          | Bob | Los Angeles | 90001 |
        | 3          | Charlie | New York | 10001 |
        - `CityZipCode` 依賴於 `CustomerCity`，而 `CustomerCity` 依賴於 `CustomerID` (主鍵)，這就是傳遞依賴。
    - **範例（符合 3NF）：**
        | CustomerID | CustomerName | CityID |
        | :--------- | :----------- | :--------- |
        | 1          | Alice | 1 |
        | 2          | Bob | 2 |
        | 3          | Charlie | 1 |
        | :--------- | :----------- | :--------- |
        | `Cities` 表: | | |
        | CityID | CustomerCity | CityZipCode |
        | :--------- | :----------- | :---------- |
        | 1 | New York | 10001 |
        | 2 | Los Angeles | 90001 |

## 關聯設計情境範例
### 題目：設計會員與訂單資料表
設計一個系統，需要記錄會員資訊、商品資訊以及會員購買商品的訂單記錄和訂單詳情。

應包含資料表：
- `users`（會員）
- `orders`（訂單）
- `products`（商品）
- `order_items`（訂單明細）

### 建議表格結構與關聯設計：

#### 1. `users` 表 (會員)
- 記錄會員的基本資訊。
- 主鍵：`user_id` (int, Primary Key)
- 其他欄位：`username` (varchar), `email` (varchar), `registration_date` (date), ...
- **約束：** `user_id` PRIMARY KEY, `email` UNIQUE

#### 2. `products` 表 (商品)
- 記錄商品的資訊。
- 主鍵：`product_id` (int, Primary Key)
- 其他欄位：`product_name` (varchar), `price` (decimal), `stock` (int), ...
- **約束：** `product_id` PRIMARY KEY

#### 3. `orders` 表 (訂單)
- 記錄訂單的主體資訊。
- 主鍵：`order_id` (int, Primary Key)
- 外鍵：`user_id` (int, Foreign Key) 參考 `users` 表的 `user_id`。表明這筆訂單是哪個會員下的。
- 其他欄位：`order_date` (datetime), `total_amount` (decimal), `status` (varchar), ...
- **關聯：** `users` 1 : N `orders` (一個會員可以有多筆訂單)
- **約束：** `order_id` PRIMARY KEY, `user_id` FOREIGN KEY REFERENCES `users`(user_id)

#### 4. `order_items` 表 (訂單明細)
- 記錄每筆訂單中包含哪些商品及其數量、購買時的價格等詳細資訊。
- 這個表通常用來解決訂單和商品之間的 N:M (多對多) 關聯，並記錄特定訂單下商品的具體細節。
- 主鍵：複合主鍵 (`order_item_id` 或 `order_id` + `product_id`)。使用單獨的 `order_item_id` 作為主鍵更靈活。
- 外鍵：
    - `order_id` (int, Foreign Key) 參考 `orders` 表的 `order_id`。表明這是哪筆訂單的明細。
    - `product_id` (int, Foreign Key) 參考 `products` 表的 `product_id`。表明這個明細是哪個商品。
- 其他欄位：`quantity` (int), `price_at_order` (decimal - 記錄購買時的商品價格，防止商品表價格變動影響歷史訂單), `subtotal` (decimal), ...
- **關聯：**
    - `orders` 1 : N `order_items` (一筆訂單可以有多個明細項)
    - `products` 1 : N `order_items` (一個商品可以出現在多個訂單明細中)
    - 最終實現 `orders` N : M `products` 透過 `order_items` 這個中介表。
- **約束：** `order_item_id` PRIMARY KEY, `order_id` FOREIGN KEY REFERENCES `orders`(order_id), `product_id` FOREIGN KEY REFERENCES `products`(product_id)

### 視覺化關聯 (簡化文字表示)：
```
users --< one-to-many >-- orders --< one-to-many >-- order_items --< many-to-one >-- products
```

或者說，`order_items` 表通過外鍵 `order_id` 指向 `orders` 表，通過外鍵 `product_id` 指向 `products` 表。

#### 創建這些表的 SQL 範例：
```sql
-- 創建 users 表
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT, -- AUTO_INCREMENT 自動生成唯一ID
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) UNIQUE,
    registration_date DATE,
    -- 其他會員相關欄位
);

-- 創建 products 表
CREATE TABLE products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,
    product_name VARCHAR(100) NOT NULL,
    price DECIMAL(10, 2) NOT NULL,
    stock INT NOT NULL DEFAULT 0,
    -- 其他商品相關欄位
);

-- 創建 orders 表
CREATE TABLE orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    order_date DATETIME NOT NULL,
    total_amount DECIMAL(10, 2) NOT NULL,
    status VARCHAR(20), -- 例如 'pending', 'completed', 'cancelled'
    -- 其他訂單相關欄位
    FOREIGN KEY (user_id) REFERENCES users(user_id) -- 定義外鍵
);

-- 創建 order_items 表 (使用複合主鍵或單獨ID取決於設計偏好，此處用單獨ID方便管理)
CREATE TABLE order_items (
    order_item_id INT PRIMARY KEY AUTO_INCREMENT, -- 明細項ID
    order_id INT,
    product_id INT,
    quantity INT NOT NULL,
    price_at_order DECIMAL(10, 2) NOT NULL, -- 記錄當時價格
    FOREIGN KEY (order_id) REFERENCES orders(order_id), -- 定義外鍵
    FOREIGN KEY (product_id) REFERENCES products(product_id) -- 定義外鍵
    -- 如果使用複合主鍵: PRIMARY KEY (order_id, product_id)
);
```
**解說:**
- `PRIMARY KEY`: 定義主鍵，唯一識別表中的每一行。
- `FOREIGN KEY`: 定義外鍵，建立表之間的關聯，引用另一個表的主鍵。這也是實現正規化的關鍵。
- `REFERENCES`: 指明外鍵參考哪個表和哪個欄位。
- `NOT NULL`, `UNIQUE`, `DEFAULT`, `AUTO_INCREMENT`: 其他常見的欄位約束，確保資料的完整性和方便性。

---

# 三、Java 基本語法與物件導向觀念（OOP）

## 重點摘要
Java 是一門物件導向的程式語言。掌握其基本語法、資料類型、控制流程以及最重要的物件導向特性（封裝、繼承、多型、抽象），是成為合格 Java 工程師的基石。物件導向思維有助於設計出結構清晰、可重用、易於擴展和維護的程式碼。

## 定義
- Java 基本語法：變數、資料類型 (原始類型如 `int`, `double`, `boolean`；引用類型如 `String`, 類別、陣列)、運算子、控制流程語句 (`if`, `for`, `while`, `switch`)、方法 (Method)、類別 (Class)、物件 (Object)、陣列 (Array)。
- 物件導向程式設計 (OOP)：一種程式設計範式，將程式視為獨立的「物件」的集合，這些物件包含數據（屬性）和處理數據的方法（行為）。

## OOP 四大特性簡述

### 📌 封裝（Encapsulation）
- **定義：** 將數據（成員變數）和處理數據的方法（成員方法）綁定在一個單元（類別）中，並通過存取修飾詞（`public`, `private`, `protected`）控制對內部數據的訪問，隱藏內部實現細節。
- **目的：** 保護數據不被外部隨意存取和修改，提高程式碼的安全性和可維護性。對外提供統一的介面（如 getter/setter 方法）。
- **範例：**
    ```java
    public class Person {
        private String name; // 私有成員變數，外部無法直接訪問

        public String getName() { // 公有 getter 方法
            return name;
        }

        public void setName(String name) { // 公有 setter 方法
            if (name != null && !name.isEmpty()) {
                this.name = name; // 在 setter 中可以加入驗證邏輯
            }
        }
    }
    ```
    - 解說：`name` 變數被封裝在 `Person` 類別內部，只能透過 `getName()` 和 `setName()` 方法來存取和修改。

---

### 📌 繼承（Inheritance）
- **定義：** 允許一個類別（子類別/衍生類別）繼承另一個類別（父類別/基礎類別）的屬性和方法。子類別可以重用父類別的程式碼，並在此基礎上添加新的功能或覆寫父類別的方法。Java 支持單一繼承（一個類別只能直接繼承一個父類別），但可以多層繼承。
- **目的：** 提高程式碼的可重用性，建立類別之間的層次關係。
- **範例：**
    ```java
    public class Animal {
        String food;
        public void eat() {
            System.out.println("Animal eats " + food);
        }
    }

    public class Dog extends Animal { // Dog 繼承 Animal
        String breed;
        public void bark() {
            System.out.println("Dog barks");
        }
        @Override // 子類別覆寫父類別的方法
        public void eat() {
            System.out.println("Dog eats bones");
        }
    }
    ```
    - 解說：`Dog` 繼承了 `Animal` 的 `food` 屬性和 `eat()` 方法，同時有自己的 `breed` 屬性和 `bark()` 方法。它也覆寫了 `eat()` 方法，提供了狗吃東西的具體實作。

---

### 📌 多型（Polymorphism）
- **定義：** 允許不同的物件對同一個方法調用做出不同的響應。主要體現在編譯時的多型（方法重載 - Overloading）和執行時的多型（方法覆寫 - Overriding）。
- **目的：** 增強程式的靈活性和擴展性，可以使用父類別的引用指向子類別的物件，並調用覆寫後的方法。
- **範例（方法覆寫實現執行時多型）：**
    ```java
    Animal myAnimal = new Dog(); // 父類別引用指向子類別物件
    myAnimal.eat(); // 執行的是 Dog 類別覆寫後的 eat() 方法 (輸出: Dog eats bones)

    Animal anotherAnimal = new Animal();
    anotherAnimal.eat(); // 執行的是 Animal 類別的 eat() 方法
    ```
    - 解說：儘管 `myAnimal` 的聲明類型是 `Animal`，但因為它的實際物件類型是 `Dog`，所以調用 `eat()` 方法時執行的是 `Dog` 類別中的實作。

- **範例（方法重載實現編譯時多型）：**
    ```java
    public class Calculator {
        public int add(int a, int b) { // 重載方法 1
            return a + b;
        }
        public double add(double a, double b) { // 重載方法 2 (參數類型不同)
            return a + b;
        }
        public int add(int a, int b, int c) { // 重載方法 3 (參數數量不同)
            return a + b + c;
        }
    }
    ```
    - 解說：`add` 方法根據傳入的參數類型和數量不同，會自動選擇呼叫對應的版本。

---

### 📌 抽象（Abstraction）
- **定義：** 隱藏複雜的實現細節，只暴露必要的功能和介面給外部。通過抽象類別 (Abstract Class) 和介面 (Interface) 來實現。
- **目的：** 建立一個共同的基礎或協定，定義行為標準，迫使子類別或實作類別提供具體的實作，同時允許程式設計者專注於物件的行為而非其內部工作原理。
- **範例：** (見下文「抽象類別 vs 介面」說明)

## 補充觀念

- **`static`：**
    - 修飾成員變數：成為類別變數 (Class Variable)，所有物件共用同一個值，屬於類別而非物件。通過類別名稱直接訪問。
    - 修飾方法：成為類別方法 (Class Method)，可以直接通過類別名稱呼叫，無需創建物件。類別方法不能直接訪問非靜態成員變數或方法（因為它們依賴於物件實例）。
    - 修飾區塊：靜態初始化區塊，在類別載入時執行一次，用於初始化靜態變數。
- **`final`：**
    - 修飾變數：變數的值一旦初始化就不能再改變（對於基本類型是值本身，對於引用類型是引用地址不能變，但物件本身的內容可以變）。
    - 修飾方法：該方法不能被子類別覆寫 (Override)。
    - 修飾類別：該類別不能被繼承。
- **`this`：**
    - 在類別內部使用，指向當前物件的實例。
    - 常用於區分成員變數和方法參數（例如 `this.name = name;`）。
    - 可以在建構子中呼叫當前類別的其他建構子（例如 `this(name, age);`）。
- **`super`：**
    - 在子類別內部使用，指向其直接父類別的實例。
    - 常用於呼叫父類別的建構子（必須是子類別建構子中的第一條語句，例如 `super(name);`）。
    - 常用於呼叫父類別被子類別覆寫的方法（例如 `super.eat();`）。
- **建構子 overloading (重載)：**
    - 一個類別可以有多個建構子，它們有相同的建構子名稱（即類別名稱），但參數列表不同（參數數量、類型或順序）。
    - 允許在創建物件時使用不同的方式初始化物件的狀態。
- **抽象類別 vs 介面：**
    - **抽象類別 (Abstract Class)**:
        - 用 `abstract` 關鍵字聲明。
        - 不能被實例化。
        - 可以有抽象方法（無實作，用 `abstract` 修飾）和具體方法（有實作）。
        - 可以有成員變數（包括非 `final` 的）。
        - 可以有建構子。
        - 一個類別只能繼承一個抽象類別。
        - 適用場景：當需要定義共同的基礎結構和部分實作，並強制子類別完成部分功能時。表示「是一種...」(is-a) 的關係層次。
    - **介面 (Interface)**:
        - 用 `interface` 關鍵字聲明。
        - 不能被實例化。
        - 在 Java 8 之前，只能有常量（`public static final`，可省略修飾詞）和抽象方法（`public abstract`，可省略修飾詞）。
        - Java 8 引入 default 和 static 方法，可以在介面中提供實作。
        - Java 9 引入 private 方法。
        - 介面中的變數預設是 `public static final`。
        - 沒有建構子。
        - 一個類別可以實作 (implement) 多個介面。
        - 適用場景：當需要定義一組行為標準或協定，而不關心具體實作時。表示「能做什麼」(can-do) 的能力。

- **記憶體管理與 Garbage Collection (GC)**：
    - **記憶體區域**：主要包括 Stack (棧，存儲局部變數、方法呼叫)、Heap (堆，存儲物件實例)、Method Area/Metaspace (方法區/元空間，存儲類別資訊)。
    - **GC 工作對象**：主要針對 Heap 區不再被任何「根引用」(GC Roots) 可達的物件進行回收。
    - **自動管理**：JVM 自動進行垃圾回收，程式員無需手動釋放記憶體，減少記憶體洩漏的風險。
    - (更詳細的 GC 說明請參考後續章節)

---

# 四、Java 垃圾回收（Garbage Collection）機制與優化策略

## 重點摘要
Java 的垃圾回收 (GC) 是一種自動化的記憶體管理機制，負責回收不再使用的物件所佔用的記憶體。理解 GC 的工作原理、不同區域（Young/Old Generation）以及常見的 GC 演算法和類型（Minor/Major/Full GC），對於診斷記憶體問題（如記憶體洩漏）和優化 Java 應用程式的效能至關重要。

## 定義
- 垃圾回收 (Garbage Collection, GC)：JVM (Java Virtual Machine) 提供的一種自動記憶體管理功能，用於自動回收不再被程式引用的物件所佔用的記憶體。
- 目的：減少程式員手動管理記憶體的負擔，避免記憶體洩漏 (Memory Leak) 和釋放後使用 (Use After Free) 等問題。
- 記憶體區域：
    - **Heap (堆)**：Java 物件主要存儲的區域，是 GC 工作的主要區域。 Heap 又分為：
        - **Young Generation (新生代)**：新創建的物件首先分配在這裡。包含 Eden Space 和兩個 Survivor Spaces (S0, S1)。
        - **Old Generation (老年代/舊生代)**：經過多次 Minor GC 仍存活的物件會晉升到這裡。
    - **Stack (棧)**：存儲局部變數和方法呼叫資訊，這部分記憶體由 JVM 自動管理，不是 GC 的重點。
    - **Method Area (方法區) / Metaspace (元空間)**：存儲類別結構資訊、靜態變數、常量等。GC 也可以對此區域進行回收，但在 Java 8 及之後主要管理 Metaspace。
- GC 類型：
    - **Minor GC (新生代 GC)**：只清理 Young Generation，發生頻率高，速度快。
    - **Major GC (老年代 GC)**：只清理 Old Generation，發生頻率低。
    - **Full GC (全 GC)**：清理整個 Heap (Young + Old) 和 Method Area/Metaspace，發生頻率最低，耗時最長，可能導致應用暫停 ("Stop-the-world" pause)。
- 判斷物件是否可回收：通過可達性分析 (Reachability Analysis)，從 GC Roots (如活動線程的局部變數、靜態變數等) 出發，任何不可達的物件都被視為垃圾。
- GC 演算法：Mark-Sweep (標記清除), Copying (複製), Mark-Compact (標記整理), Generational GC (分代 GC), Concurrent GC (並發 GC), Parallel GC (並行 GC)。

## 常考觀念 Q&A

### Q1：什麼是 Java 垃圾回收？它解決了什麼問題？
- Java 垃圾回收是 JVM 自動幫我們管理記憶體的功能。
- 它會自動找到那些程式已經不再使用的物件，並回收它們佔用的記憶體空間。
- 解決了程式員需要手動分配和釋放記憶體的問題，避免了記憶體洩漏或釋放後使用等錯誤。
- 🗣️口語化回答：就是 Java 不用你自己清記憶體，JVM 會自動找到沒用的物件並收走，讓你可以專心寫程式。

### Q2：Java 記憶體區域中，哪些是 GC 的主要工作對象？請說明 Young Gen 和 Old Gen 的區別。
- GC 主要工作對象是 Heap 區域。
- Heap 分為 Young Generation (新生代) 和 Old Generation (老年代)。
- Young Gen 用來存放新創建的物件，通常生命週期較短，GC 頻率高（Minor GC）。
- Old Gen 用來存放那些在 Young Gen 經過多次 GC 後仍然存活的物件，通常生命週期較長。
- 🗣️口語化回答：GC 主要清 Heap 區。Heap 分年輕代和老年代，新物件放年輕代，活比較久的物件會搬到老年代。

### Q3：Minor GC, Major GC, Full GC 有什麼不同？哪個影響效能最大？
- Minor GC：只清理 Young Generation，發生很頻繁，但速度很快，對應用影響小。
- Major GC：只清理 Old Generation，頻率較低，比 Minor GC 慢。
- Full GC：清理整個 Heap (Young + Old) 和 Metaspace，頻率最低，但會導致應用程式完全暫停 ("Stop-the-world")，是影響效能最大的 GC 類型。
- 🗣️口語化回答：Minor GC 是清年輕代，很快。Major GC 清老年代。Full GC 是清整個 Heap，最慢，可能會讓程式卡住一下。

### Q4：如何判斷一個 Java 物件是否「存活」（不會被 GC 回收）？
- Java 使用「可達性分析」來判斷物件是否存活。
- 從一系列稱為 "GC Roots" 的起始點（例如正在執行的線程中的局部變數、靜態變數、Native 方法堆疊的物件等）出發，遍歷所有引用的物件。
- 任何從 GC Roots 不可達的物件，都會被視為垃圾，可以被回收。
- 🗣️口語化回答：JVM 會從一些起點（像是你程式正在跑的地方）去找物件，只要能找到連過去的物件就是活著的，找不到連線的就是沒用的，可以被收走。

## 重要語法或術語
- Garbage Collection (GC)
- JVM (Java Virtual Machine)
- Heap, Stack
- Young Generation, Old Generation
- Eden Space, Survivor Spaces
- Minor GC, Major GC, Full GC
- Stop-the-world
- GC Roots
- Reachability Analysis (可達性分析)
- Memory Leak (記憶體洩漏)
- GC Algorithms (e.g., G1, Parallel, CMS)
- JVisualVM, JProfiler (GC 監控工具)

## 面試常見問法與回答

### Q1：你在開發中，如何避免或減少記憶體洩漏？
- Q：你在開發中，如何避免或減少記憶體洩漏？
- 確保不再使用的物件，其引用能夠被正確釋放或設為 null，使其變得不可達。
- 避免集合類 (Collection) 在不再需要時仍持有大量物件的引用。
- 謹慎使用靜態集合或長生命週期的物件引用。
- 如果使用了資源（如檔案流、網路連線），確保在不再需要時呼叫 close() 方法釋放。
- 使用弱引用 (WeakReference) 或軟引用 (SoftReference) 在特定場景下允許 GC 回收物件。
- 定期使用記憶體分析工具 (如 JVisualVM, Eclipse Memory Analyzer) 檢查 Heap Dump，查找未釋放的物件和引用鏈。
- 🗣️口語化回答：我會注意用完的物件要讓它能被 GC 收到，特別是集合類和長生命週期的物件。也會確保資源（像檔案連線）有確實關掉。必要時會用工具檢查是不是有物件一直佔著記憶體。

### Q2：你遇過 GC 造成的效能問題嗎？是如何診斷和解決的？
- Q：你遇過 GC 造成的效能問題嗎？是如何診斷和解決的？
- 遇過的問題：應用程式突然停頓很長時間（Full GC 停頓），或 CPU 使用率異常高且頻繁 GC。
- 診斷方法：
    - 啟用 GC 日誌，分析 GC 的頻率、類型和每次耗時。
    - 使用 JVisualVM, JProfiler 等工具連接到運行中的應用，監控 Heap 使用率、GC 活動和線程狀態。
    - 導出 Heap Dump，使用分析工具查找是否存在記憶體洩漏或過大的物件，識別是哪些物件佔用了大量記憶體且未被釋放。
- 解決方法：
    - 根據診斷結果，優化程式碼：減少不必要的物件創建，改進資料結構使用，釋放不再使用的引用。
    - 如果是 GC 演算法不適合應用場景，可以嘗試調整 JVM 參數，更換 GC 演算法（例如從 ParNew/CMS 換到 G1）。
    - 調整 Heap 大小或 Young/Old Gen 比例，但這通常是最後手段且需要仔細測試。
- 🗣️口語化回答：遇過程式突然卡住很久，發現是 Full GC 造成的。我會先開 GC 日誌或用監控工具看是哪裡記憶體用太多，是不是有物件沒被收走，然後去優化程式碼，或是調整 JVM 的 GC 參數和策略。

---

# 五、Spring Boot 架構與註解（Controller、Service、Repository 等）

## 重點摘要
Spring Boot 是一個基於 Spring 框架的快速開發工具，它通過「約定大於配置」的方式，極大地簡化了 Spring 應用程式的搭建和開發過程。理解 Spring Boot 的核心概念（IoC、DI）以及常用的註解（Annotation），是掌握現代 Java 後端開發的關鍵。它提供了成熟的 Web、資料庫、安全等解決方案。

## 定義
- Spring Boot：一個開源的 Java 框架，用於快速建立獨立、可生產級別的 Spring 應用程式。
- 特性：
    - **自動配置 (Auto-configuration)**：根據 classpath 中的函式庫自動配置 Spring 應用，減少手動配置。
    - **Starter Dependencies**：提供一組預先配置好的依賴，簡化依賴管理。
    - **嵌入式伺服器 (Embedded Servers)**：預設內嵌 Tomcat, Jetty 或 Undertow，可直接運行 JAR 文件，無需外部伺服器。
    - **無需 XML 配置**：廣泛使用 Java Configuration 和註解。
    - **生產級功能**：如健康檢查、指標收集 (Actuator)。
- 核心概念：
    - **IoC (Inversion of Control)**：控制反轉，Spring Container 負責管理物件的生命週期和依賴關係。
    - **DI (Dependency Injection)**：依賴注入，IoC Container 將物件所需的依賴自動注入給它，而非由物件自行創建或查找。
- 常見註解：
    - `@SpringBootApplication`：標記 Spring Boot 主應用類別，包含 `@Configuration`, `@EnableAutoConfiguration`, `@ComponentScan`。
    - `@Controller`：標記類別為 Spring MVC 控制器，處理 Web 請求。
    - `@RestController`：組合了 `@Controller` 和 `@ResponseBody`，用於建立 RESTful API。
    - `@Service`：標記類別為服務層組件，包含業務邏輯。
    - `@Repository`：標記類別為資料訪問層組件，通常處理資料庫操作，具有異常轉譯功能。
    - `@Component`：通用的 Spring 組件註解，其他如 `@Service`, `@Repository` 都是它的衍生物。
    - `@Autowired`：用於自動注入依賴。
    - `@Configuration`：標記類別為配置類，其中定義 `@Bean`。
    - `@Bean`：標記方法，其回傳值將註冊為 Spring IoC Container 中的一個 Bean。

## 常考觀念 Q&A

### Q1：什麼是 Spring Boot？為什麼在開發中選擇使用它？
- Spring Boot 是一個讓開發 Spring 應用更容易、更快速的框架。
- 它提供了自動配置、Starter 依賴和內嵌伺服器，可以大幅減少配置工作，直接運行 JAR 文件。
- 加速開發效率，易於部署和維護。
- 🗣️口語化回答：Spring Boot 就是讓你可以很快地建一個 Spring 專案，很多配置都幫你做好了，可以直接跑一個 JAR 檔，開發和部署都變簡單很多。

### Q2：請解釋 IoC (控制反轉) 和 DI (依賴注入) 的概念，以及 `@Autowired` 的作用。
- IoC：意思是物件的建立和管理不由程式碼自己控制，而是交給 Spring 容器來處理。
- DI：是實現 IoC 的一種方式，Spring 容器會自動幫你把物件所需要的其他物件（依賴）「注入」進來。
- `@Autowired`：這個註解就是告訴 Spring 容器，這裡需要一個某種類型的物件，請幫我從容器裡找一個合適的並注入進來。
- 🗣️口語化回答：IoC 是控制權交給 Spring，DI 是 Spring 幫你把需要的東西自動送給你。@Autowired 就是跟 Spring 說「這裡我需要那個物件，請給我」。

### Q3：請說明 `@Controller`, `@RestController`, `@Service`, `@Repository` 這幾個註解在分層架構中的作用。
- `@Controller` / `@RestController`：用於 Web 層，處理進來的 HTTP 請求，呼叫 Service 層的方法，並準備回傳 Response。`@RestController` 專門用於 RESTful API，直接回傳數據 (JSON/XML)。
- `@Service`：用於業務邏輯層，包含核心業務處理程式碼，通常會呼叫 Repository 層。
- `@Repository`：用於資料訪問層，負責與資料庫或其他數據源交互，進行 CRUD (Create, Read, Update, Delete) 操作。
- 🗣️口語化回答：Controller 處理前端請求，Service 處理業務邏輯，Repository 處理資料庫存取。他們是把程式碼切成不同部分的標籤，讓程式碼更清楚。

### Q4：什麼是 Spring Boot 的自動配置 (Auto-configuration)？
- 是 Spring Boot 的核心功能之一。
- Spring Boot 會根據你專案中加入的函式庫（dependencies），自動判斷並配置 Spring 應用程式。
- 例如，如果你加了 `spring-boot-starter-web`，它會自動配置 Tomcat 和 Spring MVC；如果你加了 `spring-boot-starter-data-jpa` 和資料庫驅動，它會自動配置 JPA 和數據源。
- 減少了大量的 XML 或 JavaConfig 手動配置工作。
- 🗣️口語化回答：就是 Spring Boot 很聰明，看你專案裡加了哪些東西，就會自動幫你把大部分基本的配置都設好，你就不需要自己寫一堆設定了。

## 重要語法或術語
- Spring IoC Container
- Dependency Injection (DI)
- Auto-configuration (自動配置)
- Starter Dependencies
- Embedded Server (內嵌伺服器)
- `@SpringBootApplication`
- `@Controller`, `@RestController`
- `@Service`
- `@Repository`
- `@Component`
- `@Autowired`
- `@Configuration`, `@Bean`
- Spring MVC
- Spring Data JPA
- Spring Security
- Actuator

## 面試常見問法與回答

### Q1：你在專案中主要是怎麼使用 Spring Boot 的？請描述一個你負責的功能是如何利用 Spring Boot 實現的。
- Q：你在專案中主要是怎麼使用 Spring Boot 的？請描述一個你負責的功能是如何利用 Spring Boot 實現的。
- 主要用於建立後端 RESTful API 服務。
- 以會員註冊功能為例：
    - 建立一個 `@RestController` 處理 `/register` 的 POST 請求。
    - 請求進來後，Controller 將接收到的會員資料 (JSON) 傳給 `@Service` 層的會員服務。
    - Service 層進行業務邏輯檢查（如用戶名是否已存在），然後呼叫 `@Repository` 層的 DAO (Data Access Object)。
    - Repository 層使用 Spring Data JPA 將會員資料存入資料庫。
    - Service 層根據結果回傳成功或失敗訊息給 Controller。
    - Controller 再以 JSON 格式回傳給前端，並設置適當的 HTTP Status Code。
- 🗣️口語化回答：我主要是用它來開發後端 API。比如做會員註冊，我就寫一個 Controller 接收請求，交給 Service 處理業務邏輯，Service 再叫 Repository 存到資料庫，最後把結果回傳給前端。

### Q2：你在使用 Spring Boot 時，覺得最方便或最有挑戰性的是什麼？
- Q：你在使用 Spring Boot 時，覺得最方便或最有挑戰性的是什麼？
- **最方便**：自動配置和 Starter 依賴，可以非常快速地啟動一個功能齊全的專案原型，省去大量配置時間。內嵌伺服器讓部署也很簡單。
- **最有挑戰性**：有時候自動配置會「過度」配置了一些不需要的功能，需要手動排除或調整。理解底層的 Spring 如何運作，以及各種 Starter 依賴之間的關係，在遇到複雜問題時需要花一些時間深入研究。GC 和效能調優在大型應用中也是需要關注的點。
- 🗣️口語化回答：最方便的是它自動幫我把很多東西都設好了，可以很快開始寫程式。比較有挑戰的是，有時候它「太」自動了，出問題時可能需要花點時間去搞清楚它到底怎麼配置的。

---

# 六、Java 筆試程式實作題

---

### 題目：印出靠左下對齊的直角三角形

#### 📋 題目說明：
請撰寫一個 Java 程式，根據使用者輸入的行數 `n`，印出一個靠左下對齊的直角三角形，該三角形由星號（`*`）組成。

程式需要讀取使用者輸入的一個正整數，代表三角形的總行數。然後，程式會從第一行開始印製，第一行一個星號，第二行兩個星號，直到第 `n` 行印製 `n` 個星號為止。每行結束後換行。

#### 📥 範例輸入：
```
請輸入三角形的行數：5
```

#### 📤 預期輸出：
```
*
**
***
****
*****
```

#### ✅ Java 解答：
```java
import java.util.Scanner;

public class LeftBottomTriangle {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("請輸入三角形的行數：");
        int numRows = scanner.nextInt();

        if (numRows <= 0) {
            System.out.println("行數必須是正整數。");
        } else {
            // 外層迴圈控制行數
            for (int i = 1; i <= numRows; i++) {
                // 內層迴圈控制每行印出的星號數量
                for (int j = 1; j <= i; j++) {
                    System.out.print("*");
                }
                // 每行結束後換行
                System.out.println();
            }
        }

        scanner.close();
    }
}
```

#### 📌 重點解析：
- **程式架構**：程式包含一個 `main` 方法，用於處理使用者輸入和控制印出邏輯。主要邏輯是使用巢狀迴圈來建立圖形。
- **Java 語法與邏輯技巧**：
    *   `Scanner` 類別用於從標準輸入（鍵盤）讀取使用者輸入的整數。
    *   `for` 迴圈是此題的關鍵。外層迴圈 `for (int i = 1; i <= numRows; i++)` 控制要印製的總行數，變數 `i` 代表當前行數。
    *   內層迴圈 `for (int j = 1; j <= i; j++)` 控制當前行要印出多少個星號。注意這裡的迴圈條件 `j <= i`，表示星號的數量等於當前行數 `i`。
    *   `System.out.print("*")` 用於在同一行印出星號，不換行。
    *   `System.out.println()` 在內層迴圈結束後調用，用於在印完一行的星號後進行換行，以便開始下一行的印製。
    *   程式也包含了對輸入行數是否為正整數的基本判斷，避免因無效輸入導致非預期行為。
- **陷阱或常見錯誤**：
    *   最常見的錯誤是內層迴圈的條件設定錯誤，導致印出的星號數量不符合預期。
    *   混淆 `System.out.print` 和 `System.out.println` 的使用，可能導致所有星號印在同一行或過早換行。
    *   忘記關閉 `Scanner` (雖然不是必須，但養成習慣較好)。
✅ 本題考驗對巢狀迴圈的理解和運用，是基礎的圖形印出題型。

---

### 題目：印出九九乘法表

#### 📋 題目說明：
請撰寫一個 Java 程式，印出一個標準的九九乘法表。九九乘法表應包含從 `1 x 1` 到 `9 x 9` 的所有乘積。

程式的輸出需要有良好的格式排版，使得每一行的數字對齊，方便閱讀。通常會讓每個乘法結果佔據固定的寬度。

#### 📥 範例輸入：
```
(無使用者輸入，程式直接運行)
```

#### 📤 預期輸出：
```
1 * 1 =  1   1 * 2 =  2   1 * 3 =  3   1 * 4 =  4   1 * 5 =  5   1 * 6 =  6   1 * 7 =  7   1 * 8 =  8   1 * 9 =  9   
2 * 1 =  2   2 * 2 =  4   2 * 3 =  6   2 * 4 =  8   2 * 5 = 10   2 * 6 = 12   2 * 7 = 14   2 * 8 = 16   2 * 9 = 18   
3 * 1 =  3   3 * 2 =  6   3 * 3 =  9   3 * 4 = 12   3 * 5 = 15   3 * 6 = 18   3 * 7 = 21   3 * 8 = 24   3 * 9 = 27   
4 * 1 =  4   4 * 2 =  8   4 * 3 = 12   4 * 4 = 16   4 * 5 = 20   4 * 6 = 24   4 * 7 = 28   4 * 8 = 32   4 * 9 = 36   
5 * 1 =  5   5 * 2 = 10   5 * 3 = 15   5 * 4 = 20   5 * 5 = 25   5 * 6 = 30   5 * 7 = 35   5 * 8 = 40   5 * 9 = 45   
6 * 1 =  6   6 * 2 = 12   6 * 3 = 18   6 * 4 = 24   6 * 5 = 30   6 * 6 = 36   6 * 7 = 42   6 * 8 = 48   6 * 9 = 54   
7 * 1 =  7   7 * 2 = 14   7 * 3 = 21   7 * 4 = 28   7 * 5 = 35   7 * 6 = 42   7 * 7 = 49   7 * 8 = 56   7 * 9 = 63   
8 * 1 =  8   8 * 2 = 16   8 * 3 = 24   8 * 4 = 32   8 * 5 = 40   8 * 6 = 48   8 * 7 = 56   8 * 8 = 64   8 * 9 = 72   
9 * 1 =  9   9 * 2 = 18   9 * 3 = 27   9 * 4 = 36   9 * 5 = 45   9 * 6 = 54   9 * 7 = 63   9 * 8 = 72   9 * 9 = 81   
```
（請注意，實際輸出應包含所有乘積並對齊）

#### ✅ Java 解答：
```java
public class MultiplicationTable {
    public static void main(String[] args) {
        // 外層迴圈控制被乘數 (1 到 9)
        for (int i = 1; i <= 9; i++) {
            // 內層迴圈控制乘數 (1 到 9)
            for (int j = 1; j <= 9; j++) {
                // 使用 printf 進行格式化輸出
                // %d 表示整數
                // %2d 表示至少佔用 2 個字元寬度，不足則在前面補空格 (右對齊)
                System.out.printf("%d * %d = %2d   ", i, j, i * j);
            }
            // 每行結束後換行
            System.out.println();
        }
    }
}
```

#### 📌 重點解析：
- **程式架構**：程式的核心是一個 `main` 方法，利用巢狀迴圈來生成九九乘法表的每一項。
- **Java 語法與邏輯技巧**：
    *   使用兩個巢狀的 `for` 迴圈：外層迴圈控制被乘數（從 1 到 9），內層迴圈控制乘數（從 1 到 9）。這確保了所有 `i * j` 的組合都被計算到。
    *   `System.out.printf()` 是實現整齊排版的關鍵。`printf` 允許使用格式化字串來控制輸出的格式。
    *   格式字串 `"%d * %d = %2d   "` 的解釋：
        *   `%d`：用於輸出整數。前面兩個 `%d` 分別對應被乘數 `i` 和乘數 `j`。
        *   `%2d`：用於輸出整數，並指定最小輸出寬度為 2 個字元。如果數字不足 2 位（例如 1 到 9），會在前面補上空格，從而實現右對齊。這對於乘積的對齊非常重要，因為乘積有 1 位數（1-9）和 2 位數（10-81）。
        *   `   `：最後加上幾個空格，用於分隔每一列的乘法項，讓表格看起來更清晰。
    *   `System.out.println()` 在內層迴圈（印完一整行）結束後調用，用於換行到下一行印製下一個被乘數的乘法表。
- **陷阱或常見錯誤**：
    *   未使用 `printf` 或格式化控制符，導致輸出數字無法對齊，排版混亂。
    *   在內層迴圈中使用 `println` 而非 `print` 或 `printf`，導致每一項乘積都單獨佔一行。
    *   迴圈範圍設置錯誤（例如從 0 開始或結束在 8），導致部分乘積遺漏或印出非預期的內容。
✅ 本題考驗對巢狀迴圈的運用以及使用 `printf` 進行格式化輸出的能力。

---

### 題目：判斷質數

#### 📋 題目說明：
請撰寫一支 Java 程式，判斷使用者輸入的一個正整數是否為質數。質數（Prime Number）是指大於 1 的自然數中，除了 1 和它本身以外不再有其他因數的數。2 是最小的質數，也是唯一一個偶數質數。

程式需要讀取使用者輸入的一個整數，然後判斷這個數字是否滿足質數的定義，最後印出判斷結果。

#### 📥 範例輸入：
```
請輸入數字：7
```

#### 📤 預期輸出：
```
7 是質數
```

#### ✅ Java 解答：
```java
import java.util.Scanner;

public class PrimeChecker {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("請輸入數字：");
        int num = sc.nextInt();
        boolean isPrime = true; // 假設是質數

        // 根據質數定義進行判斷
        if (num <= 1) { // 小於等於 1 的數不是質數
            isPrime = false;
        } else if (num == 2) { // 2 是唯一的偶數質數
            isPrime = true;
        } else if (num % 2 == 0) { // 大於 2 的偶數都不是質數
            isPrime = false;
        }
        else {
            // 從 3 開始檢查，每次跳過偶數（步長為 2）
            // 只需檢查到數字的平方根即可
            for (int i = 3; i * i <= num; i = i + 2) {
                if (num % i == 0) { // 如果能被 i 整除，則不是質數
                    isPrime = false;
                    break; // 找到一個因數即可確定不是質數，提前結束迴圈
                }
            }
        }

        if (isPrime) {
            System.out.println(num + " 是質數");
        } else {
            System.out.println(num + " 不是質數");
        }

        sc.close();
    }
}
```

#### 📌 重點解析：
- **程式架構**：程式包含一個 `main` 方法，接收使用者輸入，並使用一系列條件判斷和一個迴圈來執行質數檢查邏輯。使用一個 `boolean` 變數 `isPrime` 作為狀態旗標。
- **Java 語法與邏輯技巧**：
    *   `Scanner` 取得使用者輸入。
    *   **邏輯判斷**：
        *   首先，根據質數定義，數字必須大於 1。所以 `num <= 1` 的情況直接判定不是質數。
        *   數字 2 是特例，它是最小的質數，需要單獨判斷。
        *   所有大於 2 的偶數都不是質數，因為它們都能被 2 整除。這個判斷 `num % 2 == 0` 可以排除掉一半的檢查數字，提高效率。
    *   **迴圈檢查**：對於剩下的奇數情況，我們需要檢查它是否還有其他的因數。
        *   迴圈從 3 開始檢查。
        *   **優化**：一個數 `num` 如果有大於其平方根的因數 `k`，那麼它必然也有一個小於其平方根的因數 `num / k`。因此，我們只需要檢查從 3 到 `sqrt(num)` 之間的數即可。在程式中，使用 `i * i <= num` 作為迴圈條件，避免了計算平方根（`Math.sqrt()` 返回 `double`，轉換回 `int` 可能有精度問題且通常較慢），這是一種常見的整數優化技巧。
        *   **優化**：由於已經排除了偶數，所以我們只檢查奇數作為潛在因數，迴圈步長設定為 `i = i + 2`。
        *   `num % i == 0` 檢查 `num` 是否能被當前的 `i` 整除。如果能，說明 `num` 有除了 1 和本身以外的因數，因此不是質數，將 `isPrime` 設定為 `false`。
        *   `break` 語句：一旦找到一個因數，就可以確定 `num` 不是質數了，無需繼續檢查下去，使用 `break` 可以提前跳出迴圈，提高效率。
    *   最後根據 `isPrime` 的值印出結果。
- **陷阱或常見錯誤**：
    *   忘記處理 `num <= 1` 的情況。
    *   迴圈範圍設定錯誤，例如檢查到 `num` 或 `num/2`，雖然結果正確但效率較低。檢查到 `sqrt(num)` 是標準優化。
    *   未考慮或單獨處理數字 2，或未排除偶數因數檢查，導致檢查次數不必要地增加。
    *   在迴圈找到因數後，忘記使用 `break`，導致不必要的後續檢查。
    *   使用 `Math.sqrt()` 後未正確處理 `double` 到 `int` 的轉換或比較。使用 `i * i <= num` 是更好的整數比較方式。
✅ 本題考驗條件判斷、迴圈結構、數論基本概念、以及基本的程式優化技巧。

---

### 題目：印出前 N 個費式數列

#### 📋 題目說明：
請撰寫一個 Java 程式，印出費式數列（Fibonacci Sequence）的前 `N` 個數字。費式數列的定義是：數列中的每個數字是前兩個數字的和。數列通常從 0 和 1 開始，所以前幾個數字是 0, 1, 1, 2, 3, 5, 8, 13, ...

程式需要讀取使用者輸入的一個正整數 `N`，然後計算並印出費式數列中的前 `N` 個數字。數字之間可以用逗號或空格分隔。

#### 📥 範例輸入：
```
請輸入要印出的費式數列項數 (N)：10
```

#### 📤 預期輸出：
```
費式數列的前 10 項為：0, 1, 1, 2, 3, 5, 8, 13, 21, 34
```

#### ✅ Java 解答：
```java
import java.util.Scanner;

public class FibonacciSequence {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("請輸入要印出的費式數列項數 (N)：");
        int n = scanner.nextInt();

        if (n <= 0) {
            System.out.println("項數必須是正整數。");
        } else {
            System.out.print("費式數列的前 " + n + " 項為：");

            // 初始化前兩個費式數
            long num1 = 0;
            long num2 = 1;

            // 處理 N=1 和 N=2 的情況，以及後續的迭代
            if (n >= 1) {
                System.out.print(num1); // 印出第一項 (0)
            }
            if (n >= 2) {
                System.out.print(", " + num2); // 印出第二項 (1)
            }

            // 從第三項開始計算並印出
            for (int i = 3; i <= n; i++) {
                long nextNum = num1 + num2; // 計算下一項
                System.out.print(", " + nextNum); // 印出下一項

                // 更新 num1 和 num2，為下一次計算做準備
                num1 = num2;
                num2 = nextNum;
            }

            System.out.println(); // 最後換行

        }

        scanner.close();
    }
}
```

#### 📌 重點解析：
- **程式架構**：程式以迭代（Iteration）的方式計算費式數列。它維護兩個變數，分別儲存當前計算所需的費式數。
- **Java 語法與邏輯技巧**：
    *   `Scanner` 取得使用者輸入的項數 `n`。
    *   **基本情況處理**：費式數列的前兩項是固定的 0 和 1。程式首先初始化 `num1 = 0` 和 `num2 = 1`。對於 `n=1` 和 `n=2` 的情況需要特別處理，直接印出對應的項。
    *   **迭代計算**：對於 `n > 2` 的情況，使用 `for` 迴圈從第三項開始計算到第 `n` 項。
    *   在迴圈的每一次迭代中：
        *   `long nextNum = num1 + num2;`：計算下一項費式數，它是前兩項 (`num1` 和 `num2`) 的和。
        *   `System.out.print(", " + nextNum);`：印出計算出的下一項。使用 `print` 並加上逗號和空格，以便將數字分隔開。
        *   `num1 = num2;` 和 `num2 = nextNum;`：這是迭代的關鍵步驟。將原來的第二項 (`num2`) 變成新的第一項，將剛計算出的下一項 (`nextNum`) 變成新的第二項，為計算再下一項做準備。
    *   **資料型別選擇**：費式數列增長非常快，使用 `long` 型別而不是 `int` 可以避免對於較大的 `N` 發生整數溢位。
    *   **格式化輸出**：注意在印出第一項後，後續的項前面都加上了逗號和空格，以符合範例輸出的格式。
- **陷阱或常見錯誤**：
    *   忘記處理 `n=1` 和 `n=2` 的邊界情況。
    *   迭代時更新 `num1` 和 `num2` 的順序或邏輯錯誤。正確的順序應該是先計算出 `nextNum`，然後再更新 `num1` 和 `num2`。
    *   使用 `int` 型別來儲存費式數，當 `n` 較大時（例如超過 45），會發生整數溢位，導致結果錯誤。
    *   使用遞歸方式實現（如下面註釋中所示），雖然直觀，但效率非常低（會有重複計算），在面試中可能被要求改為迭代實現。
✅ 本題考驗對迭代的理解、變數的追蹤更新，以及對資料型別溢位問題的認識。迭代法是解決此類問題的常見高效方式。

---

### 題目：回文判斷（isPalindrome）

#### 📋 題目說明：
請撰寫一個 Java 程式，判斷使用者輸入的一個字串是否為回文（Palindrome）。回文字串是指一個字串從前往後讀與從後往前讀是完全相同的。例如 "level", "madam", "racecar" 都是回文字串。

程式需要讀取使用者輸入的一個字串，然後判斷這個字串是否滿足回文的條件，最後印出判斷結果。本題假設只比較字母本身，不考慮大小寫差異、空格或標點符號（如果需要處理這些，題目會明確說明；對於基礎題，通常只考慮字串本身）。

#### 📥 範例輸入：
```
請輸入一個字串：madam
```

#### 📤 預期輸出：
```
"madam" 是回文字串
```

#### ✅ Java 解答：
```java
import java.util.Scanner;

public class PalindromeChecker {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("請輸入一個字串：");
        String inputString = scanner.nextLine();

        boolean isPalindrome = true;
        int length = inputString.length();

        // 使用雙指標從兩端向中間檢查
        for (int i = 0; i < length / 2; i++) {
            // 比較從開頭算起第 i 個字元 和 從結尾算起第 i 個字元
            if (inputString.charAt(i) != inputString.charAt(length - 1 - i)) {
                isPalindrome = false; // 發現不匹配的字元
                break; // 一旦發現不匹配，即可確定不是回文，提前結束迴圈
            }
        }

        if (isPalindrome) {
            System.out.println("\"" + inputString + "\" 是回文字串");
        } else {
            System.out.println("\"" + inputString + "\" 不是回文字串");
        }

        scanner.close();
    }
}
```

#### 📌 重點解析：
- **程式架構**：程式的核心邏輯是遍歷字串的一半，比較對稱位置的字元。使用一個 `boolean` 旗標 `isPalindrome` 記錄判斷結果。
- **Java 語法與邏輯技巧**：
    *   `Scanner.nextLine()` 用於讀取包含空格的完整一行字串。
    *   `String.length()` 取得字串的長度。
    *   `String.charAt(index)` 取得指定索引位置的字元。
    *   **核心邏輯**：回文的特性是從頭到尾和從尾到頭相同。我們只需要比較字串前半部分的字元和後半部分對應位置的字元即可。
    *   `for` 迴圈：迴圈從索引 0 開始，遍歷到 `length / 2`。這樣可以遍歷到字串的中間位置。如果字串長度是奇數，中間那個字元無需與任何字元比較，因為它總是和自己相同。所以迴圈到 `length / 2 - 1` 或 `< length / 2` 即可。
    *   在迴圈內部，比較 `inputString.charAt(i)` 和 `inputString.charAt(length - 1 - i)`。`i` 是從開頭算起的索引，`length - 1 - i` 是從結尾算起對應位置的索引。例如，當 `i=0` 時，比較第一個字元和最後一個字元（索引 `length - 1`）；當 `i=1` 時，比較第二個字元和倒數第二個字元（索引 `length - 2`），以此類推。
    *   如果發現任意一對字元不相同，則可以立即確定字串不是回文，將 `isPalindrome` 設為 `false` 並使用 `break` 跳出迴圈，提高效率。
    *   迴圈正常結束（即沒有執行 `break`）時，`isPalindrome` 仍為 `true`，表示所有對稱位置的字元都相同。
- **陷阱或常見錯誤**：
    *   迴圈範圍設定錯誤，例如遍歷了整個字串（到 `length - 1`），導致重複比較或索引越界。正確範圍是到 `length / 2`。
    *   計算對稱位置索引的公式錯誤，常見錯誤是使用 `length - i` 或 `length - i - 0`。正確應為 `length - 1 - i`。
    *   未考慮或未處理字串長度為 0 或 1 的情況。通常這些情況會被視為回文，程式中的迴圈對於長度小於 2 的字串不會執行，`isPalindrome` 保持 `true`，結果正確。
    *   如果題目要求忽略大小寫或非字母字元，則需要額外處理，例如將字串轉換為小寫 (`toLowerCase()`) 並過濾掉非字母字元後再進行比較。
✅ 本題考驗對字串操作（獲取長度、獲取字元）的熟悉以及如何運用雙指標或單指標遍歷字串進行對稱性檢查的邏輯。

---

### 題目：陣列最大值與最小值

#### 📋 題目說明：
請撰寫一個 Java 程式，找出一個整數陣列中的最大值和最小值。

程式需要定義一個整數陣列（可以預設好，也可以接收使用者輸入的數字來建立），然後遍歷這個陣列，找到其中數值最大的元素和數值最小的元素，最後印出這兩個值。

#### 📥 範例輸入：
```
假設陣列為：[12, 45, 6, 89, 23, 5, 90]
```

#### 📤 預期輸出：
```
陣列為：[12, 45, 6, 89, 23, 5, 90]
陣列中的最大值是：90
陣列中的最小值是：5
```

#### ✅ Java 解答：
```java
import java.util.Scanner; // 如果需要使用者輸入陣列元素
import java.util.Arrays; // 可以用於印出陣列，非必需

public class FindMinMax {
    public static void main(String[] args) {
        // 範例陣列，實際應用中可以從使用者輸入或其他來源獲取
        int[] numbers = {12, 45, 6, 89, 23, 5, 90};

        // 檢查陣列是否為空
        if (numbers == null || numbers.length == 0) {
            System.out.println("陣列為空，無法找到最大值和最小值。");
            return; // 結束程式
        }

        // 初始化最大值和最小值
        // 假設陣列的第一個元素是目前的最小值和最大值
        int max = numbers[0];
        int min = numbers[0];

        // 遍歷陣列，從第二個元素開始比較
        for (int i = 1; i < numbers.length; i++) {
            // 如果當前元素大於目前的最大值，更新最大值
            if (numbers[i] > max) {
                max = numbers[i];
            }
            // 如果當前元素小於目前的最小值，更新最小值
            if (numbers[i] < min) {
                min = numbers[i];
            }
        }

        // 印出結果
        System.out.println("陣列為：" + Arrays.toString(numbers)); // 選用，方便查看陣列內容
        System.out.println("陣列中的最大值是：" + max);
        System.out.println("陣列中的最小值是：" + min);
    }
}
```

#### 📌 重點解析：
- **程式架構**：程式定義一個陣列，然後通過一次遍歷來同時尋找最大值和最小值。
- **Java 語法與邏輯技巧**：
    *   **陣列**：使用 `int[] numbers = { ... };` 創建一個整數陣列。
    *   **初始化**：在開始遍歷之前，需要設定最大值和最小值的初始參考值。一個簡單有效的方法是將陣列的第一個元素同時設定為初始的最大值和最小值 (`max = numbers[0]; min = numbers[0];`)。這樣可以確保無論陣列包含正數、負數還是零，初始值都在陣列的有效範圍內。
    *   **遍歷**：使用一個 `for` 迴圈，從陣列的第二個元素（索引為 1）開始遍歷到最後一個元素 (`i < numbers.length`)。從第二個元素開始是因為第一個元素已經被用作初始值了。
    *   **條件判斷**：在迴圈的每一次迭代中，將當前的元素 `numbers[i]` 分別與當前的最大值 `max` 和最小值 `min` 進行比較。
        *   `if (numbers[i] > max)`：如果當前元素大於當前的最大值，則更新 `max = numbers[i]`。
        *   `if (numbers[i] < min)`：如果當前元素小於當前的最小值，則更新 `min = numbers[i]`。
    *   經過一次完整的遍歷後，`max` 變數將儲存陣列中的最大值，`min` 變數將儲存陣列中的最小值。
    *   **邊界情況**：程式檢查了陣列是否為 `null` 或長度為 0，以防止在空陣列上嘗試存取元素而導致運行時錯誤 (`ArrayIndexOutOfBoundsException`)。
- **陷阱或常見錯誤**：
    *   初始化最大值為 0 或一個很小的數，最小值為一個很大的數（例如 `Integer.MAX_VALUE` 和 `Integer.MIN_VALUE`）。這種方法雖然可行，但如果陣列中所有數字都是負數或正數，可能會導致初始值設定不當。將第一個元素作為初始值是更穩健的方法。
    *   遍歷時的迴圈範圍錯誤，例如從索引 0 開始遍歷，或者迴圈條件錯誤。
    *   在遍歷前未檢查陣列是否為空或 `null`。
    *   錯誤地嘗試在一次判斷中同時更新 max 和 min。它們需要分開判斷。
✅ 本題考驗對陣列的基本操作（遍歷）以及使用變數追蹤最大/最小值的邏輯。這是一個基礎的陣列處理問題。

---

### 題目：氣泡排序

#### 📋 題目說明：
請撰寫一個 Java 程式，使用氣泡排序（Bubble Sort）演算法對一個整數陣列進行升序排序。氣泡排序是一種簡單的排序演算法，它重複地遍歷待排序的列表，比較相鄰的兩個元素，如果它們順序錯誤就把它們交換過來。遍歷列表的工作是重複地進行直到沒有再需要交換，也就是說該列表已經排序完成。

程式需要定義一個整數陣列（可以預設好），然後應用氣泡排序演算法對其進行排序，最後印出排序後的陣列。

#### 📥 範例輸入：
```
假設陣列為：[64, 34, 25, 12, 22, 11, 90]
```

#### 📤 預期輸出：
```
原始陣列: [64, 34, 25, 12, 22, 11, 90]
排序後的陣列: [11, 12, 22, 25, 34, 64, 90]
```

#### ✅ Java 解答：
```java
import java.util.Arrays;

public class BubbleSort {

    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        // 外層迴圈控制排序的趟數
        // 每趟結束後，最大的未排序元素會"浮"到其最終位置
        for (int i = 0; i < n - 1; i++) {
            boolean swapped = false; // 標記，用於提前結束排序（優化）

            // 內層迴圈用於比較和交換相鄰元素
            // j 的範圍會隨著外層迴圈的 i 減少，因為後面 i 個元素已經有序
            for (int j = 0; j < n - 1 - i; j++) {
                // 如果當前元素比下一個元素大，則交換它們
                if (arr[j] > arr[j + 1]) {
                    // 交換 arr[j] 和 arr[j+1]
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true; // 發生了交換
                }
            }

            // 如果在一趟排序中沒有發生任何交換，說明陣列已經有序
            if (!swapped) {
                break; // 提前結束外層迴圈
            }
        }
    }

    public static void main(String[] args) {
        int[] data = {64, 34, 25, 12, 22, 11, 90};

        System.out.println("原始陣列: " + Arrays.toString(data));

        bubbleSort(data); // 調用排序方法

        System.out.println("排序後的陣列: " + Arrays.toString(data));
    }
}
```

#### 📌 重點解析：
- **程式架構**：程式包含一個單獨的方法 `bubbleSort` 來執行排序邏輯，並在 `main` 方法中調用此方法並印出結果。將排序邏輯封裝在方法中有利於代碼重用和組織。
- **Java 語法與邏輯技巧**：
    *   **陣列傳遞**：Java 中陣列作為物件傳遞，方法內部對陣列元素的修改會影響到方法外部的原始陣列。`bubbleSort(data)` 調用後，`data` 陣列就被原地修改排序了。
    *   **巢狀迴圈**：氣泡排序的核心是兩個巢狀的 `for` 迴圈。
        *   外層迴圈 `for (int i = 0; i < n - 1; i++)`：控制排序的「趟數」。一個長度為 `n` 的陣列最多需要 `n-1` 趟就可以完全排序。每一趟至少能將一個元素放到其最終的正確位置（最大的那個）。
        *   內層迴圈 `for (int j = 0; j < n - 1 - i; j++)`：用於遍歷未排序部分的元素，比較並交換相鄰元素。
            *   比較範圍 `j` 到 `j+1`。
            *   迴圈的結束條件是 `n - 1 - i`，這是因為外層迴圈每完成一趟（`i` 增加 1），最後 `i` 個元素就已經是排序好的，無需再參與比較。例如，第一趟 (`i=0`) 最大的元素就到了最後 (`n-1`)，第二趟 (`i=1`) 次大的元素到了倒數第二 (`n-2`)，依此類推。所以內層迴圈的比較範圍逐漸縮小。
    *   **比較與交換**：`if (arr[j] > arr[j + 1])` 檢查相鄰元素順序是否錯誤。如果需要交換（升序中前一個大於後一個），則使用一個臨時變數 `temp` 完成值的交換：
        ```java
        int temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
        ```
    *   **優化**：添加一個 `boolean swapped` 旗標。如果在一次完整的內層迴圈遍歷中沒有發生任何交換 (`swapped` 保持為 `false`)，這說明陣列已經完全有序，可以提前使用 `break` 結束外層迴圈，避免不必要的比較。
- **陷阱或常見錯誤**：
    *   內層迴圈的結束條件設置錯誤，例如仍然遍歷到 `n-1`，可能導致比較到已經排序好的元素或發生索引越界 (`ArrayIndexOutOfBoundsException`，如果比較到 `j+1` 且 `j` 到了 `n-1`)。
    *   交換邏輯錯誤，導致元素值丟失或交換不正確。使用臨時變數是標準且安全的方法。
    *   忘記添加優化（`swapped` 旗標），對於已經部分有序或完全有序的陣列，會進行不必要的遍歷。
    *   嘗試使用其他更高效的排序演算法（如快速排序、合併排序等）回答氣泡排序問題，雖然那些演算法更優，但題目明確要求氣泡排序。
✅ 本題考驗對經典排序演算法——氣泡排序的實現能力，包括巢狀迴圈的運用、相鄰元素的比較與交換邏輯，以及基本的效能優化思路。

---

### 題目：不使用第三變數交換兩數

#### 📋 題目說明：
請撰寫一個 Java 程式，在不使用額外的第三個變數（如 temp）的情況下，交換兩個整數變數的值。

程式需要定義兩個整數變數並賦予初始值，然後執行交換邏輯，最後印出交換後兩個變數的值。

#### 📥 範例輸入：
```
初始值: a = 5, b = 10
```

#### 📤 預期輸出：
```
交換前: a = 5, b = 10
交換後: a = 10, b = 5
```

#### ✅ Java 解答：
```java
public class SwapWithoutTemp {
    public static void main(String[] args) {
        int a = 5;
        int b = 10;

        System.out.println("交換前: a = " + a + ", b = " + b);

        // 使用數學運算交換 (加減法)
        // b = a + b; // b 現在是 a 和 b 的總和 (5 + 10 = 15)
        // a = b - a; // a 現在是 (a+b) - a = b (15 - 5 = 10)
        // b = b - a; // b 現在是 (a+b) - b = a (15 - 10 = 5)

        // 使用位元運算交換 (XOR) - 這種方式更常見且不容易溢位
        // 原理: XOR 運算 ^ 具有性質 A ^ B ^ B = A
        a = a ^ b; // a 現在是原始 a ^ 原始 b
        b = a ^ b; // b 現在是 (原始 a ^ 原始 b) ^ 原始 b = 原始 a
        a = a ^ b; // a 現在是 (原始 a ^ 原始 b) ^ 原始 a = 原始 b


        System.out.println("交換後: a = " + a + ", b = " + b);
    }
}
```

#### 📌 重點解析：
- **程式架構**：程式直接在 `main` 方法中定義變數並執行交換邏輯。
- **Java 語法與邏輯技巧**：
    *   本題的關鍵在於利用數學運算或位元運算的特性來實現值的交換，而無需額外的存儲空間。
    *   **方法一：數學運算 (加減法)**
        1.  `b = a + b;`：將 `a` 和 `b` 的和存入 `b`。此時 `b` 包含了原始 `a` 的信息。
        2.  `a = b - a;`：新的 `b` (原始a + 原始b) 減去原始 `a`，結果就是原始 `b` 的值，賦給 `a`。此時 `a` 已經得到原始 `b` 的值。
        3.  `b = b - a;`：新的 `b` (原始a + 原始b) 減去新的 `a` (原始b)，結果就是原始 `a` 的值，賦給 `b`。此時 `b` 已經得到原始 `a` 的值。
        *   **注意：** 這種方法在數字很大時可能存在整數溢位的風險。
    *   **方法二：位元運算 (XOR)**
        1.  `a = a ^ b;`：計算 `a` 和 `b` 的 XOR 結果，存入 `a`。
        2.  `b = a ^ b;`：計算當前 `a` (原始a ^ 原始b) 和原始 `b` 的 XOR 結果。根據 XOR 的性質 `(X ^ Y) ^ Y = X`，結果是原始 `a` 的值，賦給 `b`。
        3.  `a = a ^ b;`：計算當前 `a` (原始a ^ 原始b) 和當前 `b` (原始a) 的 XOR 結果。根據 XOR 的性質 `(X ^ Y) ^ X = Y`，結果是原始 `b` 的值，賦給 `a`。
        *   **優點：** 這種方法不會產生溢位問題，通常比加減法更推薦。
- **陷阱或常見錯誤**：
    *   沒有正確理解加減法或 XOR 交換的邏輯順序，導致交換失敗或結果錯誤。
    *   未考慮整數溢位的問題（僅限於加減法）。
    *   對於要求「不使用第三變數」的問題，使用了臨時變數來實現交換。
✅ 本題考驗對基本運算符的理解和運用，特別是如何利用數學或位元運算的性質來實現特定邏輯。

---

# 七、JavaScript 語法重點

## 重點摘要
JavaScript 是前端開發的基石，也是全端工程師需要掌握的重要語言。本節整理了 JavaScript 中常用且容易考的概念，包括變數宣告、非同步處理、`this` 的作用域以及型別比較等。

## 常用語法：

### 📌 宣告：var / let / const 差異
- **`var`：** 函數作用域 (Function Scope)。存在變數提升 (Hoisting)，但賦值不會提升。可以重複宣告和修改。在現代 JavaScript 開發中較少使用，容易造成作用域混亂。
- **`let`：** 區塊作用域 (Block Scope)。存在暫時性死區 (Temporal Dead Zone, TDZ)，宣告前不可使用。可以修改，但不可在同一個區塊內重複宣告。適用於變數值會改變的場景。
- **`const`：** 區塊作用域 (Block Scope)。同樣存在暫時性死區 (TDZ)。宣告時必須初始化，且宣告後不可再賦予新的值 (對於基本類型是值不可變，對於引用類型是引用地址不可變，但物件/陣列本身的內容可以修改)。適用於宣告不會再重新賦值的常量或引用。

---

### 📌 非同步處理：Promise vs async/await
- **非同步 (Asynchronous)：** 指程式碼在執行非同步操作時不會阻塞主線程，可以繼續執行後續程式碼，直到非同步操作完成後再處理結果。
- **Promise：** 用於處理非同步操作的一種模式。代表一個非同步操作的最終完成或失敗及其結果值。有三種狀態：Pending (進行中), Fulfilled (已成功), Rejected (已失敗)。通過 `.then()` 處理成功結果，`.catch()` 處理失敗結果，`.finally()` 無論成功失敗都會執行。
- **async/await：** 是 Promise 的語法糖 (Syntactic Sugar)，讓非同步程式碼寫起來更像同步程式碼，提高可讀性。
    - `async` 關鍵字用於宣告一個函數為非同步函數，該函數會回傳一個 Promise。
    - `await` 關鍵字只能在 `async` 函數內部使用，用於等待一個 Promise 解決 (resolved)。`await` 會暫停 `async` 函數的執行，直到 Promise 完成，然後回傳 Promise 的結果。如果 Promise 失敗，`await` 會拋出異常，需要使用 `try...catch` 處理。

#### 範例：
```js
// 使用 Promise
function fetchData(url) {
  return new Promise((resolve, reject) => {
    fetch(url)
      .then(response => response.json())
      .then(data => resolve(data))
      .catch(error => reject(error));
  });
}

fetchData('/api/users')
  .then(users => console.log(users))
  .catch(error => console.error('Error fetching data:', error));

// 使用 async/await (推薦)
async function fetchDataAsync(url) {
  try {
    const response = await fetch(url);
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Error fetching data:', error);
  }
}

fetchDataAsync('/api/users');
```

#### 解說：
- `Promise` 需要使用 `.then()` 和 `.catch()` 的鏈式調用來處理結果。
- `async/await` 則允許你使用更直觀的 `try...catch` 區塊來處理成功和失敗，程式碼流程更線性。

---

### 📌 `this` 的作用域變化
- **`this`：** 在 JavaScript 中，`this` 的值取決於函數被「如何」調用，而不是被「在哪裡」定義。這使得 `this` 的行為相對複雜且容易出錯。
- **常見的 `this` 綁定規則：**
    - **預設綁定 (Default Binding)：** 在非嚴格模式下，獨立函數調用 (`function()`) 時，`this` 指向全域物件 (`window` 或 `global`)；在嚴格模式 (`'use strict'`) 下，`this` 指向 `undefined`。
    - **隱式綁定 (Implicit Binding)：** 當函數作為物件的方法調用時 (`object.method()`)，`this` 指向調用該方法的物件 (`object`)。
    - **顯式綁定 (Explicit Binding)：** 使用 `call()`, `apply()`, `bind()` 方法可以明確指定 `this` 的值。
        - `call()` 和 `apply()` 立即執行函數，並綁定 `this`，參數傳遞方式不同 (`call` 參數列表，`apply` 參數陣列)。
        - `bind()` 不立即執行函數，而是回傳一個綁定好 `this` 值的新函數。
    - **`new` 綁定 (New Binding)：** 使用 `new` 關鍵字調用建構函數時 (`new Constructor()`)，`this` 指向新創建的物件實例。
    - **箭頭函數 (Arrow Functions)：** 箭頭函數沒有自己的 `this` 綁定，它們的 `this` 會詞法繼承自外層（定義時的）作用域的 `this` 值。這使得箭頭函數在處理回調函數時特別有用，避免了傳統函數中 `this` 指向變化的問題。

#### 範例：
```js
const obj = {
  name: 'Alice',
  greet: function() {
    console.log('Hello, ' + this.name); // 隱式綁定，this 指向 obj
  },
  greetLater: function() {
    setTimeout(function() {
      console.log('Later, ' + this.name); // 預設綁定 (在非嚴格模式下)，this 指向全域 (name 為 undefined)
    }, 100);
  },
  greetLaterArrow: function() {
    setTimeout(() => { // 箭頭函數
      console.log('Later Arrow, ' + this.name); // 詞法繼承外層作用域的 this (指向 obj)
    }, 100);
  }
};

obj.greet(); // 輸出: Hello, Alice

obj.greetLater(); // 可能輸出: Later, undefined 或發生錯誤 (取決於嚴格模式和環境)

obj.greetLaterArrow(); // 輸出: Later Arrow, Alice
```

#### 解說：
- 傳統函數在 setTimeout 回調中，`this` 變成了全域物件，導致無法訪問 `obj.name`。
- 箭頭函數則保留了其定義時外部作用域的 `this` 值 (即 `obj`)，正確訪問到了 `obj.name`。

---

### 📌 型別比較：`==` vs `===`
- **`==` (相等運算符，Loose Equality)：** 比較時會進行強制型別轉換 (Type Coercion)。如果兩個值的型別不同，JavaScript 會嘗試將其中一個或兩個轉換為相同型別再進行比較。這可能導致一些非預期的結果。
- **`===` (嚴格相等運算符，Strict Equality)：** 比較時不會進行強制型別轉換。只有當兩個值的型別**和**值都完全相等時，才回傳 `true`。在大多數情況下，推薦使用 `===` 來避免型別轉換帶來的潛在問題。

#### 範例：
```js
console.log(1 == '1');   // 輸出: true (字串 '1' 被轉換為數字 1)
console.log(1 === '1');  // 輸出: false (數字 1 和字串 '1' 型別不同)

console.log(true == 1);  // 輸出: true (布林 true 被轉換為數字 1)
console.log(true === 1); // 輸出: false (布林和數字型別不同)

console.log(null == undefined); // 輸出: true (根據規範，null 和 undefined 用 == 比較時是相等的)
console.log(null === undefined); // 輸出: false (null 和 undefined 型別不同)

console.log('' == 0);    // 輸出: true (空字串 '' 被轉換為數字 0)
console.log('' === 0);   // 輸出: false (字串和數字型別不同)
```

#### 解說：
- `==` 在比較不同型別時會嘗試「猜測」你的意圖並進行轉換，這會降低程式碼的可預測性。
- `===` 則要求型別嚴格匹配，行為更可靠。

## 範例：

#### 範例（箭頭函數與模板字串）：
```js
const greet = (name) => `Hello, ${name}`; // 使用箭頭函數和模板字串

console.log(greet('World')); // 輸出: Hello, World
```

#### 解說：
- `(name) => ...` 是一個箭頭函數，語法更簡潔。
- `` `Hello, ${name}` `` 是一個模板字串 (Template Literal)，使用反引號包裹，可以用 `${}` 嵌入變數或表達式，方便字串拼接。

---

# 八、HTTP 基本結構與方法

## 重點摘要
HTTP (Hypertext Transfer Protocol) 是 Web 資料傳輸的基礎協定。理解 HTTP 的基本結構（請求與回應）以及常用的方法（GET, POST 等）是進行 Web 開發的根本。它定義了客戶端（瀏覽器或其他應用）如何向伺服器發送請求，以及伺服器如何回傳響應，包括狀態碼表示處理結果。

## 定義
- HTTP：超文本傳輸協定，應用層協定，用於在客戶端和伺服器之間傳輸超文本（如 HTML）和其他資源。
- 請求-回應模型：客戶端發送請求給伺服器，伺服器處理後回傳回應。
- HTTP 請求 (Request) 的基本結構：
    - **起始行 (Start Line / Request Line)**：包含請求方法 (Method)、請求 URI 和 HTTP 版本。
    - **請求標頭 (Headers)**：提供關於請求、客戶端或資源的元數據，如 `Content-Type`, `User-Agent`, `Cookie` 等。
    - **請求體 (Body)**：包含請求的實際數據，例如 POST 請求提交的表單數據或 JSON 數據 (GET, HEAD 等請求通常沒有 Body)。
- HTTP 回應 (Response) 的基本結構：
    - **起始行 (Start Line / Status Line)**：包含 HTTP 版本、狀態碼 (Status Code) 和狀態文本 (Reason Phrase)。
    - **回應標頭 (Headers)**：提供關於回應、伺服器或資源的元數據，如 `Content-Type`, `Set-Cookie`, `Cache-Control` 等。
    - **回應體 (Body)**：包含伺服器回傳的實際數據，例如 HTML 頁面、JSON 資料、圖片等 (HEAD 請求通常沒有 Body)。
- 常見 HTTP 方法：GET, POST, PUT, DELETE, HEAD, OPTIONS, PATCH。
- 常見 HTTP 狀態碼：1xx (資訊)、2xx (成功)、3xx (重定向)、4xx (客戶端錯誤)、5xx (伺服器錯誤)。

## 常考觀念 Q&A

### Q1：請說明 HTTP Request 的三個主要組成部分。
- **起始行 (Start Line)**：包含請求方法 (GET/POST 等)、資源路徑 (URI) 和 HTTP 版本。
- **標頭 (Headers)**：提供額外的資訊，例如客戶端的類型、接受的內容格式、Cookies 等。
- **請求體 (Body)**：包含要發送給伺服器的實際數據，POST 或 PUT 請求通常有 Body。
- 🗣️口語化回答：主要就是最上面一行說明要做什麼（GET/POST）、找哪個網址，再來是一堆 Header 描述細節，最後是可能會有個 Body 放要送的資料。

### Q2：請說明 HTTP Response 的三個主要組成部分。
- **起始行 (Status Line)**：包含 HTTP 版本、一個數字的狀態碼 (Status Code) 和狀態文字說明。
- **標頭 (Headers)**：提供額外的資訊，例如回傳內容的類型、Cookie 設定、快取指示等。
- **回應體 (Body)**：包含伺服器回傳的主要內容，像是網頁內容、圖片或 JSON 資料。
- 🗣️口語化回答：跟 Request 類似，有第一行狀態碼（成功還是失敗），再來是一堆 Header 描述回傳內容，最後是 Body 放實際的網頁或資料。

### Q3：GET 和 POST 方法有什麼主要區別？請從多個角度說明。
- **傳送數據方式**：GET 將數據放在 URI 的 query string 中，POST 將數據放在請求體 (Request Body) 中。
- **安全性 (數據暴露)**：GET 數據顯示在 URL 中，可能被記錄在瀏覽器歷史或伺服器日誌，不適合傳輸敏感資訊；POST 數據在 Body 中，相對較隱私。
- **數據大小限制**：GET 受限於 URL 長度 (因瀏覽器和伺服器而異)，POST 沒有嚴格限制。
- **緩存 (Caching)**：GET 請求可以被瀏覽器緩存，POST 請求通常不會被緩存。
- **冪等性**：GET 是冪等的（重複請求結果一致），POST 不是冪等的。
- **用途**：GET 主要用於獲取數據，POST 主要用於提交數據以建立或修改資源。
- 🗣️口語化回答：GET 的資料顯示在網址上，POST 藏在內容裡。GET 比較適合拿資料，POST 適合送資料去新增或修改。GET 可以被快取和重複呼叫，POST 則通常不行。

### Q4：HTTP 狀態碼 200, 404, 500 各代表什麼意思？請再舉兩個常見的狀態碼並說明。
- **200 OK**：請求成功。
- **404 Not Found**：伺服器找不到請求的資源。
- **500 Internal Server Error**：伺服器在處理請求時發生了內部錯誤。
- **201 Created**：請求成功，並建立了一個新的資源 (常用於 POST 請求)。
- **400 Bad Request**：伺服器無法理解客戶端發送的請求，請求語法錯誤。
- **401 Unauthorized**：請求需要身份驗證，但使用者尚未提供憑證或憑證無效。
- **403 Forbidden**：伺服器理解請求，但拒絕執行（沒有權限）。
- **301 Moved Permanently**：資源被永久移動到新的位置，客戶端應更新其連結。
- 🗣️口語化回答：200 是成功，404 是找不到東西，500 是伺服器自己出錯了。還有 201 是新增成功，400 是你發的請求有問題。

## 重要語法或術語
- HTTP/1.1, HTTP/2
- HTTP Request
- HTTP Response
- HTTP Method (GET, POST, PUT, DELETE, etc.)
- Status Code (狀態碼)
- Headers (標頭)
- Body (內容)
- URI / URL
- Query String
- Idempotence (冪等性)
- Cache (快取)

## 面試常見問法與回答

### Q1：你在開發後端 API 時，如何根據業務邏輯回傳正確的 HTTP Status Code？
- Q：你在開發後端 API 時，如何根據業務邏輯回傳正確的 HTTP Status Code？
- 成功讀取：回傳 200 OK。
- 成功建立資源（如註冊會員）：回傳 201 Created。
- 成功刪除或修改（無內容回傳）：回傳 204 No Content。
- 客戶端請求數據格式錯誤、缺少必要參數等：回傳 400 Bad Request。
- 請求的資源找不到：回傳 404 Not Found。
- 使用者未登入或身份驗證失敗：回傳 401 Unauthorized。
- 使用者已登入但沒有權限執行操作：回傳 403 Forbidden。
- 伺服器內部發生未預期的錯誤：回傳 500 Internal Server Error。
- 🗣️口語化回答：根據處理結果回傳不同的狀態碼，像查到東西就給 200，找不到就 404，新增成功給 201，程式自己錯了就給 500。

### Q2：HTTP 是無狀態的，那 Session 是怎麼實現的？
- Q：HTTP 是無狀態的，那 Session 是怎麼實現的？
- Session 是在伺服器端儲存客戶端狀態的一種方式。
- 為了讓伺服器「識別」是哪個客戶端的請求，通常會在客戶端和伺服器之間交換一個 Session ID。
- 常見做法是伺服器在使用者首次訪問或登入成功後，生成一個唯一的 Session ID，並將其透過 `Set-Cookie` Header 發送給客戶端。
- 客戶端（瀏覽器）收到後會將 Session ID 存儲在 Cookie 中。
- 之後客戶端每次發送請求給同一個網站時，都會自動在 `Cookie` Header 中帶上這個 Session ID。
- 伺服器收到請求後，根據 Cookie 中的 Session ID 找到對應的伺服器端 Session 數據，從而恢復客戶端的狀態。
- 🗣️口語化回答：雖然 HTTP 本身沒記憶，但我們可以用 Cookie 來記住使用者。伺服器給客戶端一個 Session ID 存在 Cookie 裡，之後客戶端每次來都帶著這個 ID，伺服器就知道是誰了。

---

# 九、RESTful API

## 重點摘要
RESTful API 是一種設計 Web 服務介面的架構風格，基於 HTTP 協定，強調以「資源」為中心，並透過標準的 HTTP 方法（GET, POST, PUT, DELETE 等）來操作這些資源。它的主要優點是架構清晰、易於理解和擴展，無狀態性使其 scalable，是目前主流的 API 設計方式，廣泛應用於前後端分離、微服務等場景。

## 定義
- REST：Representational State Transfer 的縮寫，一種用於分散式系統的架構風格。
- RESTful API：遵循 REST 原則設計的 Web API。
- 核心原則：
    - **資源 (Resource)**：網路上的實體，用 URI (Uniform Resource Identifier) 表示，如 `/users`, `/products/123`。
    - **統一介面 (Uniform Interface)**：使用標準的 HTTP 方法操作資源。
    - **無狀態 (Stateless)**：伺服器不保留客戶端狀態，每個請求都包含處理所需的所有資訊。
    - **客戶端-伺服器 (Client-Server)**：關注點分離，客戶端和伺服器獨立發展。
    - **可快取 (Cacheable)**：客戶端可以快取伺服器的響應，提升效能。
    - **分層系統 (Layered System)**：伺服器和客戶端之間的通訊可以經過多個中間層。
    - **按需程式碼 (Code on Demand)**：伺服器可以暫時擴展或自訂客戶端的功能 (可選)。

## 常考觀念 Q&A

### Q1：什麼是 RESTful API？它和 SOAP 有什麼主要區別？
- RESTful API 是一種基於 HTTP 的架構風格，以資源為中心，輕量級且彈性高，常用於 Web 和行動應用。
- SOAP 是基於 XML 的協定，相對重量級，通常使用 WSDL 描述服務，常用於企業級應用或遺留系統。
- RESTful API 更依賴 HTTP 方法，SOAP 則使用 XML 信封。
- RESTful API 無狀態，SOAP 可以是有狀態的。
- 🗣️口語化回答：RESTful 就是一種用 HTTP 方法來操作「資源」的介面設計方式，比較輕巧好用。SOAP 比較老牌、重量級，通常用 XML 來傳資料。

### Q2：GET, POST, PUT, DELETE 這幾個 HTTP 方法在 RESTful API 中通常代表什麼操作？
- GET：用於獲取資源。
- POST：用於建立新的資源。
- PUT：用於完整更新資源。
- DELETE：用於刪除資源。
- 還有 PATCH：用於部分更新資源。
- 🗣️口語化回答：GET 就是查資料，POST 是新增一筆，PUT 是把一整筆資料換新的，DELETE 是刪掉。

### Q3：RESTful API 的「無狀態」是什麼意思？為什麼重要？
- 指伺服器不會在兩次請求之間保留客戶端的任何狀態資訊。每個請求都必須包含處理該請求所需的所有資訊。
- 重要性：提高擴展性（Scaling），伺服器更容易分散到多台機器；提高可靠性，單個伺服器失敗不影響其他請求；簡化伺服器設計。
- 🗣️口語化回答：就是伺服器不會記住你上次做了什麼。每次請求都要告訴伺服器足夠的資訊讓它處理，這樣伺服器比較好擴展。

### Q4：什麼是冪等性 (Idempotence)？哪些 HTTP 方法是冪等的？
- 指對同一 URI 的同一請求執行多次，會產生相同的結果（儘管伺服器狀態可能改變）。
- 冪等方法：GET, PUT, DELETE, HEAD, OPTIONS。
- 非冪等方法：POST (多次 POST 同一數據可能建立多個資源)。PATCH 通常也非冪等，除非特別設計。
- 🗣️口語化回答：冪等就是重複發送同一個請求，產生的結果會是一樣的。像 GET、PUT、DELETE 都是，重複呼叫也不會出問題。

## 重要語法或術語
- REST
- Resource (資源)
- URI (Uniform Resource Identifier)
- Endpoint
- HTTP Methods (GET, POST, PUT, DELETE, PATCH)
- Stateless (無狀態)
- Idempotent (冪等性)
- HATEOAS (Hypermedia as the Engine of Application State) - 進階概念
- JSON / XML (資料格式)

## 面試常見問法與回答

### Q1：你在專案中是怎麼設計 RESTful API 的？請舉例說明一個資源的設計。
- Q：你在專案中是怎麼設計 RESTful API 的？請舉例說明一個資源的設計。
- 識別核心「資源」，通常用名詞表示，且常用複數 (e.g., `/users`, `/orders`)。
- 使用子資源表達關係 (e.g., `/users/{userId}/orders`)。
- 根據操作類型使用正確的 HTTP 方法 (GET 獲取、POST 建立、PUT 完整更新、DELETE 刪除)。
- 使用 HTTP Status Code 表示結果 (200 OK, 201 Created, 400 Bad Request, 404 Not Found, 500 Internal Server Error)。
- 例如：會員資源 (`/users`)。
    - `GET /users`：獲取所有會員列表。
    - `GET /users/{id}`：獲取特定 ID 的會員資料。
    - `POST /users`：新增會員。
    - `PUT /users/{id}`：完整更新特定 ID 會員資料。
    - `DELETE /users/{id}`：刪除特定 ID 會員。
- 🗣️口語化回答：我會先把系統裡的「東西」（資源）找出來，用像 `/users` 這樣名詞當網址。然後根據要做什麼動作，用對 GET/POST/PUT/DELETE 方法。

### Q2：如何在 RESTful API 中處理版本控制？
- Q：如何在 RESTful API 中處理版本控制？
- URL Path Versioning (e.g., `/v1/users`, `/v2/users`)：最直觀但修改 URI 會影響所有客戶端。
- Query Parameter Versioning (e.g., `/users?version=v1`)：對客戶端影響較小，但可能與其他參數混淆。
- Header Versioning (e.g., `Accept: application/vnd.myapp.v1+json`)：符合 REST 原則中透過 Header 進行內容協商，但客戶端實作稍複雜。
- 🗣️口語化回答：有幾種方法，最常見的是在網址裡加版本號，像是 `/v1/users`。或是放在 Header 裡，只是 Header 比較難測。

---

# 十、資安（Web Security）

## 重點摘要
Web 資安是保護網站、應用程式和使用者免受網路威脅的核心工作。範圍涵蓋防禦常見的攻擊手法如 SQL Injection、XSS、CSRF 等，並確保資料的機密性、完整性與可用性。對於全端工程師而言，理解常見的資安弱點及其防禦措施至關重要，這不僅是技術能力的要求，也是保障系統與使用者安全的基本責任。

## 定義
- Web 安全性：保護網站和 Web 應用程式及其使用者免受網路攻擊的行為和實踐。
- 常見威脅：SQL Injection (SQL 隱碼攻擊)、Cross-Site Scripting (XSS 跨站腳本攻擊)、Cross-Site Request Forgery (CSRF 跨站請求偽造)、Authentication/Authorization 繞過、Session Hijacking 等。
- 防禦策略：輸入驗證與清理、輸出編碼、使用參數化查詢、實作 CSRF Token、安全的 Session 管理、使用 HTTPS、定期安全掃描與更新函式庫等。
- OWASP Top 10：開放式 Web 應用程式安全專案列出的十大最嚴重 Web 應用程式安全風險清單，是重要的參考指標。

## 常考觀念 Q&A

### Q1：什麼是 Web 安全性？在開發中為何重要？
- 保護網站及應用程式免受惡意攻擊。
- 確保資料的機密性、完整性與可用性。
- 保護使用者隱私及信任。
- 避免潛在的法律風險與名譽損失。
- 🗣️口語化回答：Web 資安就是確保你的網站不會被駭客入侵、資料被偷或破壞，保護使用者很重要的。

### Q2：請說明 SQL Injection（隱碼攻擊）是什麼？如何防範？
- 攻擊者透過在使用者輸入欄位注入惡意的 SQL 語句。
- 利用程式未對使用者輸入進行充分過濾，導致惡意 SQL 語句被資料庫執行。
- 可能導致資料洩漏、竄改甚至刪除。
- 防範方法：使用參數化查詢（Prepared Statements）或ORM 框架、避免使用字串拼接 SQL 語句、對所有使用者輸入進行嚴格的驗證與過濾。
- 🗣️口語化回答：駭客在輸入框偷塞資料庫指令，利用程式漏洞讓資料庫執行。最簡單的防範就是用參數化查詢，不要直接把輸入跟 SQL 連起來。

### Q3：什麼是 XSS（跨站腳本攻擊）？有幾種？如何防範？
- 攻擊者將惡意腳本注入到網頁中，當其他使用者瀏覽該網頁時，惡意腳本就會在他們的瀏覽器上執行。
- 類型：儲存型 XSS（Stored XSS）、反射型 XSS（Reflected XSS）、DOM 型 XSS。
- 可能導致竊取 Cookie、Session、偽造請求等。
- 防範方法：對使用者輸入進行驗證與清理；在輸出到網頁前對所有不可信任的資料進行適當的 HTML 實體編碼（Output Encoding）。
- 🗣️口語化回答：就是駭客把惡意程式碼藏在網頁裡，當你打開網頁時程式碼就在你瀏覽器跑起來了。防範方法是在顯示使用者輸入的內容時，把一些特殊符號轉掉。

### Q4：什麼是 CSRF（跨站請求偽造）？如何防範？
- 攻擊者誘騙使用者點擊連結或圖片，利用使用者已登入的身份，在使用者不知情的情況下發送偽造的請求到目標網站。
- 目標網站會認為這是使用者自己的合法請求並執行。
- 防範方法：使用 CSRF Token（伺服器生成一個隨機 token 放入表單或 header，客戶端提交時帶回驗證）、檢查 Referer Header、使用 SameSite Cookie 屬性。
- 🗣️口語化回答：駭客騙你點一個連結，利用你網站登入中的狀態，去做一些你沒授權的事情。可以用一個只有你知道的特殊驗證碼（CSRF token）來防。

## 重要語法或術語
- SQL Injection
- XSS (Cross-Site Scripting)
- CSRF (Cross-Site Request Forgery)
- HTTPS / SSL/TLS
- OWASP Top 10
- Input Validation
- Output Encoding
- Parameterized Query
- CSRF Token
- Authentication
- Authorization
- Session Management

## 面試常見問法與回答

### Q1：你在過去的專案中，是如何考慮和實作資安的？
- Q：你在過去的專案中，是如何考慮和實作資安的？
- 針對使用者輸入，實作嚴格的驗證與清理，防止常見的注入攻擊。
- 對於資料庫操作，全部使用參數化查詢或 ORM，避免 SQL Injection。
- 開發 RESTful API 時，實作適當的身份驗證（Authentication）和權限控管（Authorization）。
- 在敏感操作上，實作 CSRF 防護（如使用框架提供的 CSRF Token）。
- 網站部署使用 HTTPS，加密傳輸過程。
- 🗣️口語化回答：主要是對所有使用者輸入都檢查和過濾，資料庫操作用安全的寫法。前後端溝通走 HTTPS，敏感操作會加上 CSRF 防護。

### Q2：如果發現專案有資安漏洞，你的處理流程是什麼？
- Q：如果發現專案有資安漏洞，你的處理流程是什麼？
- 確認漏洞的存在與影響範圍，判斷嚴重程度。
- 立刻制定修補方案並盡快實作。
- 修補完成後進行嚴格測試，確保漏洞確實被修補且未引入新的問題。
- 視情況通知相關人員（團隊、主管、使用者）。
- 檢討原因，並將防範措施納入開發流程或code review規範。
- 🗣️口語化回答：先確認漏洞，馬上修好，然後測試確保修好了，最後討論怎麼避免下次再發生。
```