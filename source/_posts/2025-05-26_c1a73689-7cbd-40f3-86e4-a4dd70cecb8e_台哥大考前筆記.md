---
title: Java 全端考前小抄筆記
date: 2023-10-27
tags:
- TCP
- HTTP
- RESTful API
- 資料庫
- SQL
- Java OOP
- GC
- 字串處理
- 例外處理
- Web Server
- Spring Boot
- JavaScript
categories:
- 程式設計
- Java
- 全端開發
---

好的，這是一份為您準備的 Java 全端考前小抄筆記，已整理並格式化為 Markdown，可直接匯入 Notion 使用。內容涵蓋您指定的重點以及後續補充的詳細資訊，並嚴格遵守程式碼格式要求。

---

# 一、TCP觀念

## 重點摘要
TCP（Transmission Control Protocol）是一種面向連線、可靠、基於位元組流的傳輸層協定。它確保資料按順序、無錯誤地送達目的地。在Web開發中，HTTP協定通常是建立在TCP之上的，因此理解TCP的連線建立（三向交握）、流量控制和錯誤處理機制，對於理解網路傳輸的可靠性、效能瓶頸以及除錯網路相關問題至關重要。雖然身為應用程式開發者不直接操作TCP，但其原理深刻影響著應用程式的行為。

## 定義
- 面向連線（Connection-oriented）：通訊雙方在傳輸資料前需要建立連線。
- 可靠性（Reliable）：通過序號、確認應答和重傳機制確保資料完整、按序到達。
- 流量控制（Flow Control）：發送方不會發送過多資料淹沒接收方緩衝區。
- 擁塞控制（Congestion Control）：避免過多資料進入網路，導致網路性能下降甚至崩潰。
- 三向交握（Three-way Handshake）：建立TCP連線的過程 (SYN, SYN-ACK, ACK)。
- 四次揮手（Four-way Handshake）：終止TCP連線的過程。

## 常考觀念 Q&A

### Q1：TCP和UDP有什麼主要區別？
- TCP是面向連線、可靠的協定，有流量控制和錯誤檢查。
- UDP是無連線、不可靠的協定，傳輸速度較快，用於對即時性要求高的場景（如串流媒體、遊戲）。
- TCP確保資料送達順序和完整性，UDP則不保證。
- 🗣️口語化回答：TCP像打電話，要先接通確認對方在，確保每句話對方都聽到並回覆；UDP像寄明信片，直接發送，不保證對方收到或收到的順序。

### Q2：TCP的三向交握是什麼？
- 客戶端發送SYN封包請求建立連線。
- 伺服器收到SYN，回傳SYN-ACK表示確認並同意建立連線。
- 客戶端收到SYN-ACK，回傳ACK確認，連線建立成功。
- 🗣️口語化回答：就是建立連線前的「你聽到嗎？」「我聽到了，你聽得到嗎？」「我聽得到了！」這三個確認步驟。

### Q3：為什麼TCP是可靠的協定？
- 使用序號(Sequence Number)和確認應答(Acknowledgement Number)追蹤資料。
- 若發送的封包未收到確認應答，會在逾時後進行重傳。
- 通過校驗和(Checksum)檢查資料在傳輸過程中是否損壞。
- 🗣️口語化回答：它會幫你追蹤發出去的每一塊資料，如果對方沒說收到，或資料錯了，它會再發一次，確保資料萬無一失。

## 重要語法或術語
- TCP/IP Protocol Suite
- Three-way Handshake
- Four-way Handshake
- Connection-oriented
- Flow Control
- Congestion Control
- Socket

## 面試常見問法與回答

### Q1：你在Web專案中遇過哪些可能跟TCP有關的網路問題？
- 連線超時：可能是伺服器負載高或網路不穩定導致TCP連線建立或維持困難。
- 資料傳輸慢：可能與TCP的流量控制或擁塞控制有關，或網路本身帶寬不足。
- 連線中斷：雙方任一方非正常關閉連線。
- 🗣️口語化回答：比較常見的是連線很久或突然斷掉，雖然底層是TCP，但實際除錯會看應用層日誌、檢查伺服器狀態，如果懷疑是網路問題，可能要請網工協助。

### Q2：身為應用程式開發者，理解TCP原理對你有什麼幫助？
- 更好理解HTTP協定的行為和效能考量。
- 除錯網路相關問題時，能更精確判斷問題可能在哪一層。
- 設計高併發系統時，理解連線資源的消耗（如Socket連線數）。
- 🗣️口語化回答：雖然不直接寫TCP層的程式，但理解它能幫助我寫出更穩定的網路應用，並在出問題時，更快知道怎麼找原因，不會只覺得是「網路爛掉」。

---

# 二、RESTful API 寫法

## 重點摘要
RESTful API 是一種設計風格，基於HTTP協定，強調資源（Resource）的概念。它使用URI來標識資源，並利用HTTP方法（GET, POST, PUT, DELETE等）來表達對資源的操作。遵循RESTful原則能讓API介面更清晰、易於理解和維護，並具備無狀態性，有利於擴展和互通。這是現代Web服務和微服務架構中非常主流的API設計方式。

## 定義
- REST (Representational State Transfer)：一種架構風格。
- RESTful：符合REST原則的API。
- 資源（Resource）：API操作的核心對象，如使用者、訂單等。
- URI (Uniform Resource Identifier)：用於唯一標識資源，通常是URL。
- HTTP 方法：用於定義對資源的操作 (GET - 讀取, POST - 建立, PUT - 更新(完整), PATCH - 更新(部分), DELETE - 刪除)。
- 無狀態（Stateless）：伺服器不儲存客戶端狀態，每次請求都包含所有必要資訊。

## 常考觀念 Q&A

### Q1：什麼樣的API設計才算RESTful？
- 使用URI標識資源，且URI中避免動詞，多用名詞複數。
- 利用HTTP方法來表達對資源的操作。
- 請求和響應之間是無狀態的。
- 可選地提供資源間的連結（HATEOAS）。
- 🗣️口語化回答：簡單來說，就是把資料當作「資源」，用像 `GET /users/1` 這種網址（URI）來找資源，用像 `POST` 或 `DELETE` 這種方法來對資源做操作，而且伺服器不記得你上次做了什麼。

### Q2：GET和POST方法有什麼區別？
- GET用於讀取資源，請求參數通常放在URL中，對長度有限制，不應有副作用，是冪等（Idempotent）且可快取的。
- POST用於建立新資源或執行特定操作，請求參數放在請求體中，無長度限制，可能有副作用，非冪等且不可快取的。
- 🗣️口語化回答：GET就像是去圖書館「查書」，只讀不改變；POST就像是「提交」一份申請表，會新增或觸發一個動作。

### Q3：PUT和PATCH方法有什麼區別？
- PUT用於完整更新資源，發送的請求體包含資源的完整新狀態，具冪等性。
- PATCH用於部分更新資源，請求體只包含需要修改的欄位，不具冪等性。
- 🗣️口語化回答：PUT像「替換」一份文件，把舊的完全換成新的；PATCH像「修改」文件中的幾段文字，只改你指定的部分。

## 重要語法或術語
- REST
- Resource
- URI/URL
- HTTP Methods (GET, POST, PUT, DELETE)
- Stateless
- JSON/XML
- HATEOAS

## 面試常見問法與回答

### Q1：你在專案中如何設計RESTful API的URI？
- 我會將資源設計為名詞複數，例如 `/users`, `/orders`。
- 獲取特定資源用 `/users/{id}` 的形式。
- 資源間的關係可能用巢狀結構，例如 `/users/{id}/orders`。
- 🗣️口語化回答：我的做法是把資料想成一個個「東西」，用複數名詞當網址，像是 `GET /users` 拿所有使用者，`GET /users/123` 拿某個使用者。

### Q2：設計API時，除了RESTful原則，你還會考慮哪些方面？
- API版本的管理 (e.g., `/v1/users`)。
- 錯誤處理和狀態碼的規範使用 (e.g., 200, 201, 400, 404, 500)。
- 安全性考量（如使用HTTPS, 身份驗證, 權限驗證）。
- API文件的撰寫（如使用Swagger/OpenAPI）。
- 🗣️口語化回答：除了遵循RESTful原則，我也會考慮版本控制、清楚的錯誤訊息和狀態碼，還有安全性，並為API寫好文件，讓前端或其他服務容易串接。

---

# 三、HTTP 基本結構與方法

## 重點摘要
HTTP（Hypertext Transfer Protocol）是Web上資料通訊的應用層協定。它基於客戶端-伺服器模型，使用簡單的請求-響應機制。理解HTTP的請求和響應結構（Header和Body）以及常用的方法是進行Web開發、除錯和效能分析的基礎。雖然HTTP是無狀態的，但可以利用Cookie和Session等機制來維護會話狀態。

## 定義
- 無狀態協定（Stateless Protocol）：伺服器不保留先前請求的狀態。
- 請求-響應模型：客戶端發送請求，伺服器回傳響應。
- HTTP 方法：定義對資源的操作類型 (GET, POST, PUT, DELETE, HEAD, OPTIONS, PATCH等)。
- HTTP 狀態碼：表示伺服器處理請求的結果 (e.g., 200 OK, 404 Not Found, 500 Internal Server Error)。
- Header：包含請求或響應的元資訊（metadata）。
- Body：包含請求或響應的實際資料（payload）。

## 常考觀念 Q&A

### Q1：什麼是HTTP狀態碼？舉幾個常見的例子？
- HTTP狀態碼是三位數字，表示伺服器處理客戶端請求的結果。
- 狀態碼分為五類：1xx (資訊), 2xx (成功), 3xx (重定向), 4xx (客戶端錯誤), 5xx (伺服器錯誤)。
- 常見例子：200 OK (成功), 201 Created (資源已建立), 400 Bad Request (請求語法錯誤), 401 Unauthorized (未授權), 403 Forbidden (禁止訪問), 404 Not Found (資源不存在), 500 Internal Server Error (伺服器內部錯誤)。
- 🗣️口語化回答：就是伺服器告訴你「它有沒有成功處理你的請求」，像 200 是成功，404 是找不到網頁，500 是伺服器內部出錯。

### Q2：HTTP是無狀態的，那如何實現購物車或使用者登入狀態？
- 利用Cookie：伺服器在響應中發送Cookie給客戶端，客戶端儲存並在後續請求中帶回。
- 利用Session：伺服器端儲存使用者狀態，並給客戶端一個Session ID（通常放在Cookie中）來識別使用者。
- 🗣️口語化回答：雖然HTTP本身不記住你，但我們可以用Cookie存在瀏覽器裡，或是讓伺服器存狀態（Session）然後給你一個ID來認你，這樣就知道你是誰、你購物車有什麼了。

### Q3：什麼是HTTP Header？有什麼用途？
- Header是HTTP請求或響應中位於Body之前的部分，包含各種元資訊。
- 用途包括：指定內容類型(Content-Type)、傳輸編碼、緩存控制(Cache-Control)、身份驗證(Authorization)、來源(Referer)、使用者代理(User-Agent)等。
- 🗣️口語化回答：Header就像是信封上的資訊，告訴伺服器或瀏覽器關於這個請求或響應的一些額外資訊，例如資料的格式、語言、要不要快取等等。

## 重要語法或術語
- HTTP/1.1, HTTP/2
- Request/Response
- HTTP Methods (GET, POST, etc.)
- HTTP Status Codes
- Header
- Body
- Stateless
- Cookie
- Session

## 面試常見問法與回答

### Q1：你在除錯前端或後端問題時，如何利用HTTP的知識？
- 我會使用瀏覽器開發者工具或Postman等工具，查看請求和響應的Header和Body，以及狀態碼。
- 通過狀態碼快速判斷問題是客戶端還是伺服器端引起。
- 檢查請求參數是否正確傳遞、響應資料格式是否符合預期。
- 🗣️口語化回答：我會用開發者工具看每次前後端傳輸的細節，看狀態碼是不是200、請求參數對不對、伺服器回來的資料格式是不是我要的，這樣很快能定位是前端發錯還是後端處理錯。

### Q2：解釋一下GET請求的參數為什麼通常放在URL中，而POST請求放在Body中？
- GET設計用於安全且冪等的資料檢索，參數放在URL有利於分享和快取。
- POST用於發送可能改變伺服器狀態的資料，將參數放在Body中可以傳輸更多資料，且不會暴露在URL中，相對更隱私。
- URL長度有限制，RequestBody沒有明顯限制。
- 🗣️口語化回答：GET參數放URL方便快取和分享，但有長度限制也不適合放敏感資料；POST參數放請求體則沒長度限制，也比較安全，適合送表單或大量資料。

---

# 四、Request / Response 結構與用途

## 重點摘要
HTTP通訊的基礎是請求(Request)和響應(Response)。客戶端發送請求，伺服器處理後回傳響應。這兩者都包含起始行、Header區塊和Body區塊。理解這些結構能幫助開發者知道如何在請求中攜帶參數、認證資訊，以及如何從響應中取得資料、處理狀態。這是所有Web服務互動的關鍵。

## 定義
- HTTP Request：由客戶端發送給伺服器，包含請求方法、URI、協定版本、Header、Body。
- HTTP Response：由伺服器回傳給客戶端，包含協定版本、狀態碼、狀態訊息、Header、Body。
- Start Line (起始行)：Request的第一行(方法 URI 版本)，Response的第一行(版本 狀態碼 狀態訊息)。
- Header 區塊：多個Header字段組成，每個字段包含名稱和值，提供元資訊。
- Body 區塊：包含實際傳輸的資料，可為空。
- 用途：Request用於告訴伺服器「想做什麼」，Response用於告訴客戶端「處理結果和資料」。

## 常考觀念 Q&A

### Q1：Request Header和Request Body分別用於傳遞什麼資訊？
- Request Header：用於傳遞關於請求本身的元資訊，如客戶端類型(User-Agent)、可接受的內容類型(Accept)、授權憑證(Authorization)、Cookie、內容長度(Content-Length)等。
- Request Body：用於傳遞請求的實際資料，通常用於POST、PUT、PATCH等方法，例如提交的表單資料、JSON格式的資料等。
- 🗣️口語化回答：Header放的是「關於」這個請求的資訊，像是誰發的、要什麼格式；Body放的是「這個請求實際要給伺服器」的資料，像你填的表單內容。

### Q2：Response Header和Response Body分別用於傳遞什麼資訊？
- Response Header：用於傳遞關於響應本身的元資訊，如內容類型(Content-Type)、緩存控制(Cache-Control)、伺服器資訊、Set-Cookie（設置客戶端Cookie）等。
- Response Body：用於傳遞伺服器回傳的實際資料，例如網頁的HTML內容、API回傳的JSON資料、圖片等。
- 🗣️口語化回答：Response Header告訴瀏覽器或客戶端這個回覆的一些細節，像是回來的資料是什麼格式、能不能快取；Response Body就是伺服器真正要給你的東西，像是網頁內容或API的資料。

### Q3：在什麼情況下Request或Response可以沒有Body？
- Request沒有Body：GET, HEAD, DELETE等方法通常沒有Request Body，參數放在URL或Header中。
- Response沒有Body：HEAD方法的回應、某些只回傳狀態的響應（如204 No Content），或是重定向(3xx)的響應也可能沒有Body。
- 🗣️口語化回答：如果是GET這種只是「拿」資料的請求，或伺服器只是回覆「成功」或「找不到」而沒有要給你實際內容時，就可能沒有Body。

## 重要語法或術語
- HTTP Request
- HTTP Response
- Start Line
- Header
- Body
- Content-Type
- Authorization
- User-Agent
- Status Code

## 面試常見問法與回答

### Q1：你在實務上如何使用Request/Response Header來處理使用者認證？
- 客戶端登入成功後，伺服器發送一個Token（如JWT），放在Response Header或Body回傳給客戶端。
- 客戶端儲存Token，並在後續需要認證的Request中，將Token放在Authorization Header（如 `Authorization: Bearer <token>`）發送給伺服器。
- 伺服器接收到Request後，檢查Authorization Header中的Token是否有效。
- 🗣️口語化回答：我會在登入成功後給使用者一個憑證(Token)，之後他每次發送請求時都把這個Token放在請求的Header裡帶過來，伺服器看到這個Token就知道是誰、有沒有權限。

### Q2：如何透過Request/Response結構處理檔案上傳？
- 客戶端使用POST方法，並設定Request Header的 `Content-Type` 為 `multipart/form-data`。
- Request Body會包含分隔符，將檔案資料和可能的其他表單欄位分開傳輸。
- 伺服器端解析 `multipart/form-data` 格式的Request Body，讀取檔案內容並儲存。
- 伺服器回傳包含處理結果的Response，Body可能包含上傳成功訊息或檔案資訊。
- 🗣️口語化回答：上傳檔案時，Request的Content-Type會設定成 `multipart/form-data`，然後檔案和其他資料都會放在請求的Body裡用特殊格式傳送，後端再照這個格式解析出檔案。

---

# 五、資料庫設計與正規化

## 正規化說明（1NF～3NF）

### 📌 1NF (第一正規化)
- **說明:** 表格的每個欄位都是原子性的，不可再分割，且沒有重複的行。
- **範例前:**
```
訂單表 (Orders)
+---------+-----------+------------+--------------+
| OrderID | OrderDate | Customer   | Products     |
+---------+-----------+------------+--------------+
| 101     | 2023-01-15| John Doe   | ProductA,B   |
| 102     | 2023-01-16| Jane Smith | ProductC     |
+---------+-----------+------------+--------------+
```
- **範例後 (符合 1NF):**
```
訂單表 (Orders)
+---------+-----------+------------+
| OrderID | OrderDate | Customer   |
+---------+-----------+------------+
| 101     | 2023-01-15| John Doe   |
| 102     | 2023-01-16| Jane Smith |
+---------+-----------+------------+

訂單明細表 (OrderItems) - 將 Products 欄位拆分並消除重複行
+---------+-----------+
| OrderID | Product    |
+---------+-----------+
| 101     | ProductA   |
| 101     | ProductB   |
| 102     | ProductC   |
+---------+-----------+
```
- **解說:** 原始訂單表的 `Products` 欄位包含多個值，且行不唯一 (如果考慮訂單+產品的組合)。正規化後，每個欄位都是單值，並將多值欄位拆分到新的訂單明細表，確保每行數據的原子性。

### 📌 2NF (第二正規化)
- **說明:** 滿足 1NF，且所有非主鍵屬性都完全函數依賴於主鍵。如果主鍵是複合主鍵，非主鍵屬性不能只依賴於主鍵的一部分。
- **範例前 (符合 1NF，不符合 2NF):**
```
訂單明細表 (OrderItems) - 複合主鍵: (OrderID, ProductID)
+---------+-----------+-------------+------------+
| OrderID | ProductID | ProductName | OrderDate  |
+---------+-----------+-------------+------------+
| 101     | P1        | ProductA    | 2023-01-15 |
| 101     | P2        | ProductB    | 2023-01-15 |
| 102     | P3        | ProductC    | 2023-01-16 |
+---------+-----------+-------------+------------+
```
- **範例後 (符合 2NF):**
```
訂單明細表 (OrderItems) - 複合主鍵: (OrderID, ProductID)
+---------+-----------+
| OrderID | ProductID |
+---------+-----------+
| 101     | P1        |
| 101     | P2        |
| 102     | P3        |
+---------+-----------+

訂單表 (Orders) - 主鍵: OrderID
+---------+------------+
| OrderID | OrderDate  |
+---------+------------+
| 101     | 2023-01-15 |
| 102     | 2023-01-16 |
+---------+------------+

產品表 (Products) - 主鍵: ProductID
+-----------+-------------+
| ProductID | ProductName |
+-----------+-------------+
| P1        | ProductA    |
| P2        | ProductB    |
| P3        | ProductC    |
+-----------+-------------+
```
- **解說:** 原始表格中，`ProductName` 僅依賴於 `ProductID` (主鍵的一部分)，`OrderDate` 僅依賴於 `OrderID` (主鍵的一部分)。正規化後，將這些部分依賴的欄位拆分到單獨的 `Orders` 和 `Products` 表，`OrderItems` 表只保留與複合主鍵完全相關的欄位。

### 📌 3NF (第三正規化)
- **說明:** 滿足 2NF，且所有非主鍵屬性都不函數依賴於其他非主鍵屬性（消除傳遞依賴）。
- **範例前 (符合 2NF，不符合 3NF):**
```
訂單表 (Orders) - 主鍵: OrderID
+---------+------------+------------+---------------+
| OrderID | OrderDate  | CustomerID | CustomerName  |
+---------+------------+------------+---------------+
| 101     | 2023-01-15 | C1         | John Doe      |
| 102     | 2023-01-16 | C2         | Jane Smith    |
| 103     | 2023-01-17 | C1         | John Doe      |
+---------+------------+------------+---------------+
```
- **範例後 (符合 3NF):**
```
訂單表 (Orders) - 主鍵: OrderID
+---------+------------+------------+
| OrderID | OrderDate  | CustomerID |
+---------+------------+------------+
| 101     | 2023-01-15 | C1         |
| 102     | 2023-01-16 | C2         |
| 103     | 2023-01-17 | C1         |
+---------+------------+------------+

客戶表 (Customers) - 主鍵: CustomerID
+------------+--------------+
| CustomerID | CustomerName |
+------------+--------------+
| C1         | John Doe     |
| C2         | Jane Smith   |
+------------+--------------+
```
- **解說:** 原始表格中，`CustomerName` 依賴於 `CustomerID`，而 `CustomerID` 依賴於主鍵 `OrderID` (通過訂單屬於哪個客戶)。這是一個傳遞依賴 (`OrderID` -> `CustomerID` -> `CustomerName`)。正規化後，將客戶資訊拆分到單獨的 `Customers` 表，消除這種傳遞依賴。

## 關聯設計情境範例

### 題目：設計會員與訂單資料表
應包含：
- users（會員）
- orders（訂單）
- products（商品）
- order_items（訂單明細）

### 建議表格關聯設計：

- **`users` 表:**
    - `user_id` (Primary Key)
    - `name`
    - `email`
    - ...其他會員資訊
- **`products` 表:**
    - `product_id` (Primary Key)
    - `name`
    - `price`
    - `stock`
    - ...其他商品資訊
- **`orders` 表:**
    - `order_id` (Primary Key)
    - `user_id` (Foreign Key reference `users.user_id`)
    - `order_date`
    - `total_amount`
    - `status`
    - ...其他訂單總覽資訊
- **`order_items` 表:**
    - `order_item_id` (Primary Key) 或 複合主鍵 (`order_id`, `product_id`)
    - `order_id` (Foreign Key reference `orders.order_id`)
    - `product_id` (Foreign Key reference `products.product_id`)
    - `quantity`
    - `price_at_purchase` (記錄購買時的價格，避免商品價格變動影響歷史訂單)
    - ...其他訂單明細資訊

### 關聯說明：
- `users` 與 `orders` 是 **1:N (一對多)** 關聯：一個會員可以有多筆訂單，一筆訂單只屬於一個會員。在 `orders` 表中建立 `user_id` 外鍵指向 `users` 表的主鍵 `user_id`。
- `orders` 與 `products` 是 **N:M (多對多)** 關聯：一筆訂單可以包含多個商品，一個商品可以出現在多筆訂單中。這種關係需要通過一個中介表 (`order_items`) 來實現。
- `orders` 與 `order_items` 是 **1:N (一對多)** 關聯：一筆訂單可以有多條訂單明細，一條訂單明細只屬於一筆訂單。在 `order_items` 表中建立 `order_id` 外鍵指向 `orders` 表的主鍵 `order_id`。
- `products` 與 `order_items` 是 **1:N (一對多)** 關聯：一個商品可以出現在多條訂單明細中，一條訂單明細只針對一個商品。在 `order_items` 表中建立 `product_id` 外鍵指向 `products` 表的主鍵 `product_id`。

---

# 六、SQL 語法重點整理

## 常用語法與說明

### 📌 SELECT + WHERE + ORDER BY
- 用於查詢資料、條件過濾、排序結果

#### 範例：
```sql
SELECT name, age FROM users WHERE age > 30 ORDER BY age DESC;
```

#### 解說：
- 查詢 `users` 表中，年齡 (`age`) 大於 30 的記錄。
- 選取 `name` 和 `age` 欄位。
- 依年齡 (`age`) 遞減 (`DESC`) 排序結果。
- `SELECT` 指定要查詢的欄位，`FROM` 指定要查詢的表格，`WHERE` 篩選符合條件的行，`ORDER BY` 指定排序的欄位和順序 (ASC 遞增, DESC 遞減)。

---

### 📌 JOIN（INNER / LEFT / RIGHT）
- 用於根據相關欄位將兩個或多個表格的行組合在一起。

#### 範例（INNER JOIN）：
```sql
SELECT users.name, orders.id
FROM users
INNER JOIN orders ON users.id = orders.user_id;
```

#### 解說：
- 將 `users` 表和 `orders` 表根據 `users.id` 等於 `orders.user_id` 的條件連接。
- `INNER JOIN` (內連接) 只保留兩個表格中 `ON` 條件匹配的行。結果是只有下過訂單 (`orders` 表中有對應 `user_id`) 的使用者會被選出。

#### 範例（LEFT JOIN）：
```sql
SELECT users.name, orders.id
FROM users
LEFT JOIN orders ON users.id = orders.user_id;
```

#### 解說：
- 將 `users` 表和 `orders` 表根據 `users.id` 等於 `orders.user_id` 的條件連接。
- `LEFT JOIN` (左連接) 回傳左表 (這裡指 `users` 表) 的所有行，即使在右表 (`orders` 表) 中沒有匹配的行。如果右表沒有匹配，則右表的欄位 (這裡指 `orders.id`) 顯示為 NULL。結果是所有使用者都會被選出，包含沒有下過訂單的使用者（其 `orders.id` 為 NULL）。

#### 範例（RIGHT JOIN）：
```sql
SELECT users.name, orders.id
FROM users
RIGHT JOIN orders ON users.id = orders.user_id;
```

#### 解說：
- 將 `users` 表和 `orders` 表根據 `users.id` 等於 `orders.user_id` 的條件連接。
- `RIGHT JOIN` (右連接) 回傳右表 (這裡指 `orders` 表) 的所有行，即使在左表 (`users` 表) 中沒有匹配的行。如果左表沒有匹配，則左表的欄位 (這裡指 `users.name`) 顯示為 NULL。結果是所有訂單都會被選出，包含可能沒有對應使用者的訂單（這在實際資料庫設計中通常不會發生，因為 `user_id` 通常是外鍵且非空）。

---

### 📌 GROUP BY + HAVING
- `GROUP BY` 用於根據一個或多個欄位對結果集進行分組。
- `HAVING` 用於在分組後對分組進行篩選（類似 `WHERE` 對單行進行篩選）。

#### 範例：
```sql
SELECT user_id, COUNT(id) AS total_orders
FROM orders
GROUP BY user_id
HAVING COUNT(id) > 5;
```

#### 解說：
- 將 `orders` 表的記錄按 `user_id` 進行分組。
- 計算每個分組 (`user_id`) 中的訂單數量 (`COUNT(id)`)，並將結果命名為 `total_orders`。
- `HAVING COUNT(id) > 5` 篩選出那些訂單總數 (`total_orders`) 大於 5 的分組。
- `WHERE` 用於篩選**行**，在 `GROUP BY` 前執行；`HAVING` 用於篩選**分組**，在 `GROUP BY` 後執行，且可以使用聚合函數。

---

### 📌 LIMIT
- 用於限制查詢結果集的行數。在不同的資料庫系統中可能語法不同（如 MySQL/PostgreSQL 用 `LIMIT`，SQL Server 用 `TOP`）。

#### 範例（MySQL/PostgreSQL）：
```sql
SELECT name, age FROM users ORDER BY age DESC LIMIT 10;
```

#### 解說：
- 查詢 `users` 表中的使用者，按年齡遞減排序。
- `LIMIT 10` 只回傳前 10 行結果。

#### 範例（SQL Server）：
```sql
SELECT TOP 10 name, age FROM users ORDER BY age DESC;
```

#### 解說：
- 查詢 `users` 表中的使用者，按年齡遞減排序。
- `TOP 10` 只回傳前 10 行結果。

---

### 📌 子查詢（Subquery）
- 嵌套在其他 SQL 語句中的查詢，通常用括號 `()` 包圍。子查詢可以出現在 `WHERE`, `FROM`, `SELECT` 等子句中。

#### 範例（在 WHERE 中）：
```sql
SELECT name, age
FROM users
WHERE age > (SELECT AVG(age) FROM users);
```

#### 解說：
- 內層子查詢 `SELECT AVG(age) FROM users` 計算出所有使用者的平均年齡。
- 外層查詢 `SELECT name, age FROM users WHERE age > ...` 找出年齡大於平均年齡的使用者。

#### 範例（在 FROM 中，作為派生表 Derived Table）：
```sql
SELECT user_id, total_orders
FROM (
    SELECT user_id, COUNT(id) AS total_orders
    FROM orders
    GROUP BY user_id
) AS UserOrderCounts
WHERE total_orders > 5;
```

#### 解說：
- 內層子查詢計算每個使用者的訂單總數，並作為一個臨時表格 `UserOrderCounts`。
- 外層查詢從這個臨時表格中選取 `user_id` 和 `total_orders`，並篩選出訂單總數大於 5 的記錄。
- 注意在 FROM 子句中的子查詢需要指定一個別名 (例如 `AS UserOrderCounts`)。

---

### 📌 COUNT(), AVG(), SUM() 聚合函數
- 對一組值（通常是分組後的）執行計算並回傳單個結果值。

#### 範例（COUNT, AVG, SUM）：
```sql
SELECT
    COUNT(order_id) AS total_orders_count,   -- 計算總訂單數
    AVG(total_amount) AS average_order_amount, -- 計算訂單平均金額
    SUM(total_amount) AS total_sales_amount    -- 計算總銷售金額
FROM orders;
```

#### 解說：
- 這些聚合函數作用於整個結果集（如果沒有 `GROUP BY`）。
- `COUNT(order_id)` 計算 `orders` 表中 `order_id` 的數量（通常非空，即總行數）。
- `AVG(total_amount)` 計算 `orders` 表中 `total_amount` 欄位的平均值。
- `SUM(total_amount)` 計算 `orders` 表中 `total_amount` 欄位的總和。
- 聚合函數通常與 `GROUP BY` 一起使用，對每個分組執行計算。

#### 範例（配合 GROUP BY 和計算差值）：
```sql
SELECT
    product_id,
    MAX(price) AS max_price,
    MIN(price) AS min_price,
    MAX(price) - MIN(price) AS price_range -- 計算最大最小價差
FROM products
GROUP BY product_id;
```

#### 解說：
- 這個例子假設 `products` 表可能有多個價格（例如歷史價格或不同銷售管道的價格），按 `product_id` 分組後，計算每個產品的最高價、最低價以及它們的差值。
- `MAX(price)` 和 `MIN(price)` 在每個 `product_id` 分組內執行。
- `MAX(price) - MIN(price)` 直接對分組內的聚合結果進行算術運算。

---

### 📌 資料更新/刪除語法（UPDATE, DELETE）
- 用於修改或刪除資料庫中的記錄。

#### 範例（UPDATE）：
```sql
UPDATE users
SET email = 'new.email@example.com', age = age + 1
WHERE user_id = 101;
```

#### 解說：
- 更新 `users` 表中 `user_id` 等於 101 的記錄。
- 將該記錄的 `email` 欄位設置為 `'new.email@example.com'`。
- 將該記錄的 `age` 欄位在原來的基礎上加 1。
- `UPDATE` 指定要更新的表格，`SET` 指定要修改的欄位及其新值，`WHERE` 指定要更新哪些行。如果沒有 `WHERE` 子句，將更新表格中所有行的對應欄位。

#### 範例（DELETE）：
```sql
DELETE FROM orders
WHERE status = 'cancelled'
AND order_date < '2023-01-01';
```

#### 解說：
- 刪除 `orders` 表中符合以下兩個條件的記錄：
    - `status` 為 `'cancelled'`。
    - `order_date` 在 '2023-01-01' 之前。
- `DELETE FROM` 指定要刪除記錄的表格，`WHERE` 指定要刪除哪些行。如果沒有 `WHERE` 子句，將刪除表格中所有記錄。

---

# 七、Java 核心觀念速讀（OOP）

## OOP 四大特性簡述

### 📌 封裝（Encapsulation）
- **說明:** 將物件的屬性（資料）和行為（方法）捆綁在一個單元中，並對外部隱藏物件內部的細節，只通過公共介面提供受控的訪問。
- **範例:**
```java
public class Account {
    private double balance; // 私有屬性，外部不能直接訪問

    public Account(double balance) {
        this.balance = balance;
    }

    // 公共方法提供受控的訪問
    public double getBalance() {
        return balance;
    }

    public void deposit(double amount) {
        if (amount > 0) {
            this.balance += amount;
            System.out.println("存款成功。");
        } else {
            System.out.println("存款金額必須大於零。");
        }
    }
    // ... withdraw() 等方法
}
```
- **解說:** `balance` 屬性被聲明為 `private`，外部程式碼無法直接修改。通過 `getBalance()` 和 `deposit()` 等公共方法來存取和修改 `balance`，這樣可以在方法內部控制業務邏輯（例如存款金額必須大於零），保護數據的完整性和安全性。

### 📌 繼承（Inheritance）
- **說明:** 允許一個類別（子類別/派生類別）繼承另一個類別（父類別/基礎類別）的屬性和方法。子類別可以重用父類別的程式碼，並可以添加新的功能或覆寫現有功能。Java 支援單一繼承（一個類別只能直接繼承一個父類別）。
- **範例:**
```java
class Animal { // 父類別
    void eat() {
        System.out.println("動物正在吃東西");
    }
}

class Dog extends Animal { // 子類別繼承 Animal
    void bark() {
        System.out.println("狗狗在叫");
    }
    // 子類別也可以覆寫父類別的方法
    @Override
    void eat() {
        System.out.println("狗狗吃狗糧");
    }
}
```
- **解說:** `Dog` 類別通過 `extends Animal` 繼承了 `Animal` 的 `eat()` 方法。它可以直接使用 `eat()` 方法，也可以添加自己的方法 `bark()`。同時，`Dog` 覆寫了 `eat()` 方法，提供了自己的特定實現。

### 📌 多型（Polymorphism）
- **說明:** 允許以統一的方式處理不同型別的物件。主要體現在：父類別的引用可以指向子類別的物件；同一個方法名稱在不同的類別中有不同的實現（方法覆寫）；或同一個方法名稱在同一個類別中有不同的參數列表（方法重載）。
- **範例:**
```java
class Animal {
    void sound() {
        System.out.println("動物發出聲音");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("貓咪喵喵叫");
    }
}

class Cow extends Animal {
    @Override
    void sound() {
        System.out.println("牛兒哞哞叫");
    }
}

public class Zoo {
    public static void main(String[] args) {
        Animal myAnimal1 = new Cat(); // 父類別引用指向子類別物件
        Animal myAnimal2 = new Cow(); // 父類別引用指向子類別物件

        myAnimal1.sound(); // 實際執行 Cat 的 sound()
        myAnimal2.sound(); // 實際執行 Cow 的 sound()

        // 方法重載範例 (在同一個類別中)
        print(5);
        print("Hello");
    }

    // 方法重載 (print 方法有不同的參數列表)
    public static void print(int num) {
        System.out.println("印出整數: " + num);
    }
    public static void print(String text) {
        System.out.println("印出字串: " + text);
    }
}
```
- **解說:** `myAnimal1` 和 `myAnimal2` 都是 `Animal` 類型的引用，但它們實際指向的是 `Cat` 和 `Cow` 的物件。當呼叫 `sound()` 方法時，會根據實際的物件型別執行對應子類別中覆寫的 `sound()` 方法，這就是執行時多型。`print` 方法名稱相同但參數不同，這是編譯時多型（方法重載）。

### 📌 抽象（Abstraction）
- **說明:** 關注物件的「是什麼」和「能做什麼」，而隱藏其內部的「如何做」的細節。通過抽象類別和介面來實現。它幫助我們建立模型的層次結構，專注於重要的特性和行為。
- **範例:**
```java
// 抽象類別
abstract class Shape {
    // 抽象方法 (沒有實作細節)
    abstract double area();

    // 非抽象方法 (有實作)
    void display() {
        System.out.println("這是一個形狀");
    }
}

// 具體類別繼承抽象類別並實現抽象方法
class Circle extends Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    double area() {
        return Math.PI * radius * radius; // 提供具體的面積計算實作
    }
}
```
- **解說:** `Shape` 類別是抽象的，定義了所有形狀「應該有」的 `area()` 行為，但沒有提供具體實現，因為不同形狀的面積計算方式不同。`Circle` 繼承 `Shape` 並提供了 `area()` 的具體實現。外部使用時，可以通過 `Shape` 引用來處理不同形狀的物件，並呼叫它們的 `area()` 方法，而無需關心具體的形狀類型和面積計算細節。

## 補充觀念

### 📌 static
- **說明:** 靜態成員（屬性或方法）屬於類別本身，而不是屬於類的特定物件。可以使用類別名稱直接訪問，無需創建物件。靜態屬性在所有物件之間共享。
- **範例:**
```java
class Counter {
    static int count = 0; // 靜態屬性，所有 Counter 物件共享

    public Counter() {
        count++; // 每次創建物件，靜態屬性加一
    }

    public static void displayCount() { // 靜態方法
        System.out.println("當前物件數量：" + count);
    }
}

public class StaticDemo {
    public static void main(String[] args) {
        Counter c1 = new Counter();
        Counter c2 = new Counter();
        Counter c3 = new Counter();

        Counter.displayCount(); // 直接使用類別名稱呼叫靜態方法
        System.out.println(Counter.count); // 直接使用類別名稱訪問靜態屬性
    }
}
```
- **解說:** `count` 是所有 `Counter` 物件共享的計數器。`displayCount` 是靜態方法，不需要 `Counter` 物件就可以呼叫。這對於工具方法或只需要一個實例的資源（如 LoggerFactory）很有用。

### 📌 final
- **說明:** `final` 關鍵字用於修飾變數、方法或類別。
    - `final 變數`: 變數一旦初始化後其值就不能改變（對於引用型別，是指引用本身不能改變，而不是引用的物件內容）。
    - `final 方法`: 子類別不能覆寫 (Override) 這個方法。
    - `final 類別`: 不能被其他類別繼承。
- **範例:**
```java
final double PI = 3.14159; // final 變數，一旦賦值後不能修改

class Base {
    final void cannotOverride() { // final 方法，子類別不能覆寫
        System.out.println("這個方法不能被覆寫");
    }
}

// final class MyFinalClass {} // final 類別，不能被繼承
// class MySubClass extends MyFinalClass {} // 編譯錯誤
```
- **解說:** `PI` 是一個常數。`cannotOverride()` 方法在 `Base` 的子類別中不能被重新實現。`final` 類別用於設計那些不希望被擴展的類別，例如 `String` 類別就是 `final` 的。

### 📌 this
- **說明:** 在類別的實例方法或建構子中，`this` 關鍵字指向當前呼叫該方法或正在創建的那個物件實例本身。
    - 用於區分實例屬性和方法參數（當它們同名時）。
    - 用於在建構子中呼叫同一個類別的其他建構子 (`this(...)`)。
    - 用於在方法中呼叫同一個物件的其他方法。
- **範例:**
```java
class Person {
    private String name;

    public Person(String name) {
        this.name = name; // this.name 指向實例屬性 name
    }

    public void introduce() {
        System.out.println("我的名字是 " + this.name); // this.name 也可以省略，但寫上更清晰
    }

    public Person setAge(int age) {
        // 可以用 this 回傳當前物件，實現方法鏈
        return this;
    }

    // 建構子呼叫另一個建構子
    public Person() {
        this("匿名"); // 呼叫上面的建構子
    }
}
```
- **解說:** 在 `Person(String name)` 建構子中，`this.name = name;` 用來將參數 `name` 的值賦給當前物件的實例屬性 `name`。`this("匿名")` 則是在無參建構子中呼叫帶參建構子。

### 📌 super
- **說明:** 在子類別中，`super` 關鍵字用於引用其直接父類別的成員。
    - `super.attribute`: 訪問父類別的屬性（如果子類別有同名屬性）。
    - `super.method()`: 呼叫父類別的方法（如果子類別覆寫了該方法）。
    - `super(...)`: 在子類別的建構子中呼叫父類別的建構子。子類別建構子的第一行通常需要隱式或顯式呼叫父類別的建構子。
- **範例:**
```java
class Animal {
    String species = "未知物種";
    void sound() {
        System.out.println("動物發出聲音");
    }
    Animal(String species) {
        this.species = species;
    }
}

class Dog extends Animal {
    String species = "犬科"; // 子類別有同名屬性
    Dog() {
        super("狗"); // 呼叫父類別的建構子，初始化父類別的 species
        System.out.println("子類別 species: " + this.species); // 訪問子類別屬性
        System.out.println("父類別 species: " + super.species); // 訪問父類別屬性
    }
    @Override
    void sound() {
        super.sound(); // 呼叫父類別的 sound() 方法
        System.out.println("並且狗狗汪汪叫");
    }
}
```
- **解說:** 在 `Dog` 的建構子中，`super("狗")` 呼叫了 `Animal` 類別中帶 String 參數的建構子。`super.species` 用於訪問 `Animal` 類別中的 `species` 屬性，以區分與子類別同名的屬性。在覆寫的 `sound()` 方法中，`super.sound()` 呼叫了 `Animal` 類別中原始的 `sound()` 方法。

### 📌 建構子 overloading
- **說明:** 一個類別可以有多個建構子，它們名稱相同（與類別名一致），但參數列表不同（參數個數、型別或順序不同）。這允許以不同的方式創建物件，提供靈活的初始化選項。
- **範例:**
```java
class Box {
    double width;
    double height;
    double depth;

    // 建構子 1: 無參建構子
    public Box() {
        width = 1;
        height = 1;
        depth = 1;
    }

    // 建構子 2: 帶三個 double 參數
    public Box(double w, double h, double d) {
        width = w;
        height = h;
        depth = d;
    }

    // 建構子 3: 帶一個 double 參數 (正方體)
    public Box(double size) {
        width = height = depth = size;
    }

    // 建構子 4: 複製建構子 (複製另一個 Box 物件)
    public Box(Box otherBox) {
        this.width = otherBox.width;
        this.height = otherBox.height;
        this.depth = otherBox.depth;
    }
}
```
- **解說:** `Box` 類別提供了四種不同的建構子，可以根據不同的需求創建 `Box` 物件：創建預設尺寸的盒子、指定長寬高的盒子、指定單一尺寸的正方體、或複製現有盒子。Java 根據提供的參數自動匹配呼叫對應的建構子。

### 📌 抽象類別 vs 介面
- **說明:** 兩者都用於實現抽象和多型，定義規範供其他類別遵循。但有重要區別。
    - **抽象類別 (Abstract Class)**:
        - 使用 `abstract` 關鍵字聲明。
        - 可以有抽象方法（無方法體）和非抽象方法（有方法體）。
        - 可以有實例變數、靜態變數、常數。
        - 可以有建構子。
        - 不能直接實例化（不能 `new`），只能被繼承。
        - 一個類別只能繼承一個抽象類別（單一繼承）。
        - 適用於表示「is-a」關係，且某些共性可以有默認實現的場景。
    - **介面 (Interface)**:
        - 使用 `interface` 關鍵字聲明。
        - 在 Java 8 之前只能有抽象方法和常數。Java 8 及之後可以有 default 方法和 static 方法。Java 9 後可以有 private 方法。
        - 不能有實例變數，只能有常數（隱式 `public static final`）。
        - 不能有建構子。
        - 不能直接實例化。
        - 一個類別可以實現多個介面（多重繼承行為）。
        - 適用於表示「has-a」能力或「can-do」的行為規範，定義一組公共行為。
- **範例:**
```java
// 抽象類別
abstract class Vehicle { // 定義交通工具的共性
    abstract void start(); // 所有交通工具都有啟動功能，但方式不同
    void stop() { // 大部分交通工具停止方式類似
        System.out.println("交通工具停止");
    }
}

// 介面
interface Flyable { // 定義飛行能力
    void fly(); // 飛行能力的方法
    // default void glide() { ... } // Java 8+ default 方法
}

// 類別繼承抽象類別並實現介面
class Airplane extends Vehicle implements Flyable {
    @Override
    void start() { System.out.println("飛機啟動引擎"); }

    @Override
    void fly() { System.out.println("飛機起飛"); }
}
```
- **解說:** `Vehicle` 是一個抽象類別，定義了交通工具的基本行為，並提供了一個默認的 `stop` 實現。`Flyable` 是一個介面，定義了一個飛行行為的規範。`Airplane` 既是 `Vehicle` 的一種（繼承 `Vehicle`），又具有飛行能力（實現 `Flyable` 介面）。

### 📌 記憶體管理與 Garbage Collection（GC）
- **說明:** Java 使用自動記憶體管理機制。開發者不需要手動分配和釋放物件佔用的記憶體。物件在 Heap 記憶體中創建。當物件不再被任何活動的引用指向時，JVM 的垃圾回收器（GC）會自動識別這些「垃圾」物件，並回收它們佔用的記憶體空間，以便於分配給新的物件。這避免了 C/C++ 中常見的記憶體洩漏和野指標問題。
- **相關章節:** 請參閱「八、Java 垃圾回收（Garbage Collection）機制與優化策略」以獲得更詳細的說明。

---

# 八、Java 垃圾回收（Garbage Collection）機制與優化策略

## 重點摘要
Java擁有一套自動記憶體管理機制——垃圾回收（GC）。JVM會追蹤並回收不再被程式使用的物件佔用的記憶體空間，避免開發者手動管理記憶體的複雜性和潛在錯誤。理解GC的工作原理（分代回收、常見的收集器）有助於分析和解決記憶體洩漏、GC暫停時間過長等效能問題。

## 定義
- 垃圾回收（Garbage Collection, GC）：JVM自動尋找並回收不再被任何引用指向的物件所佔用的記憶體。
- 堆記憶體（Heap Memory）：Java物件儲存的地方，是GC主要工作區域。
- 分代回收（Generational Collection）：GC將Heap分為不同區域（通常是年輕代、老年代），根據物件的生命週期特性採用不同的回收策略。
    - 年輕代（Young Generation）：新創建的物件首先分配在這裡，GC頻繁（Minor GC）。包含Eden區和兩個Survivor區。
    - 老年代（Old Generation/Tenured Generation）：年輕代經過多次Minor GC後仍然存活的物件會被移到這裡，GC較少（Major GC / Full GC）。
- 停止世界（Stop-the-World, STW）：GC執行時，所有應用程式執行緒暫停，直到GC工作完成。STW是影響應用程式回應性的關鍵因素。
- 記憶體洩漏（Memory Leak）：不再被應用程式使用但GC無法回收的物件佔用的記憶體。
- 常見垃圾收集器：Serial, Parallel, CMS (Concurrent Mark Sweep), G1 (Garbage-First), Shenandoah, ZGC。

## 常考觀念 Q&A

### Q1：Java的垃圾回收主要負責什麼？開發者需要關心嗎？
- GC主要負責自動回收那些不再被任何程式碼引用的物件所佔用的記憶體空間。
- 開發者通常不需要手動釋放記憶體，但理解GC是重要的。
- 關心的原因：理解GC能幫助除錯記憶體洩漏、優化應用程式效能（減少GC停頓時間）、配置合適的JVM參數。
- 🗣️口語化回答：GC就像資源回收，自動清掉沒用的物件佔的記憶體。雖然不用手動做，但了解它能幫你找到程式裡的記憶體問題，或調校讓程式跑得更快更順。

### Q2：解釋一下Java的堆記憶體分代（Young Gen/Old Gen）以及分代回收的概念？
- Heap分成年輕代（放新物件）和老年代（放活得比較久的物件）。
- 新物件在年輕代的Eden區創建，Minor GC會清理年輕代，存活的物件會被移到Survivor區，多次GC後仍存活則進入老年代。
- 老年代的物件較少變化，Major GC或Full GC會清理老年代（可能也包括年輕代）。
- 這樣分代的目的是因為大多數物件壽命都很短，頻繁清理年輕代效率更高。
- 🗣️口語化回答：Java把記憶體分成「年輕區」放新物件，「老年代」放老物件。新物件常常很快就沒用了，所以年輕區清得比較勤快；老物件比較穩定，就偶爾清一下，這樣整體效率比較高。

### Q3：什麼是Stop-the-World (STW)？它有什麼影響？
- STW是指GC執行時，為了確保一致性，JVM會暫停所有應用程式的執行緒。
- 這會導致應用程式在GC期間沒有回應，對使用者體驗（尤其是在高併發或互動式應用中）和系統吞吐量產生影響。
- 現代的GC收集器（如CMS, G1, ZGC）都在努力減少或消除STW時間。
- 🗣️口語化回答：STW就是GC在工作時，會暫停你所有程式的執行，這可能會讓你的程式在那幾毫秒或幾秒內沒有回應，影響使用者體驗。

## 重要語法或術語
- Garbage Collection (GC)
- Heap Memory
- Young Generation
- Old Generation (Tenured)
- Minor GC
- Major GC / Full GC
- Stop-the-World (STW)
- Memory Leak
- Generational Collection
- JVM Options (-Xmx, -Xms)
- G1 Collector

## 面試常見問法與回答

### Q1：你在專案中遇過記憶體相關的問題嗎？如何除錯和解決？
- 我曾經遇過應用程式跑一段時間後變慢或崩潰，懷疑是記憶體洩漏。
- 我會使用JVM監控工具，如JVisualVM或JProfiler，觀察Heap的使用情況、GC活動。
- 透過Heap Dump分析，查找哪些物件佔用記憶體最多且不應被保留，定位是哪個部分的程式碼導致了洩漏。
- 解決方法通常是修改程式碼，解除不再需要的物件引用，使其能夠被GC回收。
- 🗣️口語化回答：我碰過程式跑久了記憶體越來越高，懷疑有洩漏。我會用工具看記憶體狀況，並且Dump出來分析是哪些物件沒被釋放，再回去改程式碼，斷開那些不需要的引用。

### Q2：如何優化Java應用程式的GC效能？
- 選擇合適的GC收集器：根據應用程式的特性（吞吐量優先還是低延遲優先）選擇，例如G1收集器是很多現代應用的選擇。
- 調整Heap大小：根據應用程式的記憶體需求設定 `-Xmx` 和 `-Xms` 參數。
- 優化程式碼：減少物件創建，特別是在迴圈中；使用StringBuilder/StringBuffer代替String拼接；及時關閉資源（文件流、資料庫連線）。
- 監控和分析：持續監控GC日誌和效能指標，找出GC瓶頸。
- 🗣️口語化回答：可以換更先進的GC收集器（像G1），調整記憶體大小。更重要的是寫程式時少創建不必要的物件，特別在跑很快的地方，用StringBuilder處理字串拼接。

---

# 九、Java 字串處理及exception處理

## 重點摘要
Java對字串提供了良好的支援，但由於String的不可變性，大量字串操作可能影響效能。`StringBuilder` 和 `StringBuffer` 提供了可變的字串操作方式。例外處理（Exception Handling）是Java健壯性的重要保障，通過 `try-catch-finally` 結構和異常類別體系，可以有效地捕獲和處理執行時錯誤，防止程式崩潰。

## 定義
- 字串處理：Java中處理文字資料的方式。
    - `String`: 不可變（Immutable）的字串類別，每次修改操作（如拼接）都會產生新的String物件。
    - `StringBuilder`: 可變（Mutable）的字串類別，非執行緒安全（Non-thread-safe），效能通常比 `StringBuffer` 高，適合單執行緒環境。
    - `StringBuffer`: 可變（Mutable）的字串類別，執行緒安全（Thread-safe），適合多執行緒環境。
- 異常處理（Exception Handling）：在程式執行過程中捕獲和響應錯誤或異常情況的機制。
    - `Exception`: 表示程式可以恢復的異常情況。
    - `Error`: 表示JVM無法恢復的嚴重問題。
    - 檢查型異常（Checked Exception）：在編譯時強制檢查的異常，需要顯式捕獲或聲明拋出（如 `IOException`）。
    - 非檢查型異常（Unchecked Exception / Runtime Exception）：在執行時才會出現的異常，編譯器不強制要求處理（如 `NullPointerException`, `ArrayIndexOutOfBoundsException`）。
    - `try`: 包含可能拋出異常的程式碼塊。
    - `catch`: 捕獲特定型別的異常並處理。
    - `finally`: 無論是否發生異常，都會執行的程式碼塊（常用於資源釋放）。
    - `throw`: 在程式碼中手動拋出一個異常物件。
    - `throws`: 在方法簽名中聲明該方法可能拋出的異常型別。

## 常考觀念 Q&A

### Q1：Java中String、StringBuilder、StringBuffer有什麼區別？什麼時候用哪個？
- `String` 是不可變的，每次修改都創建新物件，適合字串內容不常變動或用於常數。
- `StringBuilder` 和 `StringBuffer` 是可變的，直接在原物件上修改，效率高。
- `StringBuilder` 非執行緒安全，適用於單執行緒環境，效能最好。
- `StringBuffer` 執行緒安全，適用於多執行緒環境，效能略低於 `StringBuilder`。
- 🗣️口語化回答：String一旦建立就不能改，每次修改都是新的。StringBuilder和StringBuffer是可以改的，修改比較快。如果程式是單線程，用StringBuilder最快；多線程就用StringBuffer確保安全。

### Q2：Java的異常處理機制是什麼？解釋try-catch-finally的用途。
- Java的異常處理允許程式在發生錯誤時，不是直接崩潰，而是轉到特定的程式碼塊（catch）來處理這個錯誤。
- `try` 塊：放可能會出錯的程式碼。
- `catch` 塊：緊跟在try後面，指定要捕獲的異常型別，並提供異常發生時的處理邏輯。
- `finally` 塊：無論try塊中的程式碼是否發生異常、是否被捕獲，finally塊中的程式碼都會執行，常用於關閉資源（如文件流、資料庫連線）。
- 🗣️口語化回答：try-catch-finally就是「試著做一件事(try)，如果出錯了就這樣處理(catch)，最後不管怎樣都要做這件事(finally)」。這樣程式就不會因為小錯誤就整個停掉。

### Q3：檢查型異常（Checked Exception）和非檢查型異常（Unchecked Exception）有什麼區別？
- 檢查型異常是編譯器會強制檢查的，如果你的方法可能拋出它，你必須使用 `try-catch` 處理或在方法簽名中使用 `throws` 聲明。通常表示外部因素導致的問題（如找不到文件 `FileNotFoundException`）。
- 非檢查型異常（Runtime Exception）編譯器不強制處理，通常表示程式設計上的錯誤（如 `NullPointerException`, `ArrayIndexOutOfBoundsException`）。處理它們是可選的，通常由JVM自動拋出。
- 🗣️口語化回答：檢查型異常是寫程式時，編譯器就會提醒你要處理的，通常是因為外部環境問題；非檢查型異常是程式寫錯了才會發生，編譯器不會提醒，執行時才會出現。

## 重要語法或術語
- String
- StringBuilder
- StringBuffer
- Immutability
- Mutable
- Exception
- Error
- Checked Exception
- Unchecked Exception (RuntimeException)
- try
- catch
- finally
- throw
- throws

## 面試常見問法與回答

### Q1：在專案中，你們是如何處理異常的？有哪些最佳實踐？
- 我們會根據異常型別進行區分處理：對於可恢復的檢查型異常，我們會適當捕獲並給予使用者友善的提示或進行重試；對於非檢查型異常，通常會讓它向上層拋出，並在框架層統一記錄日誌，然後給前端回傳統一的錯誤格式。
- 使用統一的異常處理框架或機制（如Spring的 `@ControllerAdvice`）。
- 避免捕獲所有異常（`catch (Exception e)`）並吞掉（不處理或不記錄），至少要記錄日誌。
- 釋放資源時使用finally塊或try-with-resources語句。
- 🗣️口語化回答：我們會根據不同的錯誤類型決定怎麼處理，像是文件找不到這種可能會發生的，會捕獲後告訴使用者；如果是程式寫錯導致的空指針，就讓它拋出來，在框架層統一記錄錯誤日誌，並給前端統一的錯誤回覆。重點是不要默默吃掉錯誤，至少要記下來。

### Q2：你在什麼情況下會選擇使用StringBuilder而不是String進行字串拼接？
- 在迴圈中進行多次字串拼接時，我會優先使用StringBuilder。
- 例如，構建一個大的SQL語句、生成一個CSV文件內容、或者在迴圈中組裝日誌訊息時。
- 因為String的不可變性會導致每次拼接都創建一個新物件，在迴圈中會產生大量中間物件，消耗記憶體並影響效能；StringBuilder在內部緩衝區操作，效率更高。
- 🗣️口語化回答：當我要在迴圈裡把很多小字串拼成一個大字串時，我一定會用StringBuilder。因為String每次拼接都會浪費資源建一個新物件，在迴圈裡效率會非常差，StringBuilder直接在原來的基礎上改，快很多。

---

# 十、Java有幾種String及差別

## 重點摘要
這個主題是上一題「字串處理」中關於String、StringBuilder、StringBuffer的細化和重點強調。Java中處理字串主要有這三種類別，它們的核心差別在於「可變性」和「執行緒安全性」。這是非常基礎但也常考的觀念，用於評估開發者對Java基礎和多執行緒的理解。

## 定義
- `java.lang.String`: 代表不可變的字元序列。一旦創建，其內容就不能改變。每次修改操作（如 `concat`, `substring` 等）都會回傳一個新的 `String` 物件。字串常數會被儲存在字串池(String Pool)中。
- `java.lang.StringBuilder`: 代表可變的字元序列。提供修改字串內容的方法（如 `append`, `insert`, `delete` 等），操作效率高，特別適合頻繁修改字串的場景。非執行緒安全。
- `java.lang.StringBuffer`: 代表可變的字元序列。功能與 `StringBuilder` 類似，但所有修改方法都使用 `synchronized` 關鍵字修飾，保證執行緒安全。因此在單執行緒環境下效能通常低於 `StringBuilder`。

## 常考觀念 Q&A

### Q1：請列出Java中主要的幾種String類別，並說明它們的核心差別？
- 主要有 `String`, `StringBuilder`, `StringBuffer` 三種。
- 核心差別：
    - 可變性：`String` 是不可變的，`StringBuilder` 和 `StringBuffer` 是可變的。
    - 執行緒安全：`String` 是執行緒安全的（因為不可變），`StringBuilder` 非執行緒安全，`StringBuffer` 執行緒安全。
- 🗣️口語化回答：Java主要有String、StringBuilder、StringBuffer三種。String是不能改的，StringBuilder和StringBuffer是可以改的。StringBuilder比較快但多線程下不安全，StringBuffer比較慢但多線程下安全。

### Q2：為什麼說String是不可變的(Immutable)？這有什麼優缺點？
- String物件一旦被創建，其內部儲存字元的字元陣列就不能被修改。任何看起來修改String的操作實際上都是創建並回傳一個新的String物件。
- 優點：
    - 執行緒安全：多個執行緒可以安全地共享同一個String物件。
    - 字串池：可以實現字串池，節省記憶體，提高效能（共享相同的字串常數）。
    - 用作Key：適合用作HashMap的Key，因為Hash Code計算後不會改變。
    - 安全性：用於網路傳輸、資料庫連線字串等場景時比較安全。
- 缺點：頻繁修改（如拼接）會產生大量中間物件，影響效能和GC負擔。
- 🗣️口語化回答：String就像一個寫好的合同，簽了就不能改了。好處是多線程用起來很安全，也可以共用；壞處是如果頻繁修改（像是字串拼接），會產生很多中間版本，比較浪費資源。

### Q3：在哪些場景下，你一定會選擇使用StringBuffer而不是StringBuilder或String？
- 在多執行緒環境中，需要對同一個字串物件進行修改操作時。
- 例如，多個執行緒同時向同一個日誌緩衝區追加內容，或者多個執行緒操作同一個共享的可變字串變數時。
- 🗣️口語化回答：只有在「多個執行緒」會同時去「修改」同一個字串物件時，為了保證安全，我才會選擇用StringBuffer。其他單線程或字串不變動的情況，用String或StringBuilder就好。

## 重要語法或術語
- String
- StringBuilder
- StringBuffer
- Immutability
- Mutable
- Thread-Safe
- Non-thread-safe
- String Pool
- Synchronized

## 面試常見問法與回答

### Q1：你在實際開發中有沒有遇到String使用不當導致效能問題的例子？怎麼解決？
- 我曾經在一個處理大量文字資料的批次程式中，使用 `String s = ""; for(...) { s += char; }` 的方式來構建一個大字串。結果發現程式執行速度非常慢且記憶體消耗大。
- 解決方法是將字串拼接部分改為使用 `StringBuilder`：`StringBuilder sb = new StringBuilder(); for(...) { sb.append(char); } String result = sb.toString();`。
- 🗣️口語化回答：有，之前寫批次程式時，在迴圈裡用 `+` 去拼字串，結果效率超差。後來換成了 `StringBuilder` 就解決了，速度快很多，記憶體也省很多。

### Q2：除了拼接，String類別還有哪些常用的方法？
- `length()`：獲取字串長度。
- `equals()`：比較兩個字串內容是否相等（不要用 `==`）。
- `indexOf()`, `lastIndexOf()`：查找子字串的位置。
- `substring()`：截取子字串。
- `replace()`：替換部分字串。
- `contains()`：判斷是否包含子字串。
- `split()`：根據分隔符拆分字串。
- `trim()`：去除首尾空白字元。
- 🗣️口語化回答：String有很多常用的方法，像是取長度、比較內容(用equals)、找字元位置、截取一段字串、替換內容、判斷包不包含等等，這些都蠻常用的。

---

# 十一、Web server如何處理大量request

## 重點摘要
Web伺服器如Tomcat, Jetty或內嵌於Spring Boot的伺服器需要高效地處理來自客戶端的大量併發請求。這通常通過多執行緒模型、I/O多路複用、連線池、快取以及與應用程式框架的協同工作來實現。理解這些機制有助於優化伺服器配置、提升應用程式的併發處理能力和回應速度。

## 定義
- Web Server：接收HTTP請求並回傳HTTP響應的軟體（如Nginx, Apache, Tomcat, Jetty）。
- 併發請求（Concurrent Requests）：在同一時間點或時間段內處理多個來自不同客戶端的請求。
- 多執行緒模型（Multi-threading Model）：伺服器為每個請求或一組請求分配一個執行緒來處理。
- 執行緒池（Thread Pool）：預先創建一組執行緒，用於處理傳入的請求，避免頻繁創建和銷毀執行緒的開銷，並控制併發數量。
- 阻塞I/O（Blocking I/O）：一個執行緒在等待I/O操作（如讀取網路資料或文件）完成時會被阻塞。
- 非阻塞I/O（Non-blocking I/O / NIO）：I/O操作不會阻塞執行緒，可以在等待數據時執行其他任務。
- I/O多路複用（I/O Multiplexing）：一個執行緒監控多個I/O通道，當某個通道準備好數據時通知執行緒進行處理（如Java的NIO中的Selector）。
- 連線池（Connection Pooling）：預先建立並管理一組資料庫或其他後端服務的連線，供應用程式重複使用，減少建立連線的開銷。
- 快取（Caching）：將常用資料儲存在記憶體中，加快存取速度，減少對後端服務的依賴。
- 負載平衡（Load Balancing）：將大量請求分散到多台伺服器處理，提高系統總體處理能力和可用性。

## 常考觀念 Q&A

### Q1：Web伺服器如何通過執行緒池來處理大量併發請求？
- Web伺服器啟動時會創建一個執行緒池，包含固定數量（或可配置範圍）的執行緒。
- 當一個新請求到達時，伺服器從執行緒池中分配一個空閒執行緒來處理這個請求。
- 請求處理完畢後，執行緒不會被銷毀，而是回收到執行緒池中，等待處理下一個請求。
- 這樣避免了為每個請求創建新執行緒的開銷，也限制了同時處理的請求數量，防止資源耗盡。
- 🗣️口語化回答：Web伺服器會先準備一堆「工人」（執行緒），收到請求就叫一個空閒工人去處理。處理完了工人就回去休息，等下一個活，這樣比每次有新請求就請一個新工人來要快得多。

### Q2：阻塞I/O和非阻塞I/O在處理請求時有什麼不同？哪種更有利於處理大量併發？
- 阻塞I/O：當一個請求需要進行I/O操作（讀寫網路、文件等），處理該請求的執行緒會「停在那裡」等待I/O完成，期間無法處理其他請求。處理大量併發需要大量執行緒。
- 非阻塞I/O：當發起I/O操作後，執行緒立即返回，可以去做其他事情。I/O裝置準備好數據或可以寫入時，會通知執行緒。少量執行緒就可以處理大量併發請求（通過I/O多路複用）。
- 非阻塞I/O（NIO）更有利於處理大量長連線或低頻率互動的併發請求，如WebSocket。傳統的Tomcat等Servlet容器多數是基於阻塞I/O的多執行緒模型，但在高併發下消耗執行緒資源較多。現代伺服器或框架逐漸採用NIO或反應式(Reactive)模型。
- 🗣️口語化回答：阻塞I/O就像一個店員一次只能服務一個客人，中間客人去上廁所店員也得等。非阻塞I/O像一個店員可以同時招呼很多客人，誰準備好了就去服務一下，這樣服務大量客人效率更高。

### Q3：除了執行緒模型，Web伺服器還有哪些提高處理能力和穩定性的方法？
- 連線池：特別是資料庫連線池，減少頻繁建立/關閉連線的開銷。
- 快取：將常存取的資料或計算結果暫存記憶體，減少後端處理或資料庫查詢。
- 靜態資源服務：直接由Web伺服器（如Nginx）處理靜態文件，不佔用應用伺服器的資源。
- 負載平衡：將請求分散到多台伺服器，橫向擴展處理能力。
- 非同步處理：將耗時操作轉移到後台執行，不阻塞請求處理執行緒。
- 🗣️口語化回答：他們會用連線池少開關連線，用快取讓常用的資料讀起來更快，靜態檔案交給專門的伺服器處理。還有就是把請求分散到很多台機器上（負載平衡），或把耗時的工作丟到背景非同步做。

## 重要語法或術語
- Web Server
- Thread Pool
- Concurrent Requests
- Blocking I/O
- Non-blocking I/O (NIO)
- I/O Multiplexing
- Connection Pooling
- Caching
- Load Balancing
- Asynchronous Processing
- Tomcat/Jetty

## 面試常見問法與回答

### Q1：你們專案使用的Web伺服器（如內嵌Tomcat）是怎麼配置來應對預期的高流量的？
- 我們會配置伺服器的執行緒池大小，根據預計的併發連接數和單個請求的處理時間來調整最小和最大執行緒數。
- 配置連線超時時間，避免長時間佔用執行緒。
- 確保資料庫連線池配置合理，能支撐併發請求的資料庫訪問需求。
- 如果流量非常大，會在前面加Nginx等作為反向代理和負載均衡器。
- 🗣️口語化回答：我們會調整Web伺服器（像Spring Boot內嵌的Tomcat）的執行緒數量，確保能處理足夠多的併發請求，同時資料庫連線池也配夠。如果流量預期很高，前面還會加上Nginx來做負載均衡。

### Q2：如果你的應用程式出現響應慢的情況，你會從Web伺服器層面去檢查哪些地方？
- 檢查伺服器的執行緒使用情況，看是否有大量執行緒被佔用或等待。
- 檢查請求佇列長度，看是否有大量請求正在排隊等待處理執行緒。
- 查看伺服器的錯誤日誌和訪問日誌，是否有大量錯誤或異常請求。
- 檢查伺服器的連接數，看是否達到上限。
- 監控伺服器的CPU、記憶體使用率。
- 🗣️口語化回答：我會先看伺服器的狀態，像是現在有多少執行緒在跑、有沒有請求在排隊、CPU和記憶體是不是滿了。如果發現執行緒或請求排隊很多，就可能表示後端處理太慢或伺服器配置不夠。

---

# 十二、Spring Boot 架構與註解（Controller、Service、Repository 等）

## 重點摘要
Spring Boot 是 Spring Framework 的一個子專案，用於簡化Spring應用的建立和部署。它通過自動配置和「約定優於配置」的理念，讓開發者可以快速搭建獨立的、生產級別的Spring應用。理解Spring Boot的核心架構（如三層架構）和關鍵註解（@Controller, @Service, @Repository, @Autowired等）是使用Spring Boot開發Web應用和服務的基礎。

## 定義
- Spring Boot：簡化Spring應用開發的框架，提供自動配置、嵌入式伺服器等功能。
- 自動配置（Auto-configuration）：根據專案的依賴自動配置Spring Bean。
- 依賴注入（Dependency Injection, DI）：Spring IoC容器負責物件的創建和依賴關係的管理，通過註解或XML配置注入依賴。
- 控制反轉（Inversion of Control, IoC）：物件的創建和管理不由開發者控制，而是交由容器。
- Spring IoC Container：負責創建和管理Spring Bean的容器。
- 三層架構：常見的應用程式分層模式。
    - Presentation Layer (表示層/Controller)：處理使用者請求和響應，通常使用 `@Controller` 或 `@RestController`。
    - Business Logic Layer (業務邏輯層/Service)：處理核心業務邏輯，通常使用 `@Service`。
    - Data Access Layer (資料存取層/Repository)：負責與資料庫或其他持久化存儲互動，通常使用 `@Repository`。
- 關鍵註解：
    - `@SpringBootApplication`: 標記主應用程式類別，包含 `@Configuration`, `@EnableAutoConfiguration`, `@ComponentScan`。
    - `@Autowired`: 自動注入依賴的Bean。
    - `@Component`: 標記一個通用的Spring管理的元件。
    - `@Service`: 標記業務邏輯層的元件。
    - `@Repository`: 標記資料存取層的元件，支援異常轉譯。
    - `@Controller`: 標記表示層的元件，處理Web請求，通常回傳視圖名稱。
    - `@RestController`: `@Controller` 和 `@ResponseBody` 的組合，用於建立RESTful API，直接回傳資料。
    - `@Configuration`: 標記配置類別。
    - `@Bean`: 在 `@Configuration` 類別中定義一個Bean。

## 常考觀念 Q&A

### Q1：為什麼選擇使用Spring Boot來開發應用程式？
- 快速啟動和開發：提供Starter POMs，簡化依賴管理和配置。
- 自動配置：減少手動配置的工作量。
- 嵌入式伺服器：方便打包成獨立的可執行JAR，無需額外部署到Tomcat等伺服器。
- 生態系統完整：整合了Spring Framework及其各種專案，功能強大。
- 🗣️口語化回答：Spring Boot讓搭建一個Spring應用變得超快，很多設定都自動幫你做好了，可以直接跑起來，不用再裝Tomcat什麼的，很方便。

### Q2：解釋一下Spring的依賴注入(DI)是什麼？@Autowired是怎麼用的？
- DI是一種設計模式，物件之間的依賴關係由外部（Spring容器）管理和注入，而不是物件自己創建或查找依賴。
- `@Autowired` 是Spring提供的一種方式，用於標記需要注入依賴的成員變數、建構子或方法，Spring容器會自動找到匹配的Bean並注入。
- 🗣️口語化回答：DI就是把物件的「零件」交給Spring來組裝，你不用自己New出來。`@Autowired` 就像一個標籤，告訴Spring「這裡需要一個X物件，請幫我放進來」。

### Q3：@Controller和@RestController有什麼區別？
- `@Controller` 通常用於Web應用，其方法通常回傳視圖名稱（View Name），結合視圖解析器渲染頁面。
- `@RestController` 是Spring 4.0引入的，專門用於建立RESTful API。它是 `@Controller` 和 `@ResponseBody` 的組合，其方法直接回傳資料（如JSON, XML），而不是視圖名稱。
- 🗣️口語化回答：簡單說，`@Controller` 是用來處理傳統網頁請求、回傳頁面的；`@RestController` 是專門用來寫API、直接回傳資料給前端的。

## 重要語法或術語
- Spring Boot
- Auto-configuration
- Dependency Injection (DI)
- IoC Container
- @SpringBootApplication
- @Autowired
- @Component
- @Service
- @Repository
- @Controller
- @RestController
- Layered Architecture

## 面試常見問法與回答

### Q1：你在專案中主要負責哪個部分？如何實現特定功能（例如使用者註冊）？
- 我主要負責開發後端的RESTful API，比如使用者模組、訂單模組。
- 實現使用者註冊時，我會：
    - 在Controller層 (@RestController) 接收前端的註冊請求和使用者資料。
    - 將請求轉發給Service層 (@Service)。
    - Service層處理業務邏輯，如驗證資料、密碼加密。
    - 呼叫Repository層 (@Repository) 將使用者資料存入資料庫。
    - Repository層使用Spring Data JPA或JDBC Template與資料庫互動。
    - Service層回傳處理結果給Controller，Controller回傳響應給前端。
- 🗣️口語化回答：我主要寫後端的API，會分成Controller、Service、Repository這幾層。像註冊功能，Controller收請求，Service處理業務邏輯（檢查資料、加密密碼），再透過Repository存到資料庫。

### Q2：解釋一下Spring Data JPA在Spring Boot中的作用和優勢？
- Spring Data JPA是Spring Data系列的一部分，簡化了JPA (Java Persistence API) 的資料存取層開發。
- 在Spring Boot中，通過添加Spring Data JPA Starter依賴並配置資料源，Spring Boot會自動配置JPA。
- 開發者只需定義Repository介面並繼承如 `JpaRepository`，Spring Data JPA會根據介面方法名自動生成SQL查詢。
- 優勢：極大減少了資料存取層的 boilerplate code (樣板程式碼)，提高了開發效率。
- 🗣️口語化回答：Spring Data JPA讓我寫資料庫操作變得超簡單，不用自己寫很多查詢的程式碼，只要定義一個介面，Spring就會自動幫我實現大部分常用的資料庫操作方法。

---

# 十三、Java 筆試程式實作題

---

### 題目：印出靠左下直角三角形

#### 📋 題目說明：
請撰寫一支 Java 程式，根據輸入的行數 N，印出一個由星號(*)組成的靠左下的直角三角形。

#### 📥 範例輸入：
```
請輸入三角形的行數：5
```

#### 📤 預期輸出：
```
*
**
***
****
*****
```

#### ✅ Java 解答：
```java
import java.util.Scanner;

public class LeftBottomTriangle {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("請輸入三角形的行數：");
        int numRows = sc.nextInt();

        if (numRows <= 0) {
            System.out.println("行數必須為正整數！");
        } else {
            for (int i = 1; i <= numRows; i++) { // 控制行
                for (int j = 1; j <= i; j++) { // 控制每行的星號數量
                    System.out.print("*");
                }
                System.out.println(); // 每行結束換行
            }
        }

        sc.close();
    }
}
```

#### 📌 重點解析：
- 使用 `Scanner` 取得輸入。
- 外層 `for` 迴圈控制行數 (1 到 N)。
- 內層 `for` 迴圈控制每行的星號數量，數量等於當前行數 (1 到 i)。
- `System.out.print("*")` 印出星號不換行。
- `System.out.println()` 在每行結束後換行。
- 靠右、等腰等其他三角形是類似的巢狀迴圈變化題型，通常調整內層迴圈印出的內容（空格或星號）以及印出的順序即可。

---

### 題目：印出九九乘法表（格式排版整齊）

#### 📋 題目說明：
請撰寫一支 Java 程式，印出完整的九九乘法表。輸出應排版整齊，例如每一列的數字寬度固定，對齊。

#### 📥 範例輸入：
```
(無輸入)
```

#### 📤 預期輸出：
```
1*1=1   1*2=2   1*3=3   1*4=4   1*5=5   1*6=6   1*7=7   1*8=8   1*9=9   
2*1=2   2*2=4   2*3=6   2*4=8   2*5=10  2*6=12  2*7=14  2*8=16  2*9=18  
...
9*1=9   9*2=18  9*3=27  9*4=36  9*5=45  9*6=54  9*7=63  9*8=72  9*9=81  
```
*(實際輸出會更精確對齊)*

#### ✅ Java 解答：
```java
public class MultiplicationTable {
    public static void main(String[] args) {
        for (int i = 1; i <= 9; i++) { // 外層迴圈控制被乘數
            for (int j = 1; j <= 9; j++) { // 內層迴圈控制乘數
                int result = i * j;
                // 使用 String.format 來控制輸出格式，讓數字對齊
                System.out.printf("%d*%d=%-2d   ", i, j, result);
            }
            System.out.println(); // 每印完一列換行
        }
    }
}
```

#### 📌 重點解析：
- 巢狀 `for` 迴圈遍歷 1 到 9 的所有組合。
- 外層迴圈變數 `i` 作為被乘數。
- 內層迴圈變數 `j` 作為乘數。
- `System.out.printf("%d*%d=%-2d   ", i, j, result)` 是排版關鍵。
    - `%d` 格式化整數。
    - `%-2d` 格式化結果，`-` 表示左對齊，`2` 表示至少佔用 2 個字元寬度，確保對齊。
    - `   ` 提供固定的間隔。

---

### 題目：判斷質數

#### 📋 題目說明：
請寫一個 Java 程式，輸入一個整數，判斷是否為質數（只能被 1 和自己整除的正整數，2 是最小質數）。

#### 📥 範例輸入：
```
輸入：7
```

#### 📤 預期輸出：
```
7 是質數
```

#### ✅ Java 解答：
```java
import java.util.Scanner;

public class PrimeChecker {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("請輸入數字：");
        int num = scanner.nextInt();
        boolean isPrime = true;

        if (num <= 1) {
            isPrime = false;
        } else if (num == 2) {
             isPrime = true;
        } else if (num % 2 == 0) {
             isPrime = false;
        } else {
            // 只檢查從 3 到 Math.sqrt(num) 的奇數
            for (int i = 3; i <= Math.sqrt(num); i += 2) {
                if (num % i == 0) {
                    isPrime = false;
                    break;
                }
            }
        }

        System.out.println(num + (isPrime ? " 是質數" : " 不是質數"));
        scanner.close();
    }
}
```

#### 📌 重點解析：
- 使用 `Scanner` 取得輸入。
- 初始化 `isPrime` 旗標為 `true`。
- 處理邊界情況 `num <= 1` 和特殊情況 `num == 2`。
- 優化：排除大於 2 的偶數。
- 優化：迴圈檢查範圍從 3 開始，步長為 2 (只檢查奇數)，到 `Math.sqrt(num)` 即可。
- `num % i == 0` 判斷是否能整除。
- 找到因數立即 `break` 停止檢查。
- 三元運算符 `(isPrime ? " 是質數" : " 不是質數")` 簡潔輸出結果。

---

### 題目：印出前 N 個質數

#### 📋 題目說明：
請撰寫一支 Java 程式，根據輸入的整數 N，印出前 N 個質數。

#### 📥 範例輸入：
```
請輸入要印出的質數個數：5
```

#### 📤 預期輸出：
```
2 3 5 7 11 
```

#### ✅ Java 解答：
```java
import java.util.Scanner;

public class FirstNPrimes {

    // 方法：判斷一個數字是否為質數 (重用邏輯)
    public static boolean isPrime(int num) {
        if (num <= 1) {
            return false;
        }
        if (num == 2) {
            return true;
        }
        if (num % 2 == 0) {
            return false;
        }
        for (int i = 3; i <= Math.sqrt(num); i += 2) {
            if (num % i == 0) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("請輸入要印出的質數個數：");
        int n = sc.nextInt();

        if (n <= 0) {
            System.out.println("個數必須為正整數！");
        } else {
            int count = 0; // 已找到的質數個數
            int num = 2; // 從第一個可能的質數開始檢查

            System.out.println("前 " + n + " 個質數是：");
            while (count < n) { // 當找到的質數數量不足 N 個時繼續
                if (isPrime(num)) { // 判斷當前數字是否為質數
                    System.out.print(num + " "); // 是質數則印出
                    count++; // 質數個數加一
                }
                num++; // 檢查下一個數字
            }
            System.out.println(); // 換行結束
        }

        sc.close();
    }
}
```

#### 📌 重點解析：
- 將判斷單個數字是否為質數的邏輯封裝到 `isPrime` 方法中，提高程式碼重用性。
- 使用 `while (count < n)` 迴圈，直到找到指定數量的質數為止。
- `count` 變數追蹤已找到的質數數量。
- `num` 變數從 2 開始，每次遞增，檢查是否為質數。
- `System.out.print(num + " ")` 在同一行印出質數並加空格。

---

### 題目：印出前 N 個費式數列

#### 📋 題目說明：
請撰寫一支 Java 程式，印出費式數列的前 N 項。費式數列的規則是：第一項是 0，第二項是 1，之後的每一項都是前兩項之和 (例如：0, 1, 1, 2, 3, 5, 8, ...)。

#### 📥 範例輸入：
```
請輸入要印出的費式數列項數：8
```

#### 📤 預期輸出：
```
費式數列前 8 項：
0 1 1 2 3 5 8 13 
```

#### ✅ Java 解答：
```java
import java.util.Scanner;

public class FibonacciSequence {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("請輸入要印出的費式數列項數：");
        int n = sc.nextInt();

        if (n < 0) {
            System.out.println("項數不能為負數！");
        } else if (n == 0) {
            System.out.println("費式數列前 0 項：");
        } else if (n == 1) {
            System.out.println("費式數列前 1 項：\n0");
        } else {
            System.out.println("費式數列前 " + n + " 項：");
            int term1 = 0; // 第一項
            int term2 = 1; // 第二項

            System.out.print(term1 + (n > 1 ? " " : "")); // 印出第一項，如果 N>1 則加空格
            if (n > 1) {
                 System.out.print(term2 + (n > 2 ? " " : "")); // 印出第二項，如果 N>2 則加空格
            }


            // 從第三項開始計算並印出
            for (int i = 3; i <= n; i++) {
                int nextTerm = term1 + term2; // 下一項是前兩項之和
                System.out.print(nextTerm + (i == n ? "" : " ")); // 印出下一項，最後一個數字後不加空格
                term1 = term2; // 更新 term1 為原來的 term2
                term2 = nextTerm; // 更新 term2 為新計算出的 nextTerm
            }
            System.out.println(); // 迴圈結束後換行
        }

        sc.close();
    }
}
```

#### 📌 重點解析：
- 使用 `Scanner` 取得輸入 N。
- 處理 N=0, N=1, N=2 的邊界情況。
- 使用 `term1` 和 `term2` 變數儲存前兩項的值。
- 迭代計算 `nextTerm = term1 + term2`。
- 關鍵迭代步驟：更新 `term1 = term2;` 和 `term2 = nextTerm;` 以便計算下一項。
- 迴圈從第三項開始 (`i = 3`)，因為前兩項已單獨處理。
- 輸出時控制空格，避免最後一個數字後有多餘空格。
- 此為迭代解法，效率高於遞迴解法。

---

### 題目：回文判斷（isPalindrome）

#### 📋 題目說明：
請撰寫一支 Java 程式，判斷輸入的字串是否為回文。回文是指正著讀和反著讀都一樣的字串，例如 "madam" 或 "level"。忽略大小寫和非字母數字字元。

#### 📥 範例輸入：
```
請輸入字串：A man, a plan, a canal: Panama
```

#### 📤 預期輸出：
```
"A man, a plan, a canal: Panama" 是回文
```

#### ✅ Java 解答：
```java
import java.util.Scanner;

public class PalindromeChecker {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("請輸入字串：");
        String input = sc.nextLine();

        boolean isPalindrome = checkPalindrome(input);

        if (isPalindrome) {
            System.out.println("\"" + input + "\" 是回文");
        } else {
            System.out.println("\"" + input + "\" 不是回文");
        }

        sc.close();
    }

    // 方法：判斷字串是否為回文（忽略大小寫和非字母數字字元）
    public static boolean checkPalindrome(String str) {
        if (str == null) {
            return false;
        }

        // 步驟 1: 過濾非字母數字字元並轉為小寫
        StringBuilder cleanedStrBuilder = new StringBuilder();
        for (char c : str.toCharArray()) {
            if (Character.isLetterOrDigit(c)) {
                cleanedStrBuilder.append(Character.toLowerCase(c));
            }
        }
        String cleanedStr = cleanedStrBuilder.toString();

        // 步驟 2: 使用雙指標法判斷是否為回文
        int left = 0;
        int right = cleanedStr.length() - 1;

        while (left < right) {
            if (cleanedStr.charAt(left) != cleanedStr.charAt(right)) {
                return false; // 左右字元不相等，不是回文
            }
            left++;  // 左指標向右移動
            right--; // 右指標向左移動
        }

        return true; // 所有對應字元都相等，是回文
    }
}
```

#### 📌 重點解析：
- 使用 `Scanner.nextLine()` 讀取包含空格的整行字串。
- `checkPalindrome` 方法實現核心邏輯。
- **預處理**：遍歷原始字串，使用 `Character.isLetterOrDigit` 過濾，`Character.toLowerCase` 轉小寫，`StringBuilder` 高效構建清理後的字串。
- **雙指標法**：`left` 從開頭，`right` 從結尾。
- `while (left < right)` 迴圈進行比較。
- `cleanedStr.charAt(left) != cleanedStr.charAt(right)` 比較對應字元，不等立即返回 `false`。
- `left++`, `right--` 移動指標向中間靠攏。
- 迴圈結束表示是回文，返回 `true`。

---

### 題目：陣列最大值與最小值

#### 📋 題目說明：
請撰寫一支 Java 程式，找出一個整數陣列中的最大值和最小值。

#### 📥 範例輸入：
```java
int[] numbers = {5, 2, 8, 1, 9, 4};
```

#### 📤 預期輸出：
```
陣列中的最大值為：9
陣列中的最小值為：1
```

#### ✅ Java 解答：
```java
public class FindMinMax {
    public static void main(String[] args) {
        int[] numbers = {5, 2, 8, 1, 9, 4, 7, 3, 6}; // 測試陣列

        if (numbers == null || numbers.length == 0) {
            System.out.println("陣列為空，無法找出最大/最小值。");
            return;
        }

        int max = numbers[0]; // 假設第一個元素是最大值
        int min = numbers[0]; // 假設第一個元素是最小值

        // 從第二個元素開始遍歷陣列
        for (int i = 1; i < numbers.length; i++) {
            if (numbers[i] > max) {
                max = numbers[i]; // 如果當前元素比目前的最大值大，更新最大值
            }
            if (numbers[i] < min) {
                min = numbers[i]; // 如果當前元素比目前的最小值小，更新最小值
            }
        }

        System.out.println("陣列中的最大值為：" + max);
        System.out.println("陣列中的最小值為：" + min);
    }
}
```

#### 📌 重點解析：
- 處理空陣列或 `null` 陣列的邊界情況。
- 初始化 `max` 和 `min` 為陣列的第一個元素。
- 使用 `for` 迴圈從陣列第二個元素 (`i=1`) 開始遍歷。
- 在迴圈中，分別比較當前元素與 `max` 和 `min` 的值，並更新它們。
- 只需一次遍歷即可找到最大值和最小值 (時間複雜度 O(n))。

---

### 題目：氣泡排序（Bubble Sort）

#### 📋 題目說明：
請撰寫一支 Java 程式，使用氣泡排序演算法對一個整數陣列進行排序（由小到大）。

#### 📥 範例輸入：
```java
int[] numbers = {64, 34, 25, 12, 22, 11, 90};
```

#### 📤 預期輸出：
```
原始陣列: [64, 34, 25, 12, 22, 11, 90]
排序後的陣列: [11, 12, 22, 25, 34, 64, 90]
```

#### ✅ Java 解答：
```java
import java.util.Arrays;

public class BubbleSort {

    // 方法：實現氣泡排序
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        // 外層迴圈：控制排序的趟數
        for (int i = 0; i < n - 1; i++) {
            // 內層迴圈：進行元素比較和交換，遍歷未排序的部分
            for (int j = 0; j < n - 1 - i; j++) {
                // 如果當前元素比下一個元素大，則交換它們
                if (arr[j] > arr[j + 1]) {
                    // 交換 arr[j] 和 arr[j+1]
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] numbers = {64, 34, 25, 12, 22, 11, 90};

        System.out.println("原始陣列: " + Arrays.toString(numbers));

        bubbleSort(numbers); // 呼叫氣泡排序方法

        System.out.println("排序後的陣列: " + Arrays.toString(numbers));
    }
}
```

#### 📌 重點解析：
- 氣泡排序是簡單的排序演算法，通過重複遍歷列表，比較相鄰元素並交換，直到列表排序完成。
- 使用巢狀 `for` 迴圈。
- 外層迴圈控制需要進行的「趟數」（最多 N-1 趟）。
- 內層迴圈進行相鄰元素的比較和交換。
- 內層迴圈的範圍 `j < n - 1 - i` 逐漸縮小，因為每完成一趟，最大的未排序元素會「冒泡」到陣列末尾的正確位置。
- 使用臨時變數 `temp` 實現元素交換。
- 氣泡排序的時間複雜度為 O(n^2)，效率較低，面試主要考驗對基礎排序演算法的理解。

---

### 題目：不使用第三變數交換兩數

#### 📋 題目說明：
請撰寫一支 Java 程式，在不使用額外第三個變數的情況下，交換兩個整數變數的值。

#### 📥 範例輸入：
```java
int a = 10;
int b = 20;
```

#### 📤 預期輸出：
```
交換前：a = 10, b = 20
交換後：a = 20, b = 10
```

#### ✅ Java 解答：
```java
public class SwapWithoutTemp {
    public static void main(String[] args) {
        int a = 10;
        int b = 20;

        System.out.println("交換前：a = " + a + ", b = " + b);

        // 使用數學運算交換
        a = a + b; // a 現在是兩數之和 (30)
        b = a - b; // b 現在是 (a+b) - b = a (30 - 20 = 10)
        a = a - b; // a 現在是 (a+b) - a = b (30 - 10 = 20)

        System.out.println("交換後：a = " + a + ", b = " + b);

        /*
        // 或者使用位元運算 (XOR) 交換，要求數字不能為 0
        // 如果 a=10 (1010), b=20 (10100)
        a = a ^ b; // a = 10 ^ 20 = 11110 (30)
        b = a ^ b; // b = (a^b) ^ b = a (30 ^ 20 = 1010 = 10)
        a = a ^ b; // a = (a^b) ^ a = b (30 ^ 10 = 10100 = 20)
        */
    }
}
```

#### 📌 重點解析：
- 此題考驗對基本算術或位元邏輯的理解。
- **數學運算法:**
    1.  `a = a + b;`：將 `a` 變成兩數的和。
    2.  `b = a - b;`：利用新的 `a` (和)，減去原來的 `b`，得到原來的 `a`，將其存入 `b`。
    3.  `a = a - b;`：利用新的 `a` (和)，減去已經是原來的 `a` 的 `b`，得到原來的 `b`，將其存入 `a`。
    - **限制:** 這種方法可能導致整數溢位 (Integer Overflow)，如果 `a + b` 超出整數的最大表示範圍。
- **位元運算 (XOR) 法:** 使用異或運算 (`^`) 的特性：`x ^ x = 0`, `x ^ 0 = x`, `x ^ y = y ^ x`, `(x ^ y) ^ z = x ^ (y ^ z)`.
    1.  `a = a ^ b;`
    2.  `b = a ^ b;` (等同於 `b = (原a ^ 原b) ^ 原b = 原a`)
    3.  `a = a ^ b;` (等同於 `a = (原a ^ 原b) ^ 原a = 原b`)
    - **限制:** 不適用於交換相同記憶體位置的變數（即 `a` 和 `b` 引用同一個對象），但對於基本資料型別變數是有效的。

---

# 十四、JavaScript 語法重點

## 常用語法：
- **宣告：var / let / const 差異**
    - `var`: 函數作用域或全域作用域，存在變數提升(hoisting)，可重複宣告和賦值。較不推薦在現代JS中使用。
    - `let`: 塊級作用域，存在變數提升但有暫時死區(Temporal Dead Zone, TDZ)，不可重複宣告，可變值。
    - `const`: 塊級作用域，存在變數提升但有暫時死區(TDZ)，不可重複宣告，宣告時必須賦值，且之後引用不能改變（對於物件或陣列，其內容可變，但變數本身不能指向另一個物件/陣列）。
- **非同步處理：Promise vs async/await**
    - `Promise`: 用於處理非同步操作的結果（成功或失敗）。提供鏈式呼叫 `.then()` 處理成功結果和 `.catch()` 處理失敗。解決了傳統回呼函式巢狀過深（Callback Hell）的問題。
    - `async/await`: 基於 Promise 的語法糖，使非同步程式碼看起來像同步一樣，更易讀易寫。`async` 函數返回一個 Promise，`await` 只能在 `async` 函數中使用，用於等待一個 Promise resolve，然後返回其結果或捕獲其 reject 的錯誤。
- **this 的作用域變化**
    - 在全域環境或普通函數中，`this` 通常指向全域物件 (瀏覽器中是 `window`，Node.js 中是 `global`)。
    - 在物件的方法中，`this` 指向呼叫該方法的物件。
    - 在建構子函數中，`this` 指向新創建的物件實例。
    - 在事件處理器中，`this` 通常指向觸發事件的元素。
    - 使用 `.call()`, `.apply()`, `.bind()` 可以明確綁定 `this` 的值。
    - 箭頭函數 (`=>`) 沒有自己的 `this`，它會捕捉其所在上下文的 `this` 值（詞法作用域的 `this`），使其行為更可預測。
- **型別比較：== vs ===**
    - `==` (等值比較)：只比較值，會進行隱式型別轉換。例如 `1 == '1'` 為 `true`。
    - `===` (等同比較)：既比較值也比較型別，不會進行隱式型別轉換。例如 `1 === '1'` 為 `false`。
    - 推薦始終使用 `===` 和 `!==` 來避免非預期的型別轉換問題。

## 範例：
```js
// 箭頭函數範例
const greet = (name) => `Hello, ${name}`;
console.log(greet('World')); // 輸出: Hello, World

// Promise 和 async/await 範例
function simulateAsyncOperation(delay) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (delay > 1000) {
                reject("太慢了！");
            } else {
                resolve(`延遲 ${delay} 毫秒完成`);
            }
        }, delay);
    });
}

async function runAsyncExample() {
    try {
        console.log("開始非同步操作...");
        const result1 = await simulateAsyncOperation(500); // 等待 Promise resolve
        console.log(result1);

        const result2 = await simulateAsyncOperation(1500); // 等待 Promise reject
        console.log(result2); // 這行不會執行
    } catch (error) {
        console.error("操作失敗:", error); // 捕獲 reject 的錯誤
    }
    console.log("非同步操作結束。");
}

runAsyncExample();

// this 範例
const myObject = {
  name: "物件",
  greet: function() {
    console.log(this.name); // this 指向 myObject
  }
};
myObject.greet(); // 輸出: 物件

const anotherGreet = myObject.greet;
anotherGreet(); // 在瀏覽器中可能輸出 undefined 或拋錯，因為 this 指向全域物件 (或 undefined 在嚴格模式下)

const arrowGreet = () => {
    console.log(this.name); // 箭頭函數中的 this 繼承自其定義的上下文
};
// 如果在全域環境定義，this.name 可能指向 window.name 或 undefined
// 如果在某物件方法內定義，this 指向該物件

// 比較範例
console.log(1 == '1');   // true (隱式轉換)
console.log(1 === '1');  // false (型別不同)
console.log(null == undefined); // true
console.log(null === undefined); // false
```

---