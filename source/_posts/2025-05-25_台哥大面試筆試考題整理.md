---
title: 【Java 全端考前小抄筆記】
date: 2023-10-27T10:30:00.000Z
tags:
- Java
- Spring Boot
- RESTful API
- HTTP
- SQL
- 資料庫
- 資安
- 垃圾回收
- 物件導向
- JavaScript
- 考試
- 筆記
- 全端
categories:
- Java全端
- 後端
- 前端
- 資料庫
- 資安
---

# 【Java 全端考前小抄筆記】

---

# 一、資安（Web Security）

## 重點摘要
Web 資安是保護網站、應用程式和使用者免受網路威脅的核心工作。範圍涵蓋防禦常見的攻擊手法如 SQL Injection、XSS、CSRF 等，並確保資料的機密性、完整性與可用性。對於全端工程師而言，理解常見的資安弱點及其防禦措施至關重要，這不僅是技術能力的要求，也是保障系統與使用者安全的基本責任。

## 定義
- Web 安全性：保護網站和 Web 應用程式及其使用者免受網路攻擊的行為和實踐。
- 常見威脅：SQL Injection (SQL 隱碼攻擊)、Cross-Site Scripting (XSS 跨站腳本攻擊)、Cross-Site Request Forgery (CSRF 跨站請求偽造)、Authentication/Authorization 繞過、Session Hijacking 等。
- 防禦策略：輸入驗證與清理、輸出編碼、使用參數化查詢、實作 CSRF Token、安全的 Session 管理、使用 HTTPS、定期安全掃描與更新函式庫等。
- OWASP Top 10：開放式 Web 應用程式安全專案列出的十大最嚴重 Web 應用程式安全風險清單，是重要的參考指標。

## 常考觀念 Q&A

### Q1：什麼是 Web 安全性？在開發中為何重要？
- 保護網站及應用程式免受惡意攻擊。
- 確保資料的機密性、完整性與可用性。
- 保護使用者隱私及信任。
- 避免潛在的法律風險與名譽損失。
- 🗣️口語化回答：Web 資安就是確保你的網站不會被駭客入侵、資料被偷或破壞，保護使用者很重要的。

### Q2：請說明 SQL Injection（隱碼攻擊）是什麼？如何防範？
- 攻擊者透過在使用者輸入欄位注入惡意的 SQL 語句。
- 利用程式未對使用者輸入進行充分過濾，導致惡意 SQL 語句被資料庫執行。
- 可能導致資料洩漏、竄改甚至刪除。
- 防範方法：使用參數化查詢（Prepared Statements）或ORM 框架、避免使用字串拼接 SQL 語句、對所有使用者輸入進行嚴格的驗證與過濾。
- 🗣️口語化回答：駭客在輸入框偷塞資料庫指令，利用程式漏洞讓資料庫執行。最簡單的防範就是用參數化查詢，不要直接把輸入跟 SQL 連起來。

### Q3：什麼是 XSS（跨站腳本攻擊）？有幾種？如何防範？
- 攻擊者將惡意腳本注入到網頁中，當其他使用者瀏覽該網頁時，惡意腳本就會在他們的瀏覽器上執行。
- 類型：儲存型 XSS（Stored XSS）、反射型 XSS（Reflected XSS）、DOM 型 XSS。
- 可能導致竊取 Cookie、Session、偽造請求等。
- 防範方法：對使用者輸入進行驗證與清理；在輸出到網頁前對所有不可信任的資料進行適當的 HTML 實體編碼（Output Encoding）。
- 🗣️口語化回答：就是駭客把惡意程式碼藏在網頁裡，當你打開網頁時程式碼就在你瀏覽器跑起來了。防範方法是在顯示使用者輸入的內容時，把一些特殊符號轉掉。

### Q4：什麼是 CSRF（跨站請求偽造）？如何防範？
- 攻擊者誘騙使用者點擊連結或圖片，利用使用者已登入的身份，在使用者不知情的情況下發送偽造的請求到目標網站。
- 目標網站會認為這是使用者自己的合法請求並執行。
- 防範方法：使用 CSRF Token（伺服器生成一個隨機 token 放入表單或 header，客戶端提交時帶回驗證）、檢查 Referer Header、使用 SameSite Cookie 屬性。
- 🗣️口語化回答：駭客騙你點一個連結，利用你網站登入中的狀態，去做一些你沒授權的事情。可以用一個只有你知道的特殊驗證碼（CSRF token）來防。

## 重要語法或術語
- SQL Injection
- XSS (Cross-Site Scripting)
- CSRF (Cross-Site Request Forgery)
- HTTPS / SSL/TLS
- OWASP Top 10
- Input Validation
- Output Encoding
- Parameterized Query
- CSRF Token
- Authentication
- Authorization
- Session Management

## 面試常見問法與回答

### Q1：你在過去的專案中，是如何考慮和實作資安的？
- Q：你在過去的專案中，是如何考慮和實作資安的？
- 針對使用者輸入，實作嚴格的驗證與清理，防止常見的注入攻擊。
- 對於資料庫操作，全部使用參數化查詢或 ORM，避免 SQL Injection。
- 開發 RESTful API 時，實作適當的身份驗證（Authentication）和權限控管（Authorization）。
- 在敏感操作上，實作 CSRF 防護（如使用框架提供的 CSRF Token）。
- 網站部署使用 HTTPS，加密傳輸過程。
- 🗣️口語化回答：主要是對所有使用者輸入都檢查和過濾，資料庫操作用安全的寫法。前後端溝通走 HTTPS，敏感操作會加上 CSRF 防護。

### Q2：如果發現專案有資安漏洞，你的處理流程是什麼？
- Q：如果發現專案有資安漏洞，你的處理流程是什麼？
- 確認漏洞的存在與影響範圍，判斷嚴重程度。
- 立刻制定修補方案並盡快實作。
- 修補完成後進行嚴格測試，確保漏洞確實被修補且未引入新的問題。
- 視情況通知相關人員（團隊、主管、使用者）。
- 檢討原因，並將防範措施納入開發流程或code review規範。
- 🗣️口語化回答：先確認漏洞，馬上修好，然後測試確保修好了，最後討論怎麼避免下次再發生。

---

# 二、RESTful API

## 重點摘要
RESTful API 是一種設計 Web 服務介面的架構風格，基於 HTTP 協定，強調以「資源」為中心，並透過標準的 HTTP 方法（GET, POST, PUT, DELETE 等）來操作這些資源。它的主要優點是架構清晰、易於理解和擴展，無狀態性使其 scalable，是目前主流的 API 設計方式，廣泛應用於前後端分離、微服務等場景。

## 定義
- REST：Representational State Transfer 的縮寫，一種用於分散式系統的架構風格。
- RESTful API：遵循 REST 原則設計的 Web API。
- 核心原則：
    - **資源 (Resource)**：網路上的實體，用 URI (Uniform Resource Identifier) 表示，如 `/users`, `/products/123`。
    - **統一介面 (Uniform Interface)**：使用標準的 HTTP 方法操作資源。
    - **無狀態 (Stateless)**：伺服器不保留客戶端狀態，每個請求都包含處理所需的所有資訊。
    - **客戶端-伺服器 (Client-Server)**：關注點分離，客戶端和伺服器獨立發展。
    - **可快取 (Cacheable)**：客戶端可以快取伺服器的響應，提升效能。
    - **分層系統 (Layered System)**：伺服器和客戶端之間的通訊可以經過多個中間層。
    - **按需程式碼 (Code on Demand)**：伺服器可以暫時擴展或自訂客戶端的功能 (可選)。

## 常考觀念 Q&A

### Q1：什麼是 RESTful API？它和 SOAP 有什麼主要區別？
- RESTful API 是一種基於 HTTP 的架構風格，以資源為中心，輕量級且彈性高，常用於 Web 和行動應用。
- SOAP 是基於 XML 的協定，相對重量級，通常使用 WSDL 描述服務，常用於企業級應用或遺留系統。
- RESTful API 更依賴 HTTP 方法，SOAP 則使用 XML 信封。
- RESTful API 無狀態，SOAP 可以是有狀態的。
- 🗣️口語化回答：RESTful 就是一種用 HTTP 方法來操作「資源」的介面設計方式，比較輕巧好用。SOAP 比較老牌、重量級，通常用 XML 來傳資料。

### Q2：GET, POST, PUT, DELETE 這幾個 HTTP 方法在 RESTful API 中通常代表什麼操作？
- GET：用於獲取資源。
- POST：用於建立新的資源。
- PUT：用於完整更新資源。
- DELETE：用於刪除資源。
- 還有 PATCH：用於部分更新資源。
- 🗣️口語化回答：GET 就是查資料，POST 是新增一筆，PUT 是把一整筆資料換新的，DELETE 是刪掉。

### Q3：RESTful API 的「無狀態」是什麼意思？為什麼重要？
- 指伺服器不會在兩次請求之間保留客戶端的任何狀態資訊。每個請求都必須包含處理該請求所需的所有資訊。
- 重要性：提高擴展性（Scaling），伺服器更容易分散到多台機器；提高可靠性，單個伺服器失敗不影響其他請求；簡化伺服器設計。
- 🗣️口語化回答：就是伺服器不會記住你上次做了什麼。每次請求都要告訴伺服器足夠的資訊讓它處理，這樣伺服器比較好擴展。

### Q4：什麼是冪等性 (Idempotence)？哪些 HTTP 方法是冪等的？
- 指對同一 URI 的同一請求執行多次，會產生相同的結果（儘管伺服器狀態可能改變）。
- 冪等方法：GET, PUT, DELETE, HEAD, OPTIONS。
- 非冪等方法：POST (多次 POST 同一數據可能建立多個資源)。PATCH 通常也非冪等，除非特別設計。
- 🗣️口語化回答：冪等就是重複發送同一個請求，產生的結果會是一樣的。像 GET、PUT、DELETE 都是，重複呼叫也不會出問題。

## 重要語法或術語
- REST
- Resource (資源)
- URI (Uniform Resource Identifier)
- Endpoint
- HTTP Methods (GET, POST, PUT, DELETE, PATCH)
- Stateless (無狀態)
- Idempotent (冪等性)
- HATEOAS (Hypermedia as the Engine of Application State) - 進階概念
- JSON / XML (資料格式)

## 面試常見問法與回答

### Q1：你在專案中是怎麼設計 RESTful API 的？請舉例說明一個資源的設計。
- Q：你在專案中是怎麼設計 RESTful API 的？請舉例說明一個資源的設計。
- 識別核心「資源」，通常用名詞表示，且常用複數 (e.g., `/users`, `/orders`)。
- 使用子資源表達關係 (e.g., `/users/{userId}/orders`)。
- 根據操作類型使用正確的 HTTP 方法 (GET 獲取、POST 建立、PUT 完整更新、DELETE 刪除)。
- 使用 HTTP Status Code 表示結果 (200 OK, 201 Created, 400 Bad Request, 404 Not Found, 500 Internal Server Error)。
- 例如：會員資源 (`/users`)。
    - `GET /users`：獲取所有會員列表。
    - `GET /users/{id}`：獲取特定 ID 的會員資料。
    - `POST /users`：新增會員。
    - `PUT /users/{id}`：完整更新特定 ID 會員資料。
    - `DELETE /users/{id}`：刪除特定 ID 會員。
- 🗣️口語化回答：我會先把系統裡的「東西」（資源）找出來，用像 `/users` 這樣名詞當網址。然後根據要做什麼動作，用對 GET/POST/PUT/DELETE 方法。

### Q2：如何在 RESTful API 中處理版本控制？
- Q：如何在 RESTful API 中處理版本控制？
- URL Path Versioning (e.g., `/v1/users`, `/v2/users`)：最直觀但修改 URI 會影響所有客戶端。
- Query Parameter Versioning (e.g., `/users?version=v1`)：對客戶端影響較小，但可能與其他參數混淆。
- Header Versioning (e.g., `Accept: application/vnd.myapp.v1+json`)：符合 REST 原則中透過 Header 進行內容協商，但客戶端實作稍複雜。
- 🗣️口語化回答：有幾種方法，最常見的是在網址裡加版本號，像是 `/v1/users`。或是放在 Header 裡，只是 Header 比較難測。

---

# 三、HTTP 基本結構與方法

## 重點摘要
HTTP (Hypertext Transfer Protocol) 是 Web 資料傳輸的基礎協定。理解 HTTP 的基本結構（請求與回應）以及常用的方法（GET, POST 等）是進行 Web 開發的根本。它定義了客戶端（瀏覽器或其他應用）如何向伺服器發送請求，以及伺服器如何回傳響應，包括狀態碼表示處理結果。

## 定義
- HTTP：超文本傳輸協定，應用層協定，用於在客戶端和伺服器之間傳輸超文本（如 HTML）和其他資源。
- 請求-回應模型：客戶端發送請求給伺服器，伺服器處理後回傳回應。
- HTTP 請求 (Request) 的基本結構：
    - **起始行 (Start Line / Request Line)**：包含請求方法 (Method)、請求 URI 和 HTTP 版本。
    - **請求標頭 (Headers)**：提供關於請求、客戶端或資源的元數據，如 `Content-Type`, `User-Agent`, `Cookie` 等。
    - **請求體 (Body)**：包含請求的實際數據，例如 POST 請求提交的表單數據或 JSON 數據 (GET, HEAD 等請求通常沒有 Body)。
- HTTP 回應 (Response) 的基本結構：
    - **起始行 (Start Line / Status Line)**：包含 HTTP 版本、狀態碼 (Status Code) 和狀態文本 (Reason Phrase)。
    - **回應標頭 (Headers)**：提供關於回應、伺服器或資源的元數據，如 `Content-Type`, `Content-Length`, `Server`, `Set-Cookie`, `Cache-Control` 等。
    - **回應體 (Body)**：包含伺服器回傳的實際數據，例如 HTML 頁面、JSON 資料、圖片等 (HEAD 請求通常沒有 Body)。
- 常見 HTTP 方法：GET, POST, PUT, DELETE, HEAD, OPTIONS, PATCH。
- 常見 HTTP 狀態碼：1xx (資訊)、2xx (成功)、3xx (重定向)、4xx (客戶端錯誤)、5xx (伺服器錯誤)。

## 常考觀念 Q&A

### Q1：請說明 HTTP Request 的三個主要組成部分。
- **起始行 (Start Line)**：包含請求方法 (GET/POST 等)、資源路徑 (URI) 和 HTTP 版本。
- **標頭 (Headers)**：提供額外的資訊，例如客戶端的類型、接受的內容格式、Cookies 等。
- **請求體 (Body)**：包含要發送給伺服器的實際數據，POST 或 PUT 請求通常有 Body。
- 🗣️口語化回答：主要就是最上面一行說明要做什麼（GET/POST）、找哪個網址，再來是一堆 Header 描述細節，最後是可能會有個 Body 放要送的資料。

### Q2：請說明 HTTP Response 的三個主要組成部分。
- **起始行 (Status Line)**：包含 HTTP 版本、一個數字的狀態碼 (Status Code) 和狀態文字說明。
- **標頭 (Headers)**：提供額外的資訊，例如回傳內容的類型、Cookie 設定、快取指示等。
- **回應體 (Body)**：包含伺服器回傳的主要內容，像是網頁內容、圖片或 JSON 資料。
- 🗣️口語化回答：跟 Request 類似，有第一行狀態碼（成功還是失敗），再來是一堆 Header 描述回傳內容，最後是 Body 放實際的網頁或資料。

### Q3：GET 和 POST 方法有什麼主要區別？請從多個角度說明。
- **傳送數據方式**：GET 將數據放在 URI 的 query string 中，POST 將數據放在請求體 (Request Body) 中。
- **安全性 (數據暴露)**：GET 數據顯示在 URL 中，可能被記錄在瀏覽器歷史或伺服器日誌，不適合傳輸敏感資訊；POST 數據在 Body 中，相對較隱私。
- **數據大小限制**：GET 受限於 URL 長度 (因瀏覽器和伺服器而異)，POST 沒有嚴格限制。
- **緩存 (Caching)**：GET 請求可以被瀏覽器緩存，POST 請求通常不會被緩存。
- **冪等性**：GET 是冪等的（重複請求結果一致），POST 不是冪等的。
- **用途**：GET 主要用於獲取數據，POST 主要用於提交數據以建立或修改資源。
- 🗣️口語化回答：GET 的資料顯示在網址上，POST 藏在內容裡。GET 比較適合拿資料，POST 適合送資料去新增或修改。GET 可以被快取和重複呼叫，POST 則通常不行。

### Q4：HTTP 狀態碼 200, 404, 500 各代表什麼意思？請再舉兩個常見的狀態碼並說明。
- **200 OK**：請求成功。
- **404 Not Found**：伺服器找不到請求的資源。
- **500 Internal Server Error**：伺服器在處理請求時發生了內部錯誤。
- **201 Created**：請求成功，並建立了一個新的資源 (常用於 POST 請求)。
- **400 Bad Request**：伺服器無法理解客戶端發送的請求，請求語法錯誤。
- **401 Unauthorized**：請求需要身份驗證，但使用者尚未提供憑證或憑證無效。
- **403 Forbidden**：伺服器理解請求，但拒絕執行（沒有權限）。
- **301 Moved Permanently**：資源被永久移動到新的位置，客戶端應更新其連結。
- 🗣️口語化回答：200 是成功，404 是找不到東西，500 是伺服器自己出錯了。還有 201 是新增成功，400 是你發的請求有問題。

## 重要語法或術語
- HTTP/1.1, HTTP/2
- HTTP Request
- HTTP Response
- HTTP Method (GET, POST, PUT, DELETE, etc.)
- Status Code (狀態碼)
- Headers (標頭)
- Body (內容)
- URI / URL
- Query String
- Idempotence (冪等性)
- Cache (快取)

## 面試常見問法與回答

### Q1：你在開發後端 API 時，如何根據業務邏輯回傳正確的 HTTP Status Code？
- Q：你在開發後端 API 時，如何根據業務邏輯回傳正確的 HTTP Status Code？
- 成功讀取：回傳 200 OK。
- 成功建立資源（如註冊會員）：回傳 201 Created。
- 成功刪除或修改（無內容回傳）：回傳 204 No Content。
- 客戶端請求數據格式錯誤、缺少必要參數等：回傳 400 Bad Request。
- 請求的資源找不到：回傳 404 Not Found。
- 使用者未登入或身份驗證失敗：回傳 401 Unauthorized。
- 使用者已登入但沒有權限執行操作：回傳 403 Forbidden。
- 伺服器內部發生未預期的錯誤：回傳 500 Internal Server Error。
- 🗣️口語化回答：根據處理結果回傳不同的狀態碼，像查到東西就給 200，找不到就 404，新增成功給 201，程式自己錯了就給 500。

### Q2：HTTP 是無狀態的，那 Session 是怎麼實現的？
- Q：HTTP 是無狀態的，那 Session 是怎麼實現的？
- Session 是在伺服器端儲存客戶端狀態的一種方式。
- 為了讓伺服器「識別」是哪個客戶端的請求，通常會在客戶端和伺服器之間交換一個 Session ID。
- 常見做法是伺服器在使用者首次訪問或登入成功後，生成一個唯一的 Session ID，並將其透過 `Set-Cookie` Header 發送給客戶端。
- 客戶端（瀏覽器）收到後會將 Session ID 存儲在 Cookie 中。
- 之後客戶端每次發送請求給同一個網站時，都會自動在 `Cookie` Header 中帶上這個 Session ID。
- 伺服器收到請求後，根據 Cookie 中的 Session ID 找到對應的伺服器端 Session 數據，從而恢復客戶端的狀態。
- 🗣️口語化回答：雖然 HTTP 本身沒記憶，但我們可以用 Cookie 來記住使用者。伺服器給客戶端一個 Session ID 存在 Cookie 裡，之後客戶端每次來都帶著這個 ID，伺服器就知道是誰了。

---

# 四、Request / Response 結構與用途

## 重點摘要
深入了解 HTTP Request 和 Response 的詳細結構，特別是 Header 和 Body 的具體內容及其用途。這對於 API 開發、除錯、了解前後端溝通機制、甚至資安分析都非常關鍵。理解 Request 攜帶了什麼資訊給伺服器，以及 Response 又回傳了哪些資訊給客戶端，是全端工程師的必備知識。

## 定義
- Request 結構：
    - Start Line: Method URL HTTP/Version
    - Headers: 鍵值對，提供請求的元數據，如 `Host`, `User-Agent`, `Accept`, `Content-Type`, `Content-Length`, `Authorization`, `Cookie` 等。
    - Body: 攜帶 POST/PUT 等方法實際要提交的數據。
- Response 結構：
    - Start Line: HTTP/Version Status Code Reason Phrase
    - Headers: 鍵值對，提供回應的元數據，如 `Content-Type`, `Content-Length`, `Server`, `Set-Cookie`, `Cache-Control`, `Location` 等。
    - Body: 攜帶伺服器回傳的實際數據，如 HTML、JSON、圖片等。
- 用途：
    - Request：客戶端告知伺服器要做什麼 (Method)、對哪個資源做 (URI)、傳遞什麼數據 (Body)、以及關於客戶端或請求的其他資訊 (Headers)。
    - Response：伺服器告知客戶端請求處理的結果 (Status Code)、回傳的數據內容 (Body)、以及關於伺服器或回應的其他資訊 (Headers)。

## 常考觀念 Q&A

### Q1：Request Headers 中常見的 `Content-Type` 和 `Accept` 有什麼不同？
- `Content-Type` (在 Request Body 存在時使用)：告知伺服器 **請求體** 中的數據是什麼格式。例如：`application/json`, `application/x-www-form-urlencoded`。
- `Accept`：告知伺服器 **客戶端期望接收** 的回應數據是什麼格式。例如：`application/json`, `text/html`, `image/png`。伺服器會嘗試回傳客戶端可接受的格式。
- 🗣️口語化回答：`Content-Type` 是告訴伺服器「我給你的資料」是什麼格式，`Accept` 是告訴伺服器「我想要你給我的資料」是什麼格式。

### Q2：Response Headers 中 `Set-Cookie` 的用途是什麼？
- `Set-Cookie` 是伺服器在 Response Header 中發送給客戶端的一個指令。
- 用於指示客戶端（通常是瀏覽器）在本地儲存一個 Cookie。
- 儲存後，客戶端在之後發送給同一個網站的 Request 中，會自動在 `Cookie` Header 中帶上這個 Cookie。
- 常見用途是儲存 Session ID、使用者偏好設定等狀態資訊。
- 🗣️口語化回答：這是伺服器告訴你的瀏覽器「請幫我存一個 Cookie 起來」，這樣你下次來的時候瀏覽器就會把這個 Cookie 自動帶給我，我就知道你是誰了。

### Q3：Request Body 主要用於哪些 HTTP 方法？為什麼？
- 主要用於 POST, PUT, PATCH 方法。
- GET 和 HEAD 方法理論上也可以有 Body，但語義上不建議，且多數伺服器會忽略。
- 原因：POST, PUT, PATCH 用於向伺服器提交數據以建立或修改資源，這些數據通常較大或包含敏感資訊，不適合放在 URL 中傳輸，故放在 Body 中。
- 🗣️口語化回答：主要是 POST 和 PUT，因為這些方法是要送比較多或比較私密的資料給伺服器，放在 Body 裡比較適合。

## 重要語法或術語
- Request Header
- Response Header
- Request Body
- Response Body
- Content-Type
- Accept
- Authorization
- Cookie
- Set-Cookie
- User-Agent
- Referer
- Location
- Cache-Control

## 面試常見問法與回答

### Q1：你在開發中，如何從 HTTP Request 中取得前端傳來的 JSON 資料？
- Q：你在開發中，如何從 HTTP Request 中取得前端傳來的 JSON 資料？
- 確保前端在 Request Headers 中設置 `Content-Type: application/json`。
- 在後端程式中，讀取 Request Body 的內容。
- 使用 JSON 解析函式庫（如 Jackson, Gson）或框架提供的機制（如 Spring 的 `@RequestBody` 註解）。
- 將解析後的 JSON 數據映射到後端對應的 Java 物件（POJO）。
- 🗣️口語化回答：我會確保前端送資料時有說這是 JSON，然後在後端讀取它送過來的內容，用程式把 JSON 字串轉成我們可以用的物件。在 Spring Boot 裡用 `@RequestBody` 很方便。

### Q2：你在回傳 HTTP Response 給前端時，通常會設定哪些重要的 Header？
- Q：你在回傳 HTTP Response 給前端時，通常會設定哪些重要的 Header？
- `Content-Type`：指定回傳內容的格式，例如 `application/json` (最常用於 API) 或 `text/html`。
- `Content-Length`：指定回傳 Body 的大小（雖然框架通常會自動設定）。
- `Status Code`：這是 Status Line 的一部分，但非常關鍵，表示請求的處理結果。
- `Set-Cookie`：如果需要讓前端儲存 Cookie (如 Session ID或 Token)。
- `Cache-Control`：控制瀏覽器或代理伺服器如何快取這個回應。
- 🗣️口語化回答：一定會設 `Content-Type` 告訴前端資料是什麼格式，還有狀態碼（200, 404 之類的）。如果需要前端存 Cookie 或處理快取，也會設定相關的 Header。

---

# 五、資料正規化（Database Normalization）

## 重點摘要
資料正規化是關聯式資料庫設計中的一項重要技術，目標是透過分解表格、建立關聯，來減少資料冗餘（重複）、避免資料更新異常，並提升資料的一致性和完整性。理解正規化的概念和不同等級（1NF, 2NF, 3NF 等）有助於設計出結構良好、易於維護的資料庫。

## 定義
- 資料正規化：一個系統化的過程，用於設計關聯式資料庫的結構，以減少資料冗餘和提高資料完整性。
- 目的：
    - 減少資料的重複存儲。
    - 避免更新異常 (Insertion, Update, Deletion Anomaly)。
    - 提高資料的一致性。
    - 使資料庫結構更易於維護和修改。
- 更新異常：
    - 插入異常 (Insertion Anomaly)：無法在不輸入某個相關資訊的情況下插入新資料。
    - 更新異常 (Update Anomaly)：修改一個資料需要在多處進行，否則會導致不一致。
    - 刪除異常 (Deletion Anomaly)：刪除某個資料時，不小心刪除了其他不應被刪除的相關資訊。
- 正規形式 (Normal Forms, NF)：衡量資料庫表格正規化程度的標準，越高階的正規形式要求越嚴格。
    - **1NF (First Normal Form)**：每個表格必須有主鍵，每個欄位的值都必須是原子的（不可再分割）。
    - **2NF (Second Normal Form)**：滿足 1NF，且所有非主鍵欄位都必須完全依賴於主鍵（針對複合主鍵）。
    - **3NF (Third Normal Form)**：滿足 2NF，且所有非主鍵欄位不能透過其他非主鍵欄位來依賴主鍵（消除傳遞依賴）。
    - BCNF (Boyce-Codd Normal Form)：比 3NF 更嚴格的形式，處理主鍵的一部分依賴於其他欄位的情況。

## 常考觀念 Q&A

### Q1：什麼是資料正規化？它的主要目的是什麼？
- 資料正規化是一種設計資料庫表格結構的方法。
- 主要目的是減少資料重複（冗餘）和避免資料更新時發生的異常（插入、修改、刪除異常）。
- 確保資料的一致性和完整性。
- 🗣️口語化回答：就是把資料庫表格整理乾淨，減少重複放一樣的東西，讓資料更一致，修改或刪除時比較不會出錯。

### Q2：請用簡單的話說明 1NF, 2NF, 3NF 各是什麼？
- 1NF：表格裡的每個欄位值都不能再被分割了，而且要有個唯一識別這筆資料的主鍵。
- 2NF：符合 1NF，而且如果你的主鍵是好幾個欄位組成的（複合主鍵），那其他非主鍵的欄位都必須完全依賴這個複合主鍵，不能只依賴其中一部分。
- 3NF：符合 2NF，而且非主鍵欄位不能依賴於其他的非主鍵欄位。
- 🗣️口語化回答：1NF 就是欄位值不可分，要有主鍵；2NF 是非主鍵要完全依賴主鍵（對複合主鍵來說）；3NF 是非主鍵之間不能互相依賴。

### Q3：正規化有哪些優點和缺點？
- 優點：
    - 減少資料冗餘，節省存儲空間。
    - 提高資料一致性，修改資料時只需要改一處。
    - 避免更新異常，資料完整性更好。
    - 結構更清晰，易於維護和擴展。
- 缺點：
    - 查詢時可能需要 JOIN 更多的表格，增加查詢的複雜度和執行時間。
    - 有時為了高度正規化會拆分出很多小表格。
- 🗣️口語化回答：好處是資料比較乾淨、不容易出錯、省空間，也好維護。但缺點是查資料時可能會需要把很多小表格 JOIN 起來，比較慢。

### Q4：什麼是反正規化 (Denormalization)？為什麼會使用它？
- 反正規化是指在已正規化的資料庫中，為了提高讀取效能，有意地引入一些冗餘數據或將表格合併。
- 目的：減少查詢時所需的 JOIN 操作，加速資料檢索。
- 使用時機：當正規化導致的 JOIN 操作成為查詢效能瓶頸，且讀取效能比寫入效能更關鍵時。
- 🗣️口語化回答：反正規化就是犧牲一點正規化原則（比如放一些重複資料），讓表格不要拆那麼散，這樣查詢資料時就不用 JOIN 那麼多表，速度會變快。通常是在發現效能瓶頸時才用。

## 重要語法或術語
- Normalization (正規化)
- Denormalization (反正規化)
- Redundancy (冗餘)
- Data Integrity (資料完整性)
- Insertion Anomaly (插入異常)
- Update Anomaly (更新異常)
- Deletion Anomaly (刪除異常)
- Normal Form (NF)
- 1NF, 2NF, 3NF, BCNF
- Primary Key (主鍵)
- Foreign Key (外部鍵)
- Dependency (依賴)
- JOIN (資料庫操作)

## 面試常見問法與回答

### Q1：你在設計資料庫 Schema 時，通常會正規化到哪個程度？為什麼？
- Q：你在設計資料庫 Schema 時，通常會正規化到哪個程度？為什麼？
- 通常會設計到至少 3NF。
- 原因是 3NF 已經能夠消除大部分常見的更新異常和冗餘，提供一個結構清晰且資料完整性較好的基礎。
- BCNF 雖然更嚴格，但在大多數業務場景下，3NF 已足夠，且過度正規化可能導致 JOIN 過多影響效能。
- 如果後續發現特定查詢存在嚴重效能問題，可能會針對該部分考慮進行反正規化。
- 🗣️口語化回答：我通常會正規化到 3NF。這樣大部分資料重複和更新的問題都能避免了，基礎會比較好。如果真的遇到效能瓶頸，才會考慮為了查詢速度做一些反正規化。

### Q2：請舉例說明一個你需要正規化的場景，以及正規化後的表格結構。
- Q：請舉例說明一個你需要正規化的場景，以及正規化後的表格結構。
- 假設有一個訂單表格 `Orders`，一開始包含了訂單資訊和客戶資訊：`OrderID`, `OrderDate`, `CustomerID`, `CustomerName`, `CustomerAddress`, `ProductName`, `Quantity`, `Price`。
- 這個表格存在冗餘：同一個客戶的姓名和地址會重複出現在每筆訂單中。
- 存在更新異常：如果客戶地址變了，需要更新該客戶的所有訂單記錄；如果刪除一個客戶的所有訂單，客戶資訊也會遺失。
- 正規化：
    - 拆分成 `Customers` 表 (`CustomerID` (PK), `CustomerName`, `CustomerAddress`)。
    - `Orders` 表只保留訂單和商品資訊，並透過外部鍵關聯客戶表 (`OrderID` (PK), `OrderDate`, `CustomerID` (FK), `ProductName`, `Quantity`, `Price`)。
    - 如果多個商品在同一訂單，商品資訊可能仍冗餘，可以進一步拆分出 `OrderItems` 表和 `Products` 表來達到更高的正規化。
- 🗣️口語化回答：像訂單表，如果客戶資料跟訂單放一起，同個客戶買很多次，他的名字地址就重複很多遍。我會把它拆成「客戶表」和「訂單表」，訂單表只記錄是哪個客戶下的單，這樣客戶資料就只存一次。

---

# 六、SQL 常見語法與概念（SELECT、JOIN、WHERE、GROUP BY、子查詢等）

## 重點摘要
SQL (Structured Query Language) 是操作關聯式資料庫的標準語言。掌握核心的查詢語法（SELECT, FROM, WHERE, JOIN, GROUP BY, HAVING, ORDER BY）以及子查詢等概念，是進行後端開發不可或缺的能力。面試中常透過撰寫或解釋 SQL 語句來考察對資料庫操作的理解。

## 定義
- SQL：用於管理關聯式資料庫的標準程式語言。
- 常見操作類型：DML (Data Manipulation Language - INSERT, UPDATE, DELETE, SELECT), DDL (Data Definition Language - CREATE, ALTER, DROP), DCL (Data Control Language - GRANT, REVOKE), TCL (Transaction Control Language - COMMIT, ROLLBACK)。
- SELECT：用於從資料庫中檢索數據。
- FROM：指定從哪個表格中檢索數據。
- WHERE：用於篩選符合特定條件的行。
- JOIN：用於將兩個或多個表格基於相關列連接起來，從中查詢數據。
    - INNER JOIN: 返回兩個表中匹配的行。
    - LEFT JOIN (LEFT OUTER JOIN): 返回左表中的所有行，以及右表中匹配的行。
    - RIGHT JOIN (RIGHT OUTER JOIN): 返回右表中的所有行，以及左表中匹配的行。
    - FULL JOIN (FULL OUTER JOIN): 返回當左表或右表中有匹配時的所有行。
- GROUP BY：根據一個或多個列對結果集進行分組，常用於搭配聚合函數 (Aggregate Functions)。
- HAVING：在 GROUP BY 分組後，用於篩選符合特定條件的分組 (類似於 WHERE，但用於分組後的結果)。
- ORDER BY：對結果集進行排序。
- 子查詢 (Subquery / Nested Query)：嵌套在另一個 SQL 語句中的查詢。

## 常考觀念 Q&A

### Q1：請說明 SELECT, FROM, WHERE, ORDER BY 的用途。
- SELECT：選擇你想要顯示哪些欄位。
- FROM：告訴資料庫你要從哪個表格裡面抓資料。
- WHERE：設定條件，只抓符合特定條件的那些資料行。
- ORDER BY：設定資料要按照哪個欄位排序（升冪或降冪）。
- 🗣️口語化回答：SELECT 是選要看哪些欄位，FROM 是選哪個表，WHERE 是篩選資料，ORDER BY 是排序結果。

#### 範例：
sql
SELECT name, age FROM users WHERE age > 30 ORDER BY age DESC;


#### 解說：
- 查詢年齡大於 30 的使用者，並依年齡遞減排序  
- `SELECT` 指定欄位、`WHERE` 過濾條件、`ORDER BY` 排序

### Q2：請說明 INNER JOIN 和 LEFT JOIN 的區別，並舉例。
- INNER JOIN：只返回兩個表格中連接條件匹配的那些行。
- LEFT JOIN：返回左表格中的所有行，即使右表格中沒有匹配的行（右表對應的欄位會顯示 NULL）。
- 例子：`SELECT * FROM Orders LEFT JOIN Customers ON Orders.CustomerID = Customers.CustomerID;` 會列出所有訂單，即使有些訂單找不到對應的客戶；`SELECT * FROM Orders INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;` 只列出有客戶的訂單。
- 🗣️口語化回答：INNER JOIN 只拿兩個表都有匹配到的資料，LEFT JOIN 是左邊那個表的資料全部都要，右邊沒對到的就補 NULL。

#### 範例（INNER JOIN）：
sql
SELECT users.name, orders.id
FROM users
INNER JOIN orders ON users.id = orders.user_id;


#### 解說：
- 查出有訂單的使用者  
- `INNER JOIN` 只保留雙方皆有對應資料的紀錄

#### 範例（LEFT JOIN）：
sql
SELECT c.name, o.order_date
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id;


#### 解說：
- 查出所有客戶及其訂單日期，即使某些客戶沒有訂單也會列出 (訂單日期會是 NULL)。

### Q3：GROUP BY 的用途是什麼？HAVING 和 WHERE 有什麼不同？
- GROUP BY：用於將結果集按照一個或多個欄位的相同值分組，通常用於搭配聚合函數（如 COUNT, SUM, AVG, MAX, MIN）來計算每個組的統計值。
- WHERE：用於在資料從表格中被分組之前篩選「行」。
- HAVING：用於在資料被 GROUP BY 分組之後，篩選符合特定條件的「分組」。
- 🗣️口語化回答：GROUP BY 是把資料分成一組一組的，方便你算每個組的總數或平均。WHERE 是在分組「之前」篩選單筆資料，HAVING 是在分組「之後」篩選分好的那一組組。

#### 範例（GROUP BY + HAVING）：
sql
SELECT department_id, COUNT(*) AS employee_count
FROM employees
GROUP BY department_id
HAVING COUNT(*) > 10;


#### 解說：
- 統計每個部門的員工數量  
- `GROUP BY department_id` 按部門分組  
- `HAVING COUNT(*) > 10` 過濾出員工數量大於 10 的部門分組

### Q4：什麼是子查詢？它的用途是什麼？
- 子查詢：一個 SQL 查詢語句被嵌套在另一個 SQL 語句內部。
- 用途：
    - 作為 WHERE 條件的一部分，用於過濾數據。
    - 作為 FROM 子句的一部分，建立一個臨時的衍生表格。
    - 作為 SELECT 子句的一部分，計算單個值。
- 🗣️口語化回答：就是把一個查詢包在另一個查詢裡面用，可以用來篩選資料，或是做出一個暫時的表格來查。

#### 範例（子查詢作為 WHERE 條件）：
sql
SELECT name, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);


#### 解說：
- 查出薪水高於平均薪水的員工姓名和薪水  
- `(SELECT AVG(salary) FROM employees)` 是一個子查詢，用於計算平均薪水

### 📌 聚合函數（COUNT(), AVG(), SUM(), MAX(), MIN()）
- 用於對一組值執行計算並返回一個單一的值。常與 `GROUP BY` 一起使用。

#### 範例：
sql
SELECT COUNT(id), AVG(price), SUM(quantity)
FROM order_items
WHERE order_id = 123;


#### 解說：
- 計算訂單 ID 為 123 的訂單項總數、平均價格和總數量。
- `COUNT(*)` 或 `COUNT(column)` 計算行數或非 NULL 值數量。
- `AVG(column)` 計算平均值。
- `SUM(column)` 計算總和。
- `MAX(column)` 找出最大值。
- `MIN(column)` 找出最小值。

### 📌 LIMIT / OFFSET
- 用於限制 SELECT 語句返回的行數。常與 `ORDER BY` 一起用於分頁。

#### 範例：
sql
SELECT name, age
FROM users
ORDER BY age ASC
LIMIT 10 OFFSET 20;


#### 解說：
- 查詢依年齡升冪排序的使用者，跳過前 20 筆，只返回接下來的 10 筆記錄。
- `LIMIT count`：返回最多 `count` 行。
- `OFFSET skip_count`：跳過前 `skip_count` 行。

### 📌 資料更新/刪除語法（UPDATE, DELETE）
- `UPDATE` 用於修改表中現有的記錄。
- `DELETE` 用於刪除表中現有的記錄。

#### 範例（UPDATE）：
sql
UPDATE products
SET price = price * 1.10
WHERE category = 'Electronics';


#### 解說：
- 將 'Electronics' 分類下所有產品的價格提高 10%。
- `UPDATE table_name` 指定要更新的表格。
- `SET column1 = value1, ...` 指定要修改的欄位及其新值。
- `WHERE condition` 過濾要更新的記錄（非常重要，避免更新所有記錄）。

#### 範例（DELETE）：
sql
DELETE FROM orders
WHERE order_date < '2023-01-01';


#### 解說：
- 刪除所有訂單日期在 2023 年 1 月 1 日之前的訂單記錄。
- `DELETE FROM table_name` 指定要刪除記錄的表格。
- `WHERE condition` 過濾要刪除的記錄（非常重要，避免刪除所有記錄）。

## 重要語法或術語
- SELECT, FROM, WHERE
- JOIN (INNER, LEFT, RIGHT, FULL)
- GROUP BY, HAVING
- ORDER BY (ASC, DESC)
- LIMIT, OFFSET
- Subquery (子查詢)
- Aggregate Functions (COUNT, SUM, AVG, MAX, MIN)
- Primary Key, Foreign Key
- Index (索引)
- UNION, UNION ALL
- INSERT, UPDATE, DELETE
- CREATE TABLE, ALTER TABLE, DROP TABLE

## 面試常見問法與回答

### Q1：請寫一個 SQL 查詢：從 `employees` 表和 `departments` 表中，找出所有位於 'Sales' 部門的員工姓名和部門名稱。
- Q：請寫一個 SQL 查詢：從 `employees` 表和 `departments` 表中，找出所有位於 'Sales' 部門的員工姓名和部門名稱。（假設 `employees` 表有 `employee_name`, `department_id` 欄位，`departments` 表有 `department_id`, `department_name` 欄位）
- sql
  SELECT
      e.employee_name,
      d.department_name
  FROM
      employees e
  JOIN
      departments d ON e.department_id = d.department_id
  WHERE
      d.department_name = 'Sales';
  
- 說明：使用 JOIN 連接員工表和部門表，連接條件是部門 ID 相同，然後用 WHERE 過濾出部門名稱是 'Sales' 的記錄，最後選取員工姓名和部門名稱。
- 🗣️口語化回答：把員工表跟部門表 JOIN 起來，用部門 ID 連接，然後篩選出部門名稱是 Sales 的員工，取出姓名和部門名。

### Q2：請寫一個 SQL 查詢：找出每個部門的員工數量。
- Q：請寫一個 SQL 查詢：找出每個部門的員工數量。（使用 `employees` 表，假設有 `department_id` 欄位）
- sql
  SELECT
      department_id,
      COUNT(*) AS employee_count
  FROM
      employees
  GROUP BY
      department_id;
  
- 說明：使用 GROUP BY 將員工按照部門 ID 分組，然後使用 COUNT(*) 計算每個組（即每個部門）的員工數量。可以 JOIN `departments` 表來顯示部門名稱而非 ID。
- 🗣️口語化回答：把員工按照部門 ID 分組，然後計算每一組裡面有多少人，就是每個部門的員工數了。

### Q3：在處理大量數據的查詢時，你會考慮哪些 SQL 效能優化？
- Q：在處理大量數據的查詢時，你會考慮哪些 SQL 效能優化？
- **索引 (Indexing)**：檢查 WHERE 和 JOIN 條件中常用的欄位是否有建立索引。
- **查詢計畫分析**：使用資料庫提供的工具（如 MySQL 的 `EXPLAIN`）分析查詢語句的執行計畫，看是否使用了正確的索引、JOIN 順序是否合理。
- **優化 JOIN**：選擇最適合的 JOIN 類型（INNER, LEFT 等），確保 JOIN 條件使用了索引。
- **避免 SELECT ***：只選擇需要的欄位，減少資料傳輸和處理量。
- **合理使用子查詢**：有時子查詢效率不高，可以考慮改寫為 JOIN。
- **反正規化**：對於頻繁讀取且 JOIN 過多的情況，考慮在效能關鍵點引入少量冗餘。
- **資料庫設計**：確保資料庫 schema 本身是合理的正規化或反正規化。
- 🗣️口語化回答：我會先看查詢計畫，檢查有沒有用到索引，通常會對常用來篩選或 JOIN 的欄位加索引。也會盡量避免 `SELECT *`，只抓需要的欄位。

---

# 七、Spring Boot 架構與註解（Controller、Service、Repository 等）

## 重點摘要
Spring Boot 是一個基於 Spring 框架的快速開發工具，它通過「約定大於配置」的方式，極大地簡化了 Spring 應用程式的搭建和開發過程。理解 Spring Boot 的核心概念（IoC、DI）以及常用的註解（Annotation），是掌握現代 Java 後端開發的關鍵。它提供了成熟的 Web、資料庫、安全等解決方案。

## 定義
- Spring Boot：一個開源的 Java 框架，用於快速建立獨立、可生產級別的 Spring 應用程式。
- 特性：
    - **自動配置 (Auto-configuration)**：根據 classpath 中的函式庫自動配置 Spring 應用，減少手動配置。
    - **Starter Dependencies**：提供一組預先配置好的依賴，簡化依賴管理。
    - **嵌入式伺服器 (Embedded Servers)**：預設內嵌 Tomcat, Jetty 或 Undertow，可直接運行 JAR 文件，無需外部伺服器。
    - **無需 XML 配置**：廣泛使用 Java Configuration 和註解。
    - **生產級功能**：如健康檢查、指標收集 (Actuator)。
- 核心概念：
    - **IoC (Inversion of Control)**：控制反轉，Spring Container 負責管理物件的生命週期和依賴關係。
    - **DI (Dependency Injection)**：依賴注入，IoC Container 將物件所需的依賴自動注入給它，而非由物件自行創建或查找。
- 常見註解：
    - `@SpringBootApplication`：標記 Spring Boot 主應用類別，包含 `@Configuration`, `@EnableAutoConfiguration`, `@ComponentScan`。
    - `@Controller`：標記類別為 Spring MVC 控制器，處理 Web 請求。
    - `@RestController`：組合了 `@Controller` 和 `@ResponseBody`，用於建立 RESTful API。
    - `@Service`：標記類別為服務層組件，包含業務邏輯。
    - `@Repository`：標記類別為資料訪問層組件，通常處理資料庫操作，具有異常轉譯功能。
    - `@Component`：通用的 Spring 組件註解，其他如 `@Service`, `@Repository` 都是它的衍生物。
    - `@Autowired`：用於自動注入依賴。
    - `@Configuration`：標記類別為配置類，其中定義 `@Bean`。
    - `@Bean`：標記方法，其回傳值將註冊為 Spring IoC Container 中的一個 Bean。

## 常考觀念 Q&A

### Q1：什麼是 Spring Boot？為什麼在開發中選擇使用它？
- Spring Boot 是一個讓開發 Spring 應用更容易、更快速的框架。
- 它提供了自動配置、Starter 依賴和內嵌伺服器，可以大幅減少配置工作，直接運行 JAR 文件。
- 加速開發效率，易於部署和維護。
- 🗣️口語化回答：Spring Boot 就是讓你可以很快地建一個 Spring 專案，很多配置都幫你做好了，可以直接跑一個 JAR 檔，開發和部署都變簡單很多。

### Q2：請解釋 IoC (控制反轉) 和 DI (依賴注入) 的概念，以及 `@Autowired` 的作用。
- IoC：意思是物件的建立和管理不由程式碼自己控制，而是交給 Spring 容器來處理。
- DI：是實現 IoC 的一種方式，Spring 容器會自動幫你把物件所需要的其他物件（依賴）「注入」進來。
- `@Autowired`：這個註解就是告訴 Spring 容器，這裡需要一個某種類型的物件，請幫我從容器裡找一個合適的並注入進來。
- 🗣️口語化回答：IoC 是控制權交給 Spring，DI 是 Spring 幫你把需要的東西自動送給你。@Autowired 就是跟 Spring 說「這裡我需要那個物件，請給我」。

### Q3：請說明 `@Controller`, `@RestController`, `@Service`, `@Repository` 這幾個註解在分層架構中的作用。
- `@Controller` / `@RestController`：用於 Web 層，處理進來的 HTTP 請求，呼叫 Service 層的方法，並準備回傳 Response。`@RestController` 專門用於 RESTful API，直接回傳數據 (JSON/XML)。
- `@Service`：用於業務邏輯層，包含核心業務處理程式碼，通常會呼叫 Repository 層。
- `@Repository`：用於資料訪問層，負責與資料庫或其他數據源交互，進行 CRUD (Create, Read, Update, Delete) 操作。
- 🗣️口語化回答：Controller 處理前端請求，Service 處理業務邏輯，Repository 處理資料庫存取。他們是把程式碼切成不同部分的標籤，讓程式碼更清楚。

### Q4：什麼是 Spring Boot 的自動配置 (Auto-configuration)？
- 是 Spring Boot 的核心功能之一。
- Spring Boot 會根據你專案中加入的函式庫（dependencies），自動判斷並配置 Spring 應用程式。
- 例如，如果你加了 `spring-boot-starter-web`，它會自動配置 Tomcat 和 Spring MVC；如果你加了 `spring-boot-starter-data-jpa` 和資料庫驅動，它會自動配置 JPA 和數據源。
- 減少了大量的 XML 或 JavaConfig 手動配置工作。
- 🗣️口語化回答：就是 Spring Boot 很聰明，看你專案裡加了哪些東西，就會自動幫你把大部分基本的配置都設好，你就不需要自己寫一堆設定了。

## 重要語法或術語
- Spring IoC Container
- Dependency Injection (DI)
- Auto-configuration (自動配置)
- Starter Dependencies
- Embedded Server (內嵌伺服器)
- `@SpringBootApplication`
- `@Controller`, `@RestController`
- `@Service`
- `@Repository`
- `@Component`
- `@Autowired`
- `@Configuration`, `@Bean`
- Spring MVC
- Spring Data JPA
- Spring Security
- Actuator

## 面試常見問法與回答

### Q1：你在專案中主要是怎麼使用 Spring Boot 的？請描述一個你負責的功能是如何利用 Spring Boot 實現的。
- Q：你在專案中主要是怎麼使用 Spring Boot 的？請描述一個你負責的功能是如何利用 Spring Boot 實現的。
- 主要用於建立後端 RESTful API 服務。
- 以會員註冊功能為例：
    - 建立一個 `@RestController` 處理 `/register` 的 POST 請求。
    - 請求進來後，Controller 將接收到的會員資料 (JSON) 傳給 `@Service` 層的會員服務。
    - Service 層進行業務邏輯檢查（如用戶名是否已存在），然後呼叫 `@Repository` 層的 DAO (Data Access Object)。
    - Repository 層使用 Spring Data JPA 將會員資料存入資料庫。
    - Service 層根據結果回傳成功或失敗訊息給 Controller。
    - Controller 再以 JSON 格式回傳給前端，並設置適當的 HTTP Status Code。
- 🗣️口語化回答：我主要是用它來開發後端 API。比如做會員註冊，我就寫一個 Controller 接收請求，交給 Service 處理業務邏輯，Service 再叫 Repository 存到資料庫，最後把結果回傳給前端。

### Q2：你在使用 Spring Boot 時，覺得最方便或最有挑戰性的是什麼？
- Q：你在使用 Spring Boot 時，覺得最方便或最有挑戰性的是什麼？
- **最方便**：自動配置和 Starter 依賴，可以非常快速地啟動一個功能齊全的專案原型，省去大量配置時間。內嵌伺服器讓部署也很簡單。
- **最有挑戰性**：有時候自動配置會「過度」配置了一些不需要的功能，需要手動排除或調整。理解底層的 Spring 如何運作，以及各種 Starter 依賴之間的關係，在遇到複雜問題時需要花一些時間深入研究。GC 和效能調優在大型應用中也是需要關注的點。
- 🗣️口語化回答：最方便的是它自動幫我把很多東西都設好了，可以很快開始寫程式。比較有挑戰的是，有時候它「太」自動了，出問題時可能需要花點時間去搞清楚它到底怎麼配置的。

---

# 八、Java 垃圾回收（Garbage Collection）機制與優化策略

## 重點摘要
Java 的垃圾回收 (GC) 是一種自動化的記憶體管理機制，負責回收不再使用的物件所佔用的記憶體。理解 GC 的工作原理、不同區域（Young/Old Generation）以及常見的 GC 演算法和類型（Minor/Major/Full GC），對於診斷記憶體問題（如記憶體洩漏）和優化 Java 應用程式的效能至關重要。

## 定義
- 垃圾回收 (Garbage Collection, GC)：JVM (Java Virtual Machine) 提供的一種自動記憶體管理功能，用於自動回收不再被程式引用的物件所佔用的記憶體。
- 目的：減少程式員手動管理記憶體的負擔，避免記憶體洩漏 (Memory Leak) 和釋放後使用 (Use After Free) 等問題。
- 記憶體區域：
    - **Heap (堆)**：Java 物件主要存儲的區域，是 GC 工作的主要區域。 Heap 又分為：
        - **Young Generation (新生代)**：新創建的物件首先分配在這裡。包含 Eden Space 和兩個 Survivor Spaces (S0, S1)。
        - **Old Generation (老年代/舊生代)**：經過多次 Minor GC 仍存活的物件會晉升到這裡。
    - **Stack (棧)**：存儲局部變數和方法呼叫資訊，這部分記憶體由 JVM 自動管理，不是 GC 的重點。
    - **Method Area (方法區) / Metaspace (元空間)**：存儲類別結構資訊、靜態變數、常量等。GC 也可以對此區域進行回收，但在 Java 8 及之後主要管理 Metaspace。
- GC 類型：
    - **Minor GC (新生代 GC)**：只清理 Young Generation，發生頻率高，速度快。
    - **Major GC (老年代 GC)**：只清理 Old Generation，發生頻率低。
    - **Full GC (全 GC)**：清理整個 Heap (Young + Old) 和 Method Area/Metaspace，發生頻率最低，耗時最長，可能導致應用暫停 ("Stop-the-world" pause)。
- 判斷物件是否可回收：通過可達性分析 (Reachability Analysis)，從 GC Roots (如活動線程的局部變數、靜態變數等) 出發，任何不可達的物件都被視為垃圾。
- GC 演算法：Mark-Sweep (標記清除), Copying (複製), Mark-Compact (標記整理), Generational GC (分代 GC), Concurrent GC (並發 GC), Parallel GC (並行 GC)。

## 常考觀念 Q&A

### Q1：什麼是 Java 垃圾回收？它解決了什麼問題？
- Java 垃圾回收是 JVM 自動幫我們管理記憶體的功能。
- 它會自動找到那些程式已經不再使用的物件，並回收它們佔用的記憶體空間。
- 解決了程式員需要手動分配和釋放記憶體的問題，避免了記憶體洩漏或釋放後使用等錯誤。
- 🗣️口語化回答：就是 Java 不用你自己清記憶體，JVM 會自動找到沒用的物件並收走，讓你可以專心寫程式。

### Q2：Java 記憶體區域中，哪些是 GC 的主要工作對象？請說明 Young Gen 和 Old Gen 的區別。
- GC 主要工作對象是 Heap 區域。
- Heap 分為 Young Generation (新生代) 和 Old Generation (老年代)。
- Young Gen 用來存放新創建的物件，通常生命週期較短，GC 頻率高（Minor GC）。
- Old Gen 用來存放那些在 Young Gen 經過多次 GC 後仍然存活的物件，通常生命週期較長。
- 🗣️口語化回答：GC 主要清 Heap 區。Heap 分年輕代和老年代，新物件放年輕代，活比較久的物件會搬到老年代。

### Q3：Minor GC, Major GC, Full GC 有什麼不同？哪個影響效能最大？
- Minor GC：只清理 Young Generation，發生很頻繁，但速度很快，對應用影響小。
- Major GC：只清理 Old Generation，頻率較低，比 Minor GC 慢。
- Full GC：清理整個 Heap (Young + Old) 和 Metaspace，頻率最低，但會導致應用程式完全暫停 ("Stop-the-world")，是影響效能最大的 GC 類型。
- 🗣️口語化回答：Minor GC 是清年輕代，很快。Major GC 清老年代。Full GC 是清整個 Heap，最慢，可能會讓程式卡住一下。

### Q4：如何判斷一個 Java 物件是否「存活」（不會被 GC 回收）？
- Java 使用「可達性分析」來判斷物件是否存活。
- 從一系列稱為 "GC Roots" 的起始點（例如正在執行的線程中的局部變數、靜態變數、Native 方法堆疊的物件等）出發，遍歷所有引用的物件。
- 任何從 GC Roots 不可達的物件，都會被視為垃圾，可以被回收。
- 🗣️口語化回答：JVM 會從一些起點（像是你程式正在跑的地方）去找物件，只要能找到連過去的物件就是活著的，找不到連線的就是沒用的，可以被收走。

## 重要語法或術語
- Garbage Collection (GC)
- JVM (Java Virtual Machine)
- Heap, Stack
- Young Generation, Old Generation
- Eden Space, Survivor Spaces
- Minor GC, Major GC, Full GC
- Stop-the-world
- GC Roots
- Reachability Analysis (可達性分析)
- Memory Leak (記憶體洩漏)
- GC Algorithms (e.g., G1, Parallel, CMS)
- JVisualVM, JProfiler (GC 監控工具)

## 面試常見問法與回答

### Q1：你在開發中，如何避免或減少記憶體洩漏？
- Q：你在開發中，如何避免或減少記憶體洩漏？
- 確保不再使用的物件，其引用能夠被正確釋放或設為 null，使其變得不可達。
- 避免集合類 (Collection) 在不再需要時仍持有大量物件的引用。
- 謹慎使用靜態集合或長生命週期的物件引用。
- 如果使用了資源（如檔案流、網路連線），確保在不再需要時呼叫 close() 方法釋放。
- 使用弱引用 (WeakReference) 或軟引用 (SoftReference) 在特定場景下允許 GC 回收物件。
- 定期使用記憶體分析工具 (如 JVisualVM, Eclipse Memory Analyzer) 檢查 Heap Dump，查找未釋放的物件和引用鏈。
- 🗣️口語化回答：我會注意用完的物件要讓它能被 GC 收到，特別是集合類和長生命週期的物件。也會確保資源（像檔案連線）有確實關掉。必要時會用工具檢查是不是有物件一直佔著記憶體。

### Q2：你遇過 GC 造成的效能問題嗎？是如何診斷和解決的？
- Q：你遇過 GC 造成的效能問題嗎？是如何診斷和解決的？
- 遇過的問題：應用程式突然停頓很長時間（Full GC 停頓），或 CPU 使用率異常高且頻繁 GC。
- 診斷方法：
    - 啟用 GC 日誌，分析 GC 的頻率、類型和每次耗時。
    - 使用 JVisualVM, JProfiler 等工具連接到運行中的應用，監控 Heap 使用率、GC 活動和線程狀態。
    - 導出 Heap Dump，使用分析工具查找是否存在記憶體洩漏或過大的物件，識別是哪些物件佔用了大量記憶體且未被釋放。
- 解決方法：
    - 根據診斷結果，優化程式碼：減少不必要的物件創建，改進資料結構使用，釋放不再使用的引用。
    - 如果是 GC 演算法不適合應用場景，可以嘗試調整 JVM 參數，更換 GC 演算法（例如從 ParNew/CMS 換到 G1）。
    - 調整 Heap 大小或 Young/Old Gen 比例，但這通常是最後手段且需要仔細測試。
- 🗣️口語化回答：遇過程式突然卡住很久，發現是 Full GC 造成的。我會先開 GC 日誌或用監控工具看是哪裡記憶體用太多，是不是有物件沒被收走，然後去優化程式碼，或是調整 JVM 的 GC 參數和策略。

---

# 九、Java 基本語法與物件導向觀念（OOP）

## 重點摘要
Java 是一門物件導向的程式語言。掌握其基本語法、資料類型、控制流程以及最重要的物件導向三大特性（封裝、繼承、多型），是成為合格 Java 工程師的基石。物件導向思維有助於設計出結構清晰、可重用、易於擴展和維護的程式碼。

## 定義
- Java 基本語法：變數、資料類型 (原始類型如 `int`, `double`, `boolean`；引用類型如 `String`, 類別、陣列)、運算子、控制流程語句 (`if`, `for`, `while`, `switch`)、方法 (Method)、類別 (Class)、物件 (Object)、陣列 (Array)。
- 物件導向程式設計 (OOP)：一種程式設計範式，將程式視為獨立的「物件」的集合，這些物件包含數據（屬性）和處理數據的方法（行為）。
- OOP 三大特性：
    - **封裝 (Encapsulation)**：將數據（成員變數）和處理數據的方法（成員方法）綁定在一個單元（類別）中，並通過存取修飾詞（`public`, `private`, `protected`）控制對內部數據的訪問，隱藏內部實現細節。
    - **繼承 (Inheritance)**：允許一個類別（子類別/衍生類別）繼承另一個類別（父類別/基礎類別）的屬性和方法。提高了程式碼的可重用性。 Java 支持單一繼承。
    - **多型 (Polymorphism)**：允許不同的物件對同一個方法調用做出不同的響應。主要體現在方法重載 (Overloading) 和方法覆寫 (Overriding)。
- 抽象 (Abstraction)：OOP 的第四個特性，強調隱藏複雜的實現細節，只展示必要的資訊給使用者。通過抽象類別 (Abstract Class) 和介面 (Interface) 實現。
- 類別 (Class)：物件的藍圖或模板，定義了物件的屬性和方法。
- 物件 (Object)：類別的一個實例，具有特定的屬性值和行為。

## 常考觀念 Q&A

### Q1：請說明物件導向（OOP）的三大特性：封裝、繼承、多型。
- 封裝：就像把資料和處理資料的方法包在一個箱子裡（物件），箱子外面只留一些開關讓你操作，裡面的細節你看不到也動不了。這樣資料比較安全，程式也比較模組化。
- 繼承：就像兒子繼承爸爸的財產和能力。一個子類別可以繼承父類別的屬性和方法，這樣就不用重複寫很多程式碼，提高程式碼的重用性。
- 多型：意思是用同一個名稱呼叫方法，但因為物件類型不同，實際執行的行為會不一樣。例如，父類別有個 `draw()` 方法，子類別（如圓形、方形）覆寫了它，呼叫 `draw()` 時圓形畫圓、方形畫方。
- 🗣️口語化回答：封裝是把東西包起來藏細節，繼承是複製老爸的能力，多型是同一個指令不同物件有不同反應。

### Q2：Java 中的方法重載 (Overloading) 和方法覆寫 (Overriding) 有什麼區別？
- 重載 (Overloading)：發生在同一個類別中。多個方法有相同的方法名稱，但它們的參數列表（參數數量、類型或順序）不同。回傳類型和存取修飾詞可以不同，但不是判斷重載的依據。這是編譯時的多型 (Compile-time Polymorphism / Static Polymorphism)。
- 覆寫 (Overriding)：發生在父類別和子類別之間（繼承關係）。子類別定義了一個和父類別完全相同的方法簽名（方法名稱、參數列表、回傳類型），但提供不同的實作。子類別覆寫方法的存取修飾詞不能比父類別更嚴格。這是執行時的多型 (Runtime Polymorphism / Dynamic Polymorphism)。
- 🗣️口語化回答：重載是同一個類別裡，方法名一樣但參數不一樣；覆寫是子類別寫了一個跟父類別一模一樣的方法，把父類別的換掉。

### Q3：`interface` 和 `abstract class` 有什麼區別？分別用在什麼場景？
- `interface` (介面)：定義了一組方法的規格（協定），但不提供方法的具體實作（Java 8 後可以有 default/static 方法）。一個類別可以實作 (implement) 多個介面。主要用於定義行為標準或協定。
- `abstract class` (抽象類別)：可以包含抽象方法（沒有實作）和具體方法（有實作）。不能被直接實例化，只能被繼承。一個類別只能繼承 (extend) 一個抽象類別。主要用於定義共同的基礎結構或部分實作，供子類別繼承並完成剩餘部分。
- 🗣️口語化回答：Interface 就像一份合約或規格書，只說要做什麼（不能寫怎麼做），一個類別可以簽很多份。Abstract Class 就像半成品，有些做好了有些沒做，只能繼承一個。Interface 強調「能做什麼」，Abstract Class 強調「是什麼」。

### Q4：Primitive types (基本資料類型) 和 Reference types (引用資料類型) 有什麼區別？
- Primitive types：直接存儲實際的值在變數中。包括 `byte`, `short`, `int`, `long`, `float`, `double`, `char`, `boolean`。它們佔用固定大小的記憶體空間。
- Reference types：變數中存儲的是對物件在 Heap 記憶體中的引用（地址），而不是實際的物件本身。包括類別、介面、陣列、枚舉、字符串 (雖然有特殊處理，但 `String` 是物件)。需要通過引用來訪問實際的物件。
- 🗣️口語化回答：基本類型變數裡直接存值，像數字 5 或 True/False。引用類型變數裡存的是物件的「地址」，你要透過這個地址才能找到實際的物件。

## 補充觀念

- **`static`**:
    - 用於成員變數、方法、內部類別和初始化塊。
    - `static` 成員屬於類別本身，而不是類別的任何特定物件實例。所有物件共享同一份 `static` 成員。
    - `static` 方法只能直接存取 `static` 成員。
    - `static` 內部類別可以不依賴外部類別的實例而存在。
- **`final`**:
    - 用於變數、方法和類別。
    - `final` 變數：一旦被賦值，其值不能被改變（對於基本類型是值不能變；對於引用類型是引用不能變，但物件本身內容可以變）。
    - `final` 方法：不能被子類別覆寫。
    - `final` 類別：不能被繼承。
- **`this`**:
    - 指向當前物件的引用。
    - 用於區分成員變數和方法參數（當名稱相同時）。
    - 用於在建構子中呼叫同一個類別的其他建構子 (`this(...)`)。
- **`super`**:
    - 指向父類別的引用。
    - 用於存取父類別的成員變數和方法（當子類別有同名成員時）。
    - 用於在子類別建構子中呼叫父類別的建構子 (`super(...)`)。

## 重要語法或術語
- Class (類別), Object (物件)
- Encapsulation (封裝), Inheritance (繼承), Polymorphism (多型), Abstraction (抽象)
- Method Overloading (方法重載), Method Overriding (方法覆寫)
- `public`, `private`, `protected` (存取修飾詞)
- `static`, `final`
- `abstract class`, `interface`
- Primitive Types (基本資料類型), Reference Types (引用資料類型)
- Constructor (建構子)
- `super`, `this`
- `new` (創建物件)

## 面試常見問法與回答

### Q1：請用一個現實世界的例子，說明如何用物件導向概念來描述它。
- Q：請用一個現實世界的例子，說明如何用物件導向概念來描述它。（例如：寵物系統）
- 例子：寵物系統。
    - 定義一個 `Animal` 抽象類別，包含 `name` 屬性和抽象方法 `makeSound()`。
    - 定義 `Dog` 和 `Cat` 類別，繼承自 `Animal`。它們繼承了 `name` 屬性。
    - `Dog` 覆寫 `makeSound()` 方法為「汪汪」，`Cat` 覆寫 `makeSound()` 方法為「喵喵」。 (多型, 繼承)
    - 在 `Animal` 類別中，可能將 `name` 設定為 `private`，通過 `public` 的 getter/setter 方法訪問。 (封裝)
    - 我們可以創建一個 `List<Animal>` 集合，裡面可以放 `Dog` 和 `Cat` 的物件。遍歷列表呼叫 `makeSound()` 時，會根據實際物件類型發出不同的聲音。 (多型)
    - 🗣️口語化回答：想像一個寵物系統。我們可以有個「動物」的基底，有名字和叫聲，然後「狗」和「貓」繼承動物，但它們的叫聲方法（多型）不一樣。你可以把所有狗和貓都放進一個「動物列表」，一個個叫它們發出聲音，它們就會發出各自的叫聲。

### Q2：你在開發中，如何應用物件導向原則來提升程式碼品質？
- Q：你在開發中，如何應用物件導向原則來提升程式碼品質？
- **封裝**：將相關的數據和行為放在同一個類別中，對外提供清晰的介面，隱藏內部實現細節。這讓程式碼更容易理解和修改，不容易誤用。
- **繼承/組合**：利用繼承（謹慎使用）或更傾向使用組合 (Composition over Inheritance)，來重用程式碼和建立類別之間的關係，避免重複寫輪子。
- **多型/介面**：面向介面程式設計，使用多型來處理不同類型的物件。這樣可以寫出更彈性、更易於擴展的程式碼。當需要新增新的類型時，只需實作介面或繼承抽象類別，而不需要修改現有程式碼。
- 提高可讀性、可維護性和可擴展性。
- 🗣️口語化回答：我會盡量把功能切成有意義的物件，用封裝藏好內部細節。也會多用介面和多型，這樣以後要加新功能或改東西時，程式碼會比較好修改，不用動到太多地方。

---

# 十、Java 筆試程式實作題（必含範例與答案）

---

### 題目：判斷質數

#### 📋 題目說明：
請寫一個 Java 程式，輸入一個整數，判斷是否為質數（只能被 1 和自己整除的正整數，2 是最小質數）。

#### 📥 範例輸入：

輸入：7


#### 📤 預期輸出：

7 是質數


#### ✅ Java 解答：

java
import java.util.Scanner;

public class PrimeChecker {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("請輸入數字："); // 增加提示
        int num = scanner.nextInt();
        boolean isPrime = true; // 初始化為 true

        // 根據質數定義判斷
        if (num <= 1) {
            isPrime = false;
        } else if (num == 2) {
            isPrime = true; // 2 是質數
        } else if (num % 2 == 0) {
            isPrime = false; // 大於2的偶數不是質數
        } else {
            // 從 3 開始檢查奇數因子，到 Math.sqrt(num) 即可
            for (int i = 3; i * i <= num; i = i + 2) {
                if (num % i == 0) {
                    isPrime = false;
                    break; // 找到一個因子就夠了
                }
            }
        }

        System.out.println(num + (isPrime ? " 是質數" : " 不是質數"));
        scanner.close();
    }
}


#### 📌 重點解析：
- 使用 `boolean isPrime` 作為旗標記錄狀態。
- 特殊處理 `num <= 1` 和 `num == 2` 的情況。
- 優化：排除大於 2 的偶數，迴圈只檢查奇數因子，步長為 2。
- 優化：迴圈條件 `i * i <= num` 等同於檢查到 `Math.sqrt(num)`，效率更高且避免浮點運算。
- 使用 `break` 在找到第一個因子時提前結束迴圈。

---

### 題目：印出靠左下對齊的直角三角形

#### 📋 題目說明：
請寫一個 Java 程式，輸入一個整數 `n`，印出一個由星號組成的靠左下對齊的直角三角形，共 `n` 行。

#### 📥 範例輸入：

輸入：5


#### 📤 預期輸出：

*
**
***
****
*****


#### ✅ Java 解答：

java
import java.util.Scanner;

public class LeftTriangle {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("請輸入三角形的行數：");
        int numRows = scanner.nextInt();

        if (numRows <= 0) {
            System.out.println("行數必須是正整數。");
        } else {
            // 外層迴圈控制行數
            for (int i = 1; i <= numRows; i++) {
                // 內層迴圈控制每行印出的星號數量
                for (int j = 1; j <= i; j++) {
                    System.out.print("*");
                }
                // 每行結束後換行
                System.out.println();
            }
        }
        scanner.close();
    }
}


#### 📌 重點解析：
- 使用巢狀迴圈 (`for` 迴圈)。
- 外層迴圈控制當前是第幾行（從 1 到 `numRows`）。
- 內層迴圈控制當前行要印出的字元數量。關鍵在於內層迴圈的次數等於外層迴圈的當前行數 `i` (`j <= i`)。
- `System.out.print` 在同一行印出星號。
- `System.out.println` 在內層迴圈結束後換行。
- (延伸：靠右直角三角形需要在星號前印出空格；等腰三角形需要處理空格和星號的數量，且對稱印出)。

---

### 題目：印出九九乘法表

#### 📋 題目說明：
請寫一個 Java 程式，印出排版整齊的九九乘法表 (1x1 到 9x9)。

#### 📤 預期輸出：

1 * 1 =  1   1 * 2 =  2   ... 1 * 9 =  9   
2 * 1 =  2   2 * 2 =  4   ... 2 * 9 = 18   
...
9 * 1 =  9   9 * 2 = 18   ... 9 * 9 = 81

(注意數字對齊)

#### ✅ Java 解答：

java
public class MultiplicationTable {
    public static void main(String[] args) {
        // 外層迴圈控制被乘數 (1 到 9)
        for (int i = 1; i <= 9; i++) {
            // 內層迴圈控制乘數 (1 到 9)
            for (int j = 1; j <= 9; j++) {
                // 使用 printf 進行格式化輸出
                // %d 輸出整數
                // %2d 表示至少佔用 2 個字元寬度並右對齊 (前面補空格)
                System.out.printf("%d * %d = %2d   ", i, j, i * j);
            }
            // 每行結束後換行
            System.out.println();
        }
    }
}


#### 📌 重點解析：
- 使用巢狀迴圈：外層迴圈 `i` 控制被乘數，內層迴圈 `j` 控制乘數。
- 使用 `System.out.printf()` 方法進行格式化輸出，確保數字對齊。
- 格式化字串 `"%d * %d = %2d   "`:
    - 前兩個 `%d` 分別對應 `i` 和 `j`。
    - `%2d` 對應乘積 `i * j`，它會將數字以至少 2 個字元的寬度輸出，不足時在前面補空格，實現右對齊。
    - `   ` (空格) 用於分隔不同的乘法式。
- `System.out.println()` 在內層迴圈結束後換行，形成表格結構。

---

### 題目：印出前 N 個費式數列

#### 📋 題目說明：
請寫一個 Java 程式，輸入一個整數 `N`，印出費式數列的前 `N` 個數字。費式數列從 0, 1 開始，後續數字為前兩者之和 (0, 1, 1, 2, 3, 5, ...)。

#### 📥 範例輸入：

輸入：10


#### 📤 預期輸出：

費式數列的前 10 項為：0, 1, 1, 2, 3, 5, 8, 13, 21, 34


#### ✅ Java 解答：

java
import java.util.Scanner;

public class FibonacciSequence {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("請輸入要印出的費式數列項數 (N)：");
        int n = scanner.nextInt();

        if (n <= 0) {
            System.out.println("項數必須是正整數。");
        } else {
            System.out.print("費式數列的前 " + n + " 項為：");

            // 初始化前兩個費式數，使用 long 避免溢位
            long num1 = 0;
            long num2 = 1;

            // 處理前兩項及後續項的印出
            if (n >= 1) {
                System.out.print(num1); // 第一項
            }
            if (n >= 2) {
                System.out.print(", " + num2); // 第二項
            }

            // 從第三項開始迭代計算並印出
            for (int i = 3; i <= n; i++) {
                long nextNum = num1 + num2; // 計算下一項
                System.out.print(", " + nextNum); // 印出下一項，前面加逗號和空格

                // 更新 num1 和 num2 為下一次迭代做準備
                num1 = num2;
                num2 = nextNum;
            }
            System.out.println(); // 最後換行
        }
        scanner.close();
    }
}


#### 📌 重點解析：
- 使用迭代方式計算費式數列，效率高於遞歸（遞歸會有大量重複計算）。
- 需要兩個變數 `num1` 和 `num2` 分別儲存當前計算所需的兩個前項。
- 每次迭代計算出 `nextNum = num1 + num2`，然後更新 `num1 = num2` 和 `num2 = nextNum`。
- 使用 `long` 型別儲存數字，因為費式數列增長很快，避免 `int` 溢位。
- 單獨處理 `N=1` 和 `N=2` 的情況，以正確印出前兩項並控制逗號的格式。
- 使用 `System.out.print` 搭配 ", " 來控制輸出格式。

---

### 題目：回文判斷（isPalindrome）

#### 📋 題目說明：
請寫一個 Java 程式，判斷輸入的字串是否為回文 (正讀反讀都一樣)，忽略大小寫。

#### 📥 範例輸入：

輸入：Level


#### 📤 預期輸出：

"Level" 是回文字串


#### 📥 範例輸入：

輸入：Java


#### 📤 預期輸出：

"Java" 不是回文字串


#### ✅ Java 解答：

java
import java.util.Scanner;

public class PalindromeChecker {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("請輸入一個字串：");
        String inputString = scanner.nextLine();

        // 將字串轉換為小寫，以便忽略大小寫比較
        String cleanedString = inputString.toLowerCase();

        boolean isPalindrome = true;
        int length = cleanedString.length();

        // 使用雙指標從兩端向中間檢查
        for (int i = 0; i < length / 2; i++) {
            // 比較從開頭算起第 i 個字元 和 從結尾算起第 i 個字元
            if (cleanedString.charAt(i) != cleanedString.charAt(length - 1 - i)) {
                isPalindrome = false; // 發現不匹配的字元
                break; // 一旦發現不匹配，即可確定不是回文
            }
        }

        if (isPalindrome) {
            System.out.println("\"" + inputString + "\" 是回文字串");
        } else {
            System.out.println("\"" + inputString + "\" 不是回文字串");
        }
        scanner.close();
    }
}


#### 📌 重點解析：
- 使用 `String.toLowerCase()` 將字串轉換為小寫，實現忽略大小寫比較。
- 使用 `String.charAt(index)` 獲取指定位置的字元。
- 使用雙指標或單指標遍歷字串的一半：從開頭 `i` 往後，從結尾 `length - 1 - i` 往前。
- 迴圈只需要檢查到字串長度的一半 (`length / 2`)，因為對稱位置的比較只需要做一次。
- 如果在任何位置發現不匹配的字元，將 `isPalindrome` 設為 `false` 並立即 `break` 退出迴圈。
- 字串長度為 0 或 1 時，迴圈不會執行，`isPalindrome` 保持 `true`，判斷結果正確。
- (延伸：如果需要忽略空格和標點符號，可以在轉小寫後，再使用正則表達式或其他方法過濾掉非字母數字字元，形成一個乾淨的字串再進行判斷)。

---

### 題目：找出陣列最大值與最小值

#### 📋 題目說明：
請寫一個 Java 程式，找出給定整數陣列中的最大值和最小值。

#### 📥 範例輸入：

陣列為：[12, 45, 6, 89, 23, 5, 90]


#### 📤 預期輸出：

陣列中的最大值是：90
陣列中的最小值是：5


#### ✅ Java 解答：

java
public class FindMinMax {
    public static void main(String[] args) {
        int[] numbers = {12, 45, 6, 89, 23, 5, 90};

        // 檢查陣列是否為空或 null
        if (numbers == null || numbers.length == 0) {
            System.out.println("陣列為空，無法找到最大值和最小值。");
            return;
        }

        // 初始化最大值和最小值為陣列的第一個元素
        int max = numbers[0];
        int min = numbers[0];

        // 從陣列的第二個元素開始遍歷
        for (int i = 1; i < numbers.length; i++) {
            // 更新最大值
            if (numbers[i] > max) {
                max = numbers[i];
            }
            // 更新最小值
            if (numbers[i] < min) {
                min = numbers[i];
            }
        }

        // 印出結果
        System.out.println("陣列中的最大值是：" + max);
        System.out.println("陣列中的最小值是：" + min);
    }
}


#### 📌 重點解析：
- 遍歷陣列一次，同時比較和更新最大值和最小值。
- 初始化 `max` 和 `min` 為陣列的第一個元素 (`numbers[0]`)。這樣確保了無論陣列元素是正數、負數還是零，初始值都在有效範圍內。
- 從第二個元素（索引 1）開始迴圈遍歷。
- 在迴圈中，用當前元素與 `max` 和 `min` 分別比較，並更新相應的值。
- 考慮陣列為 `null` 或空陣列的邊界情況，避免錯誤。

---

### 題目：氣泡排序（Bubble Sort）

#### 📋 題目說明：
請寫一個 Java 程式，使用氣泡排序演算法對一個整數陣列進行升序排序。

#### 📥 範例輸入：

原始陣列：[64, 34, 25, 12, 22, 11, 90]


#### 📤 預期輸出：

排序後的陣列：[11, 12, 22, 25, 34, 64, 90]


#### ✅ Java 解答：

java
import java.util.Arrays;

public class BubbleSort {

    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        // 外層迴圈控制排序的趟數 (最多 n-1 趟)
        for (int i = 0; i < n - 1; i++) {
            // 優化：如果一趟沒有交換，說明已經有序
            boolean swapped = false;

            // 內層迴圈比較和交換相鄰元素
            // 每趟結束，最後 i 個元素已經是有序的，所以範圍縮小
            for (int j = 0; j < n - 1 - i; j++) {
                // 如果前一個元素大於後一個，交換它們
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true; // 發生了交換
                }
            }

            // 如果本趟沒有交換，則提前結束
            if (!swapped) {
                break;
            }
        }
    }

    public static void main(String[] args) {
        int[] data = {64, 34, 25, 12, 22, 11, 90};
        System.out.println("原始陣列: " + Arrays.toString(data));

        bubbleSort(data); // 呼叫排序方法

        System.out.println("排序後的陣列: " + Arrays.toString(data));
    }
}


#### 📌 重點解析：
- 氣泡排序通過重複遍歷，比較並交換相鄰元素來排序。
- 使用巢狀迴圈：外層迴圈控制趟數，內層迴圈控制每趟的比較範圍。
- 內層迴圈的比較範圍會隨著外層迴圈的執行而縮小，因為每趟都能確定一個最大元素到其最終位置。
- 使用臨時變數 `temp` 來完成兩個元素的交換。
- 添加 `swapped` 旗標作為優化：如果在某趟遍歷中沒有發生任何交換，說明陣列已經有序，可以提前結束排序。

---

### 題目：不使用第三變數交換兩數

#### 📋 題目說明：
請寫一個 Java 程式，交換兩個整數變數的值，但不能使用任何額外的（第三個）變數來暫存值。

#### 📥 範例輸入：

交換前：a = 5, b = 10


#### 📤 預期輸出：

交換後：a = 10, b = 5


#### ✅ Java 解答：

java
public class SwapWithoutThirdVariable {
    public static void main(String[] args) {
        int a = 5;
        int b = 10;

        System.out.println("交換前：a = " + a + ", b = " + b);

        // 使用數學運算交換 (加減法)
        // 1. a = a + b; (a 現在是兩數之和)
        // 2. b = a - b; (b 現在是 (a+b) - b = a 的原始值)
        // 3. a = a - b; (a 現在是 (a+b) - (a 的原始值) = b 的原始值)
        a = a + b;
        b = a - b;
        a = a - b;

        // 另一種方法：使用位元運算 (XOR)
        /*
        a = a ^ b; // a = a XOR b
        b = a ^ b; // b = (a XOR b) XOR b = a 的原始值
        a = a ^ b; // a = (a XOR b 的原始值) XOR (a 的原始值) = b 的原始值
        */

        System.out.println("交換後：a = " + a + ", b = " + b);
    }
}


#### 📌 重點解析：
- 此題考驗不依賴臨時變數進行值交換的技巧。
- **方法一：加減法**
    - 透過三次數學運算巧妙地在原始變數上儲存中間結果並導出最終結果。
    - 步驟如範例程式碼中註釋所示。
    - 注意：這種方法可能存在溢位問題，如果 `a + b` 超出 `int` 的最大範圍。
- **方法二：位元運算 (XOR)**
    - 利用 XOR 運算符的特性：`x ^ x = 0`，`x ^ 0 = x`，`x ^ y = y ^ x`，以及結合律 `(x ^ y) ^ z = x ^ (y ^ z)`。
    - 透過三次 XOR 運算實現交換，步驟如範例程式碼中註釋所示。
    - 此方法通常更安全，因為它不會產生溢位問題。
- 面試中通常會考察這兩種方法中的一種或兩種。加減法相對直觀，XOR 則更顯對位元運算的理解。

---

# 十一、JavaScript 語法重點

## 常用語法：
- **宣告變數**：`var`, `let`, `const` 差異  
    - `var`: 函數作用域或全域作用域，可以重複宣告，存在變數提升 (Hoisting)。
    - `let`: 區塊作用域 (Block Scope)，不能重複宣告，有暫時性死區 (Temporal Dead Zone)，用於宣告會改變的變數。
    - `const`: 區塊作用域，不能重複宣告，有暫時性死區，用於宣告值不可變的變數（對於物件和陣列，是引用不可變，內部屬性/元素可變）。
- **非同步處理**：`Promise` vs `async/await`  
    - `Promise`: 用於處理非同步操作的結果（成功或失敗），提供 `then()` 和 `catch()` 方法鏈式調用，解決回調地獄 (Callback Hell) 問題。
    - `async/await`: 基於 `Promise` 的語法糖，使非同步代碼寫起來像同步代碼一樣，更易讀寫。`async` 函數會回傳一個 Promise，`await` 只能在 `async` 函數內部使用，等待 Promise 解決。
- **`this` 的作用域變化**  
    - `this` 的值取決於函數的執行方式（如何被呼叫）。
    - 全域上下文：`this` 指向全域物件 (瀏覽器中是 `window`，Node.js 中是 `global`)。
    - 函數呼叫 (`function()`)：在非嚴格模式下，`this` 指向全域物件；在嚴格模式下，`this` 為 `undefined`。
    - 方法呼叫 (`object.method()`)：`this` 指向呼叫該方法的物件。
    - 建構子呼叫 (`new Constructor()`)：`this` 指向新建立的物件實例。
    - 事件處理器：`this` 通常指向觸發事件的元素。
    - 箭頭函數 (`=>`)：箭頭函數沒有自己的 `this`，它會捕獲其所在上下文的 `this` 值，並且不會改變。
    - 可以使用 `call()`, `apply()`, `bind()` 改變 `this` 的指向。
- **型別比較**：`==` vs `===`  
    - `==` (相等運算符)：比較時會進行型別轉換（Coercion），可能導致非預期的結果。例如 `5 == '5'` 為 `true`。
    - `===` (嚴格相等運算符)：比較時不進行型別轉換，要求值和型別都必須嚴格相等。例如 `5 === '5'` 為 `false`。
    - 在大多數情況下，建議使用 `===` 以避免隱式的型別轉換帶來的問題。

## 常用資料結構與方法：
- **陣列 (Array)**：常用方法如 `push()`, `pop()`, `shift()`, `unshift()`, `splice()`, `slice()`, `forEach()`, `map()`, `filter()`, `reduce()`, `find()`, `indexOf()`, `includes()`, `sort()`。
- **物件 (Object)**：常用操作如屬性訪問 (`.` 或 `[]`), `Object.keys()`, `Object.values()`, `Object.entries()`, 展開運算符 (`...`) 進行淺拷貝或合併。
- **字串 (String)**：常用方法如 `length`, `charAt()`, `substring()`, `slice()`, `indexOf()`, `replace()`, `split()`, `trim()`, `toUpperCase()`, `toLowerCase()`。

## 範例：

### 範例：箭頭函數與模板字串

js
// 箭頭函數：簡潔的函數寫法，且 this 綁定行為不同
const greet = (name) => `Hello, ${name}`;

console.log(greet('World')); // 輸出: Hello, World

// 模板字串：使用反引號定義字串，可以直接嵌入變數 ${}
const message = `你好，${greet('開發者')}！`;
console.log(message); // 輸出: 你好，Hello, 開發者！


### 範例：Promise 非同步處理

js
function fetchData() {
  return new Promise((resolve, reject) => {
    // 模擬非同步操作 (例如網路請求)
    setTimeout(() => {
      const success = true; // 假設操作成功
      if (success) {
        resolve('數據成功獲取'); // 操作成功，呼叫 resolve
      } else {
        reject('數據獲取失敗'); // 操作失敗，呼叫 reject
      }
    }, 1000); // 模擬延遲 1 秒
  });
}

fetchData()
  .then(data => {
    console.log(data); // 輸出：數據成功獲取 (如果 success 為 true)
  })
  .catch(error => {
    console.error(error); // 輸出：數據獲取失敗 (如果 success 為 false)
  });


### 範例：Async/Await 非同步處理

js
async function processData() {
  try {
    console.log('開始獲取數據...');
    // await 等待 fetchData() 這個 Promise 解決
    const data = await fetchData();
    console.log('獲取到數據:', data); // 在 await 解決後執行
    console.log('數據處理完成。');
  } catch (error) {
    console.error('處理數據時發生錯誤:', error); // 捕獲 Promise 中的 reject
  }
}

// 調用 async 函數
processData();

// 注意：fetchData() 是上面 Promise 範例中的函數
function fetchData() {
  return new Promise((resolve, reject) => {
    // 模擬非同步操作
    setTimeout(() => {
      const success = true; // 改變這裡可以測試 catch
      if (success) {
        resolve('一些數據');
      } else {
        reject('出錯了');
      }
    }, 1000);
  });
}


---
