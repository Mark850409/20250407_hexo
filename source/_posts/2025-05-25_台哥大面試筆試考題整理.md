---
title: Java 全端考前小抄筆記
date: 2023-12-08T14:32:23.301Z
tags:
- Java
- 全端
- 筆記
- 考前
- 資安
- RESTful API
- HTTP
- 資料庫
- 正規化
- SQL
- Spring Boot
- GC
- 物件導向
- JavaScript
categories:
- 後端開發
- 全端開發
---

# 【Java 全端考前小抄筆記】

---

# 一、資安（Web Security）

## 重點摘要
Web 資安是保護網站、應用程式和使用者免受網路威脅的核心工作。範圍涵蓋防禦常見的攻擊手法如 SQL Injection、XSS、CSRF 等，並確保資料的機密性、完整性與可用性。對於全端工程師而言，理解常見的資安弱點及其防禦措施至關重要，這不僅是技術能力的要求，也是保障系統與使用者安全的基本責任。

## 定義
- Web 安全性：保護網站和 Web 應用程式及其使用者免受網路攻擊的行為和實踐。
- 常見威脅：SQL Injection (SQL 隱碼攻擊)、Cross-Site Scripting (XSS 跨站腳本攻擊)、Cross-Site Request Forgery (CSRF 跨站請求偽造)、Authentication/Authorization 繞過、Session Hijacking 等。
- 防禦策略：輸入驗證與清理、輸出編碼、使用參數化查詢、實作 CSRF Token、安全的 Session 管理、使用 HTTPS、定期安全掃描與更新函式庫等。
- OWASP Top 10：開放式 Web 應用程式安全專案列出的十大最嚴重 Web 應用程式安全風險清單，是重要的參考指標。

## 常考觀念 Q&A

### Q1：什麼是 Web 安全性？在開發中為何重要？
- 保護網站及應用程式免受惡意攻擊。
- 確保資料的機密性、完整性與可用性。
- 保護使用者隱私及信任。
- 避免潛在的法律風險與名譽損失。
- 🗣️口語化回答：Web 資安就是確保你的網站不會被駭客入侵、資料被偷或破壞，保護使用者很重要的。

### Q2：請說明 SQL Injection（隱碼攻擊）是什麼？如何防範？
- 攻擊者透過在使用者輸入欄位注入惡意的 SQL 語句。
- 利用程式未對使用者輸入進行充分過濾，導致惡意 SQL 語句被資料庫執行。
- 可能導致資料洩漏、竄改甚至刪除。
- 防範方法：使用參數化查詢（Prepared Statements）或ORM 框架、避免使用字串拼接 SQL 語句、對所有使用者輸入進行嚴格的驗證與過濾。
- 🗣️口語化回答：駭客在輸入框偷塞資料庫指令，利用程式漏洞讓資料庫執行。最簡單的防範就是用參數化查詢，不要直接把輸入跟 SQL 連起來。

### Q3：什麼是 XSS（跨站腳本攻擊）？有幾種？如何防範？
- 攻擊者將惡意腳本注入到網頁中，當其他使用者瀏覽該網頁時，惡意腳本就會在他們的瀏覽器上執行。
- 類型：儲存型 XSS（Stored XSS）、反射型 XSS（Reflected XSS）、DOM 型 XSS。
- 可能導致竊取 Cookie、Session、偽造請求等。
- 防範方法：對使用者輸入進行驗證與清理；在輸出到網頁前對所有不可信任的資料進行適當的 HTML 實體編碼（Output Encoding）。
- 🗣️口語化回答：就是駭客把惡意程式碼藏在網頁裡，當你打開網頁時程式碼就在你瀏覽器跑起來了。防範方法是在顯示使用者輸入的內容時，把一些特殊符號轉掉。

### Q4：什麼是 CSRF（跨站請求偽造）？如何防範？
- 攻擊者誘騙使用者點擊連結或圖片，利用使用者已登入的身份，在使用者不知情的情況下發送偽造的請求到目標網站。
- 目標網站會認為這是使用者自己的合法請求並執行。
- 防範方法：使用 CSRF Token（伺服器生成一個隨機 token 放入表單或 header，客戶端提交時帶回驗證）、檢查 Referer Header、使用 SameSite Cookie 屬性。
- 🗣️口語化回答：駭客騙你點一個連結，利用你網站登入中的狀態，去做一些你沒授權的事情。可以用一個只有你知道的特殊驗證碼（CSRF token）來防。

## 重要語法或術語
- SQL Injection
- XSS (Cross-Site Scripting)
- CSRF (Cross-Site Request Forgery)
- HTTPS / SSL/TLS
- OWASP Top 10
- Input Validation
- Output Encoding
- Parameterized Query
- CSRF Token
- Authentication
- Authorization
- Session Management

## 面試常見問法與回答

### Q1：你在過去的專案中，是如何考慮和實作資安的？
- Q：你在過去的專案中，是如何考慮和實作資安的？
- 針對使用者輸入，實作嚴格的驗證與清理，防止常見的注入攻擊。
- 對於資料庫操作，全部使用參數化查詢或 ORM，避免 SQL Injection。
- 開發 RESTful API 時，實作適當的身份驗證（Authentication）和權限控管（Authorization）。
- 在敏感操作上，實作 CSRF 防護（如使用框架提供的 CSRF Token）。
- 網站部署使用 HTTPS，加密傳輸過程。
- 🗣️口語化回答：主要是對所有使用者輸入都檢查和過濾，資料庫操作用安全的寫法。前後端溝通走 HTTPS，敏感操作會加上 CSRF 防護。

### Q2：如果發現專案有資安漏洞，你的處理流程是什麼？
- Q：如果發現專案有資安漏洞，你的處理流程是什麼？
- 確認漏洞的存在與影響範圍，判斷嚴重程度。
- 立刻制定修補方案並盡快實作。
- 修補完成後進行嚴格測試，確保漏洞確實被修補且未引入新的問題。
- 視情況通知相關人員（團隊、主管、使用者）。
- 檢討原因，並將防範措施納入開發流程或code review規範。
- 🗣️口語化回答：先確認漏洞，馬上修好，然後測試確保修好了，最後討論怎麼避免下次再發生。

---

# 二、RESTful API

## 重點摘要
RESTful API 是一種設計 Web 服務介面的架構風格，基於 HTTP 協定，強調以「資源」為中心，並透過標準的 HTTP 方法（GET, POST, PUT, DELETE 等）來操作這些資源。它的主要優點是架構清晰、易於理解和擴展，無狀態性使其 scalable，是目前主流的 API 設計方式，廣泛應用於前後端分離、微服務等場景。

## 定義
- REST：Representational State Transfer 的縮寫，一種用於分散式系統的架構風格。
- RESTful API：遵循 REST 原則設計的 Web API。
- 核心原則：
    - **資源 (Resource)**：網路上的實體，用 URI (Uniform Resource Identifier) 表示，如 `/users`, `/products/123`。
    - **統一介面 (Uniform Interface)**：使用標準的 HTTP 方法操作資源。
    - **無狀態 (Stateless)**：伺服器不保留客戶端狀態，每個請求都包含處理所需的所有資訊。
    - **客戶端-伺服器 (Client-Server)**：關注點分離，客戶端和伺服器獨立發展。
    - **可快取 (Cacheable)**：客戶端可以快取伺服器的響應，提升效能。
    - **分層系統 (Layered System)**：伺服器和客戶端之間的通訊可以經過多個中間層。
    - **按需程式碼 (Code on Demand)**：伺服器可以暫時擴展或自訂客戶端的功能 (可選)。

## 常考觀念 Q&A

### Q1：什麼是 RESTful API？它和 SOAP 有什麼主要區別？
- RESTful API 是一種基於 HTTP 的架構風格，以資源為中心，輕量級且彈性高，常用於 Web 和行動應用。
- SOAP 是基於 XML 的協定，相對重量級，通常使用 WSDL 描述服務，常用於企業級應用或遺留系統。
- RESTful API 更依賴 HTTP 方法，SOAP 則使用 XML 信封。
- RESTful API 無狀態，SOAP 可以是有狀態的。
- 🗣️口語化回答：RESTful 就是一種用 HTTP 方法來操作「資源」的介面設計方式，比較輕巧好用。SOAP 比較老牌、重量級，通常用 XML 來傳資料。

### Q2：GET, POST, PUT, DELETE 這幾個 HTTP 方法在 RESTful API 中通常代表什麼操作？
- GET：用於獲取資源。
- POST：用於建立新的資源。
- PUT：用於完整更新資源。
- DELETE：用於刪除資源。
- 還有 PATCH：用於部分更新資源。
- 🗣️口語化回答：GET 就是查資料，POST 是新增一筆，PUT 是把一整筆資料換新的，DELETE 是刪掉。

### Q3：RESTful API 的「無狀態」是什麼意思？為什麼重要？
- 指伺服器不會在兩次請求之間保留客戶端的任何狀態資訊。每個請求都必須包含處理該請求所需的所有資訊。
- 重要性：提高擴展性（Scaling），伺服器更容易分散到多台機器；提高可靠性，單個伺服器失敗不影響其他請求；簡化伺服器設計。
- 🗣️口語化回答：就是伺服器不會記住你上次做了什麼。每次請求都要告訴伺服器足夠的資訊讓它處理，這樣伺服器比較好擴展。

### Q4：什麼是冪等性 (Idempotence)？哪些 HTTP 方法是冪等的？
- 指對同一 URI 的同一請求執行多次，會產生相同的結果（儘管伺服器狀態可能改變）。
- 冪等方法：GET, PUT, DELETE, HEAD, OPTIONS。
- 非冪等方法：POST (多次 POST 同一數據可能建立多個資源)。PATCH 通常也非冪等，除非特別設計。
- 🗣️口語化回答：冪等就是重複發送同一個請求，產生的結果會是一樣的。像 GET、PUT、DELETE 都是，重複呼叫也不會出問題。

## 重要語法或術語
- REST
- Resource (資源)
- URI (Uniform Resource Identifier)
- Endpoint
- HTTP Methods (GET, POST, PUT, DELETE, PATCH)
- Stateless (無狀態)
- Idempotent (冪等性)
- HATEOAS (Hypermedia as the Engine of Application State) - 進階概念
- JSON / XML (資料格式)

## 面試常見問法與回答

### Q1：你在專案中是怎麼設計 RESTful API 的？請舉例說明一個資源的設計。
- Q：你在專案中是怎麼設計 RESTful API 的？請舉例說明一個資源的設計。
- 識別核心「資源」，通常用名詞表示，且常用複數 (e.g., `/users`, `/orders`)。
- 使用子資源表達關係 (e.g., `/users/{userId}/orders`)。
- 根據操作類型使用正確的 HTTP 方法 (GET 獲取、POST 建立、PUT 完整更新、DELETE 刪除)。
- 使用 HTTP Status Code 表示結果 (200 OK, 201 Created, 400 Bad Request, 404 Not Found, 500 Internal Server Error)。
- 例如：會員資源 (`/users`)。
    - `GET /users`：獲取所有會員列表。
    - `GET /users/{id}`：獲取特定 ID 的會員資料。
    - `POST /users`：新增會員。
    - `PUT /users/{id}`：完整更新特定 ID 會員資料。
    - `DELETE /users/{id}`：刪除特定 ID 會員。
- 🗣️口語化回答：我會先把系統裡的「東西」（資源）找出來，用像 `/users` 這樣名詞當網址。然後根據要做什麼動作，用對 GET/POST/PUT/DELETE 方法。

### Q2：如何在 RESTful API 中處理版本控制？
- Q：如何在 RESTful API 中處理版本控制？
- URL Path Versioning (e.g., `/v1/users`, `/v2/users`)：最直觀但修改 URI 會影響所有客戶端。
- Query Parameter Versioning (e.g., `/users?version=v1`)：對客戶端影響較小，但可能與其他參數混淆。
- Header Versioning (e.g., `Accept: application/vnd.myapp.v1+json`)：符合 REST 原則中透過 Header 進行內容協商，但客戶端實作稍複雜。
- 🗣️口語化回答：有幾種方法，最常見的是在網址裡加版本號，像是 `/v1/users`。或是放在 Header 裡，只是 Header 比較難測。

---

# 三、HTTP 基本結構與方法

## 重點摘要
HTTP (Hypertext Transfer Protocol) 是 Web 資料傳輸的基礎協定。理解 HTTP 的基本結構（請求與回應）以及常用的方法（GET, POST 等）是進行 Web 開發的根本。它定義了客戶端（瀏覽器或其他應用）如何向伺服器發送請求，以及伺服器如何回傳響應，包括狀態碼表示處理結果。

## 定義
- HTTP：超文本傳輸協定，應用層協定，用於在客戶端和伺服器之間傳輸超文本（如 HTML）和其他資源。
- 請求-回應模型：客戶端發送請求給伺服器，伺服器處理後回傳回應。
- HTTP 請求 (Request) 的基本結構：
    - **起始行 (Start Line / Request Line)**：包含請求方法 (Method)、請求 URI 和 HTTP 版本。
    - **請求標頭 (Headers)**：提供關於請求、客戶端或資源的元數據，如 `Content-Type`, `User-Agent`, `Cookie` 等。
    - **請求體 (Body)**：包含請求的實際數據，例如 POST 請求提交的表單數據或 JSON 數據 (GET, HEAD 等請求通常沒有 Body)。
- HTTP 回應 (Response) 的基本結構：
    - **起始行 (Start Line / Status Line)**：包含 HTTP 版本、狀態碼 (Status Code) 和狀態文本 (Reason Phrase)。
    - **回應標頭 (Headers)**：提供關於回應、伺服器或資源的元數據，如 `Content-Type`, `Content-Length`, `Server`, `Set-Cookie`, `Cache-Control` 等。
    - **回應體 (Body)**：包含伺服器回傳的實際數據，例如 HTML 頁面、JSON 資料、圖片等 (HEAD 請求通常沒有 Body)。
- 常見 HTTP 方法：GET, POST, PUT, DELETE, HEAD, OPTIONS, PATCH。
- 常見 HTTP 狀態碼：1xx (資訊)、2xx (成功)、3xx (重定向)、4xx (客戶端錯誤)、5xx (伺服器錯誤)。

## 常考觀念 Q&A

### Q1：請說明 HTTP Request 的三個主要組成部分。
- **起始行 (Start Line)**：包含請求方法 (GET/POST 等)、資源路徑 (URI) 和 HTTP 版本。
- **標頭 (Headers)**：提供額外的資訊，例如客戶端的類型、接受的內容格式、Cookies 等。
- **請求體 (Body)**：包含要發送給伺服器的實際數據，POST 或 PUT 請求通常有 Body。
- 🗣️口語化回答：主要就是最上面一行說明要做什麼（GET/POST）、找哪個網址，再來是一堆 Header 描述細節，最後是可能會有個 Body 放要送的資料。

### Q2：請說明 HTTP Response 的三個主要組成部分。
- **起始行 (Status Line)**：包含 HTTP 版本、一個數字的狀態碼 (Status Code) 和狀態文字說明。
- **標頭 (Headers)**：提供額外的資訊，例如回傳內容的類型、Cookie 設定、快取指示等。
- **回應體 (Body)**：包含伺服器回傳的主要內容，像是網頁內容、圖片或 JSON 資料。
- 🗣️口語化回答：跟 Request 類似，有第一行狀態碼（成功還是失敗），再來是一堆 Header 描述回傳內容，最後是 Body 放實際的網頁或資料。

### Q3：GET 和 POST 方法有什麼主要區別？請從多個角度說明。
- **傳送數據方式**：GET 將數據放在 URI 的 query string 中，POST 將數據放在請求體 (Request Body) 中。
- **安全性 (數據暴露)**：GET 數據顯示在 URL 中，可能被記錄在瀏覽器歷史或伺服器日誌，不適合傳輸敏感資訊；POST 數據在 Body 中，相對較隱私。
- **數據大小限制**：GET 受限於 URL 長度 (因瀏覽器和伺服器而異)，POST 沒有嚴格限制。
- **緩存 (Caching)**：GET 請求可以被瀏覽器緩存，POST 請求通常不會被緩存。
- **冪等性**：GET 是冪等的（重複請求結果一致），POST 不是冪等的。
- **用途**：GET 主要用於獲取數據，POST 主要用於提交數據以建立或修改資源。
- 🗣️口語化回答：GET 的資料顯示在網址上，POST 藏在內容裡。GET 比較適合拿資料，POST 適合送資料去新增或修改。GET 可以被快取和重複呼叫，POST 則通常不行。

### Q4：HTTP 狀態碼 200, 404, 500 各代表什麼意思？請再舉兩個常見的狀態碼並說明。
- **200 OK**：請求成功。
- **404 Not Found**：伺服器找不到請求的資源。
- **500 Internal Server Error**：伺服器在處理請求時發生了內部錯誤。
- **201 Created**：請求成功，並建立了一個新的資源 (常用於 POST 請求)。
- **400 Bad Request**：伺服器無法理解客戶端發送的請求，請求語法錯誤。
- **401 Unauthorized**：請求需要身份驗證，但使用者尚未提供憑證或憑證無效。
- **403 Forbidden**：伺服器理解請求，但拒絕執行（沒有權限）。
- **301 Moved Permanently**：資源被永久移動到新的位置，客戶端應更新其連結。
- 🗣️口語化回答：200 是成功，404 是找不到東西，500 是伺服器自己出錯了。還有 201 是新增成功，400 是你發的請求有問題。

## 重要語法或術語
- HTTP/1.1, HTTP/2
- HTTP Request
- HTTP Response
- HTTP Method (GET, POST, PUT, DELETE, etc.)
- Status Code (狀態碼)
- Headers (標頭)
- Body (內容)
- URI / URL
- Query String
- Idempotence (冪等性)
- Cache (快取)

## 面試常見問法與回答

### Q1：你在開發後端 API 時，如何根據業務邏輯回傳正確的 HTTP Status Code？
- Q：你在開發後端 API 時，如何根據業務邏輯回傳正確的 HTTP Status Code？
- 成功讀取：回傳 200 OK。
- 成功建立資源（如註冊會員）：回傳 201 Created。
- 成功刪除或修改（無內容回傳）：回傳 204 No Content。
- 客戶端請求數據格式錯誤、缺少必要參數等：回傳 400 Bad Request。
- 請求的資源找不到：回傳 404 Not Found。
- 使用者未登入或身份驗證失敗：回傳 401 Unauthorized。
- 使用者已登入但沒有權限執行操作：回傳 403 Forbidden。
- 伺服器內部發生未預期的錯誤：回傳 500 Internal Server Error。
- 🗣️口語化回答：根據處理結果回傳不同的狀態碼，像查到東西就給 200，找不到就 404，新增成功給 201，程式自己錯了就給 500。

### Q2：HTTP 是無狀態的，那 Session 是怎麼實現的？
- Q：HTTP 是無狀態的，那 Session 是怎麼實現的？
- Session 是在伺服器端儲存客戶端狀態的一種方式。
- 為了讓伺服器「識別」是哪個客戶端的請求，通常會在客戶端和伺服器之間交換一個 Session ID。
- 常見做法是伺服器在使用者首次訪問或登入成功後，生成一個唯一的 Session ID，並將其透過 `Set-Cookie` Header 發送給客戶端。
- 客戶端（瀏覽器）收到後會將 Session ID 存儲在 Cookie 中。
- 之後客戶端每次發送請求給同一個網站時，都會自動在 `Cookie` Header 中帶上這個 Session ID。
- 伺服器收到請求後，根據 Cookie 中的 Session ID 找到對應的伺服器端 Session 數據，從而恢復客戶端的狀態。
- 🗣️口語化回答：雖然 HTTP 本身沒記憶，但我們可以用 Cookie 來記住使用者。伺服器給客戶端一個 Session ID 存在 Cookie 裡，之後客戶端每次來都帶著這個 ID，伺服器就知道是誰了。

---

# 四、Request / Response 結構與用途

## 重點摘要
深入了解 HTTP Request 和 Response 的詳細結構，特別是 Header 和 Body 的具體內容及其用途。這對於 API 開發、除錯、了解前後端溝通機制、甚至資安分析都非常關鍵。理解 Request 攜帶了什麼資訊給伺服器，以及 Response 又回傳了哪些資訊給客戶端，是全端工程師的必備知識。

## 定義
- Request 結構：
    - Start Line: Method URL HTTP/Version
    - Headers: 鍵值對，提供請求的元數據，如 `Host`, `User-Agent`, `Accept`, `Content-Type`, `Content-Length`, `Authorization`, `Cookie` 等。
    - Body: 攜帶 POST/PUT 等方法實際要提交的數據。
- Response 結構：
    - Start Line: HTTP/Version Status Code Reason Phrase
    - Headers: 鍵值對，提供回應的元數據，如 `Content-Type`, `Content-Length`, `Server`, `Set-Cookie`, `Cache-Control`, `Location` 等。
    - Body: 攜帶伺服器回傳的實際數據，如 HTML、JSON、圖片等。
- 用途：
    - Request：客戶端告知伺服器要做什麼 (Method)、對哪個資源做 (URI)、傳遞什麼數據 (Body)、以及關於客戶端或請求的其他資訊 (Headers)。
    - Response：伺服器告知客戶端請求處理的結果 (Status Code)、回傳的數據內容 (Body)、以及關於伺服器或回應的其他資訊 (Headers)。

## 常考觀念 Q&A

### Q1：Request Headers 中常見的 `Content-Type` 和 `Accept` 有什麼不同？
- `Content-Type` (在 Request Body 存在時使用)：告知伺服器 **請求體** 中的數據是什麼格式。例如：`application/json`, `application/x-www-form-urlencoded`。
- `Accept`：告知伺服器 **客戶端期望接收** 的回應數據是什麼格式。例如：`application/json`, `text/html`, `image/png`。伺服器會嘗試回傳客戶端可接受的格式。
- 🗣️口語化回答：`Content-Type` 是告訴伺服器「我給你的資料」是什麼格式，`Accept` 是告訴伺服器「我想要你給我的資料」是什麼格式。

### Q2：Response Headers 中 `Set-Cookie` 的用途是什麼？
- `Set-Cookie` 是伺服器在 Response Header 中發送給客戶端的一個指令。
- 用於指示客戶端（通常是瀏覽器）在本地儲存一個 Cookie。
- 儲存後，客戶端在之後發送給同一個網站的 Request 中，會自動在 `Cookie` Header 中帶上這個 Cookie。
- 常見用途是儲存 Session ID、使用者偏好設定等狀態資訊。
- 🗣️口語化回答：這是伺服器告訴你的瀏覽器「請幫我存一個 Cookie 起來」，這樣你下次來的時候瀏覽器就會把這個 Cookie 自動帶給我，我就知道你是誰了。

### Q3：Request Body 主要用於哪些 HTTP 方法？為什麼？
- 主要用於 POST, PUT, PATCH 方法。
- GET 和 HEAD 方法理論上也可以有 Body，但語義上不建議，且多數伺服器會忽略。
- 原因：POST, PUT, PATCH 用於向伺服器提交數據以建立或修改資源，這些數據通常較大或包含敏感資訊，不適合放在 URL 中傳輸，故放在 Body 中。
- 🗣️口語化回答：主要是 POST 和 PUT，因為這些方法是要送比較多或比較私密的資料給伺服器，放在 Body 裡比較適合。

## 重要語法或術語
- Request Header
- Response Header
- Request Body
- Response Body
- Content-Type
- Accept
- Authorization
- Cookie
- Set-Cookie
- User-Agent
- Referer
- Location
- Cache-Control

## 面試常見問法與回答

### Q1：你在開發中，如何從 HTTP Request 中取得前端傳來的 JSON 資料？
- Q：你在開發中，如何從 HTTP Request 中取得前端傳來的 JSON 資料？
- 確保前端在 Request Headers 中設置 `Content-Type: application/json`。
- 在後端程式中，讀取 Request Body 的內容。
- 使用 JSON 解析函式庫（如 Jackson, Gson）或框架提供的機制（如 Spring 的 `@RequestBody` 註解）。
- 將解析後的 JSON 數據映射到後端對應的 Java 物件（POJO）。
- 🗣️口語化回答：我會確保前端送資料時有說這是 JSON，然後在後端讀取它送過來的內容，用程式把 JSON 字串轉成我們可以用的物件。在 Spring Boot 裡用 `@RequestBody` 很方便。

### Q2：你在回傳 HTTP Response 給前端時，通常會設定哪些重要的 Header？
- Q：你在回傳 HTTP Response 給前端時，通常會設定哪些重要的 Header？
- `Content-Type`：指定回傳內容的格式，例如 `application/json` (最常用於 API) 或 `text/html`。
- `Content-Length`：指定回傳 Body 的大小（雖然框架通常會自動設定）。
- `Status Code`：這是 Status Line 的一部分，但非常關鍵，表示請求的處理結果。
- `Set-Cookie`：如果需要讓前端儲存 Cookie (如 Session ID或 Token)。
- `Cache-Control`：控制瀏覽器或代理伺服器如何快取這個回應。
- 🗣️口語化回答：一定會設 `Content-Type` 告訴前端資料是什麼格式，還有狀態碼（200, 404 之類的）。如果需要前端存 Cookie 或處理快取，也會設定相關的 Header。

---

# 五、資料正規化（Database Normalization）

## 重點摘要
資料正規化是關聯式資料庫設計中的一項重要技術，目標是透過分解表格、建立關聯，來減少資料冗餘（重複）、避免資料更新異常，並提升資料的一致性和完整性。理解正規化的概念和不同等級（1NF, 2NF, 3NF 等）有助於設計出結構良好、易於維護的資料庫。

## 定義
- 資料正規化：一個系統化的過程，用於設計關聯式資料庫的結構，以減少資料冗餘和提高資料完整性。
- 目的：
    - 減少資料的重複存儲。
    - 避免更新異常 (Insertion, Update, Deletion Anomaly)。
    - 提高資料的一致性。
    - 使資料庫結構更易於維護和修改。
- 更新異常：
    - 插入異常 (Insertion Anomaly)：無法在不輸入某個相關資訊的情況下插入新資料。
    - 更新異常 (Update Anomaly)：修改一個資料需要在多處進行，否則會導致不一致。
    - 刪除異常 (Deletion Anomaly)：刪除某個資料時，不小心刪除了其他不應被刪除的相關資訊。
- 正規形式 (Normal Forms, NF)：衡量資料庫表格正規化程度的標準，越高階的正規形式要求越嚴格。
    - **1NF (First Normal Form)**：每個表格必須有主鍵，每個欄位的值都必須是原子的（不可再分割）。
    - **2NF (Second Normal Form)**：滿足 1NF，且所有非主鍵欄位都必須完全依賴於主鍵（針對複合主鍵）。
    - **3NF (Third Normal Form)**：滿足 2NF，且所有非主鍵欄位不能透過其他非主鍵欄位來依賴主鍵（消除傳遞依賴）。
    - BCNF (Boyce-Codd Normal Form)：比 3NF 更嚴格的形式，處理主鍵的一部分依賴於其他欄位的情況。

## 常考觀念 Q&A

### Q1：什麼是資料正規化？它的主要目的是什麼？
- 資料正規化是一種設計資料庫表格結構的方法。
- 主要目的是減少資料重複（冗餘）和避免資料更新時發生的異常（插入、修改、刪除異常）。
- 確保資料的一致性和完整性。
- 🗣️口語化回答：就是把資料庫表格整理乾淨，減少重複放一樣的東西，讓資料更一致，修改或刪除時比較不會出錯。

### Q2：請用簡單的話說明 1NF, 2NF, 3NF 各是什麼？
- 1NF：表格裡的每個欄位值都不能再被分割了，而且要有個唯一識別這筆資料的主鍵。
- 2NF：符合 1NF，而且如果你的主鍵是好幾個欄位組成的（複合主鍵），那其他非主鍵的欄位都必須完全依賴這個複合主鍵，不能只依賴其中一部分。
- 3NF：符合 2NF，而且非主鍵欄位不能依賴於其他的非主鍵欄位。
- 🗣️口語化回答：1NF 就是欄位值不可分，要有主鍵；2NF 是非主鍵要完全依賴主鍵（對複合主鍵來說）；3NF 是非主鍵之間不能互相依賴。

### Q3：正規化有哪些優點和缺點？
- 優點：
    - 減少資料冗餘，節省存儲空間。
    - 提高資料一致性，修改資料時只需要改一處。
    - 避免更新異常，資料完整性更好。
    - 結構更清晰，易於維護和擴展。
- 缺點：
    - 查詢時可能需要 JOIN 更多的表格，增加查詢的複雜度和執行時間。
    - 有時為了高度正規化會拆分出很多小表格。
- 🗣️口語化回答：好處是資料比較乾淨、不容易出錯、省空間，也好維護。但缺點是查資料時可能會需要把很多小表格 JOIN 起來，比較慢。

### Q4：什麼是反正規化 (Denormalization)？為什麼會使用它？
- 反正規化是指在已正規化的資料庫中，為了提高讀取效能，有意地引入一些冗餘數據或將表格合併。
- 目的：減少查詢時所需的 JOIN 操作，加速資料檢索。
- 使用時機：當正規化導致的 JOIN 操作成為查詢效能瓶頸，且讀取效能比寫入效能更關鍵時。
- 🗣️口語化回答：反正規化就是犧牲一點正規化原則（比如放一些重複資料），讓表格不要拆那麼散，這樣查詢資料時就不用 JOIN 那麼多表，速度會變快。通常是在發現效能瓶頸時才用。

## 重要語法或術語
- Normalization (正規化)
- Denormalization (反正規化)
- Redundancy (冗餘)
- Data Integrity (資料完整性)
- Insertion Anomaly (插入異常)
- Update Anomaly (更新異常)
- Deletion Anomaly (刪除異常)
- Normal Form (NF)
- 1NF, 2NF, 3NF, BCNF
- Primary Key (主鍵)
- Foreign Key (外部鍵)
- Dependency (依賴)
- JOIN (資料庫操作)

## 面試常見問法與回答

### Q1：你在設計資料庫 Schema 時，通常會正規化到哪個程度？為什麼？
- Q：你在設計資料庫 Schema 時，通常會正規化到哪個程度？為什麼？
- 通常會設計到至少 3NF。
- 原因是 3NF 已經能夠消除大部分常見的更新異常和冗餘，提供一個結構清晰且資料完整性較好的基礎。
- BCNF 雖然更嚴格，但在大多數業務場景下，3NF 已足夠，且過度正規化可能導致 JOIN 過多影響效能。
- 如果後續發現特定查詢存在嚴重效能問題，可能會針對該部分考慮進行反正規化。
- 🗣️口語化回答：我通常會正規化到 3NF。這樣大部分資料重複和更新的問題都能避免了，基礎會比較好。如果真的遇到效能瓶頸，才會考慮為了查詢速度做一些反正規化。

### Q2：請舉例說明一個你需要正規化的場景，以及正規化後的表格結構。
- Q：請舉例說明一個你需要正規化的場景，以及正規化後的表格結構。
- 假設有一個訂單表格 `Orders`，一開始包含了訂單資訊和客戶資訊：`OrderID`, `OrderDate`, `CustomerID`, `CustomerName`, `CustomerAddress`, `ProductName`, `Quantity`, `Price`。
- 這個表格存在冗餘：同一個客戶的姓名和地址會重複出現在每筆訂單中。
- 存在更新異常：如果客戶地址變了，需要更新該客戶的所有訂單記錄；如果刪除一個客戶的所有訂單，客戶資訊也會遺失。
- 正規化：
    - 拆分成 `Customers` 表 (`CustomerID` (PK), `CustomerName`, `CustomerAddress`)。
    - `Orders` 表只保留訂單和商品資訊，並透過外部鍵關聯客戶表 (`OrderID` (PK), `OrderDate`, `CustomerID` (FK), `ProductName`, `Quantity`, `Price`)。
    - 如果多個商品在同一訂單，商品資訊可能仍冗餘，可以進一步拆分出 `OrderItems` 表和 `Products` 表來達到更高的正規化。
- 🗣️口語化回答：像訂單表，如果客戶資料跟訂單放一起，同個客戶買很多次，他的名字地址就重複很多遍。我會把它拆成「客戶表」和「訂單表」，訂單表只記錄是哪個客戶下的單，這樣客戶資料就只存一次。

---

# 六、SQL 常見語法與概念（SELECT、JOIN、WHERE、GROUP BY、子查詢等）

## 重點摘要
SQL (Structured Query Language) 是操作關聯式資料庫的標準語言。掌握核心的查詢語法（SELECT, FROM,