---
title: Java 全端考前小抄筆記
date: 2023-10-27T08:00:00.000Z
tags:
- Java
- 全端
- 筆記
- SQL
- 資料庫
- 正規化
- OOP
- 程式實作
- 垃圾回收
- Spring Boot
- 資安
- HTTP
- RESTful API
- JavaScript
categories:
- 程式開發
- 學習筆記
---

# 【Java 全端考前小抄筆記】

---

# 一、SQL 語法重點整理

## 常用語法與說明
請依照以下格式產出每一個語法說明：

### 📌 SELECT + WHERE + ORDER BY
- 用於查詢資料、條件過濾、排序結果

#### 範例：
sql
SELECT name, age FROM users WHERE age > 30 ORDER BY age DESC;


#### 解說：
- 查詢年齡大於 30 的使用者，並依年齡遞減排序
- `SELECT` 指定欄位、`WHERE` 過濾條件、`ORDER BY` 排序 (DESC 遞減, ASC 遞增，預設為 ASC)

---

### 📌 JOIN（INNER / LEFT / RIGHT / FULL）
- 用於合併來自兩個或多個表格的行，這些行是基於兩個表格之間的相關列。

#### 範例（INNER JOIN）：
sql
SELECT users.name, orders.id AS order_id
FROM users
INNER JOIN orders ON users.id = orders.user_id;


#### 解說：
- 查出有訂單的使用者姓名及其訂單編號。
- `INNER JOIN` 只保留雙方表格皆有對應資料的紀錄。

#### 範例（LEFT JOIN）：
sql
SELECT users.name, orders.id AS order_id
FROM users
LEFT JOIN orders ON users.id = orders.user_id;


#### 解說：
- 查出所有使用者及其訂單編號，即使使用者沒有訂單（訂單 ID 會顯示 NULL）。
- `LEFT JOIN` 保留左邊表格 (users) 的所有紀錄，並匹配右邊表格 (orders) 的紀錄。

---

### 📌 GROUP BY + HAVING
- `GROUP BY` 用於根據一個或多個欄位將結果集分組。
- `HAVING` 用於篩選分組後的結果集（類似 WHERE，但作用於分組）。

#### 範例：
sql
SELECT department_id, COUNT(*) AS employee_count
FROM employees
GROUP BY department_id
HAVING COUNT(*) > 10;


#### 解說：
- 統計每個部門的員工數量。
- `GROUP BY department_id` 將員工按部門分組。
- `COUNT(*)` 計算每個組的員工數量。
- `HAVING COUNT(*) > 10` 過濾出員工數量大於 10 的部門。

---

### 📌 LIMIT / OFFSET
- `LIMIT` 用於限制結果集返回的行數。
- `OFFSET` 用於跳過指定數量的行，通常與 LIMIT 一起用於分頁。

#### 範例：
sql
SELECT name, age FROM users ORDER BY age LIMIT 10 OFFSET 20;


#### 解說：
- 查詢依年齡排序後，跳過前 20 行，並取出接下來的 10 行資料。
- 常見於實作分頁功能。

---

### 📌 子查詢（Subquery）
- 一個嵌套在另一個 SQL 查詢語句中的查詢，可以出現在 WHERE, FROM, 或 SELECT 子句中。

#### 範例（WHERE 子查詢）：
sql
SELECT name, age
FROM users
WHERE department_id IN (SELECT id FROM departments WHERE name = 'Sales');


#### 解說：
- 找出所有在 'Sales' 部門的員工。
- 子查詢 `SELECT id FROM departments WHERE name = 'Sales'` 先找出 'Sales' 部門的 ID。
- 外層查詢再利用這個 ID 列表 (`IN (...)`) 過濾員工表格。

#### 範例（FROM 子查詢 / 衍生表格）：
sql
SELECT department_name, employee_count
FROM (
    SELECT department_id, COUNT(*) AS employee_count
    FROM employees
    GROUP BY department_id
) AS department_summary
JOIN departments ON department_summary.department_id = departments.id;


#### 解說：
- 先通過子查詢計算每個部門的員工數，將子查詢結果視為一個臨時表格 `department_summary`。
- 再將這個臨時表格與 `departments` 表格 JOIN，獲取部門名稱，最終顯示每個部門的名稱和員工數量。

---

### 📌 聚合函數（COUNT(), AVG(), SUM(), MAX(), MIN()）
- 用於對一組值執行計算並返回單個值，常與 `GROUP BY` 一起使用。

#### 範例：
sql
SELECT COUNT(*) AS total_employees, AVG(salary) AS average_salary, MAX(salary) AS max_salary
FROM employees WHERE department_id = 1;


#### 解說：
- 計算部門 ID 為 1 的員工總數、平均薪資和最高薪資。
- `COUNT(*)` 計算行數、`AVG()` 計算平均值、`MAX()` 計算最大值。`SUM()` 計算總和、`MIN()` 計算最小值。

---

### 📌 資料更新/刪除語法（UPDATE, DELETE）
- `UPDATE` 用於修改表格中現有的記錄。
- `DELETE` 用於刪除表格中的現有記錄。

#### 範例（UPDATE）：
sql
UPDATE users SET email = 'new.email@example.com' WHERE id = 10;


#### 解說：
- 將使用者 ID 為 10 的記錄的電子郵件更新為 'new.email@example.com'。
- `SET` 指定要修改的欄位和新值。
- `WHERE` 指定要更新哪些記錄（**重要：缺少 WHERE 子句會更新整個表格！**）。

#### 範例（DELETE）：
sql
DELETE FROM users WHERE status = 'inactive';


#### 解說：
- 刪除所有狀態為 'inactive' 的使用者記錄。
- `FROM` 指定要刪除的表格。
- `WHERE` 指定要刪除哪些記錄（**重要：缺少 WHERE 子句會刪除整個表格的所有數據！**）。

---

# 二、資料庫設計與正規化

## 重點摘要
資料正規化是關聯式資料庫設計中的一項重要技術，目標是透過分解表格、建立關聯，來減少資料冗餘（重複）、避免資料更新異常，並提升資料的一致性和完整性。理解正規化的概念和不同等級（1NF, 2NF, 3NF 等）有助於設計出結構良好、易於維護的資料庫。

## 定義
- 資料正規化：一個系統化的過程，用於設計關聯式資料庫的結構，以減少資料冗餘和提高資料完整性。
- 目的：
    - 減少資料的重複存儲。
    - 避免更新異常 (Insertion, Update, Deletion Anomaly)。
    - 提高資料的一致性。
    - 使資料庫結構更易於維護和修改。
- 更新異常：
    - 插入異常 (Insertion Anomaly)：無法在不輸入某個相關資訊的情況下插入新資料。
    - 更新異常 (Update Anomaly)：修改一個資料需要在多處進行，否則會導致不一致。
    - 刪除異常 (Deletion Anomaly)：刪除某個資料時，不小心刪除了其他不應被刪除的相關資訊。
- 正規形式 (Normal Forms, NF)：衡量資料庫表格正規化程度的標準，越高階的正規形式要求越嚴格。
    - **1NF (First Normal Form)**：每個表格必須有主鍵，每個欄位的值都必須是原子的（不可再分割）。
    - **2NF (Second Normal Form)**：滿足 1NF，且所有非主鍵欄位都必須完全依賴於主鍵（針對複合主鍵）。
    - **3NF (Third Normal Form)**：滿足 2NF，且所有非主鍵欄位不能透過其他非主鍵欄位來依賴主鍵（消除傳遞依賴）。
    - BCNF (Boyce-Codd Normal Form)：比 3NF 更嚴格的形式，處理主鍵的一部分依賴於其他欄位的情況。

## 常考觀念 Q&A

### Q1：什麼是資料正規化？它的主要目的是什麼？
- 資料正規化是一種設計資料庫表格結構的方法。
- 主要目的是減少資料重複（冗餘）和避免資料更新時發生的異常（插入、修改、刪除異常）。
- 確保資料的一致性和完整性。
- 🗣️口語化回答：就是把資料庫表格整理乾淨，減少重複放一樣的東西，讓資料更一致，修改或刪除時比較不會出錯。

### Q2：請用簡單的話說明 1NF, 2NF, 3NF 各是什麼？
- 1NF：表格裡的每個欄位值都不能再被分割了，而且要有個唯一識別這筆資料的主鍵。
- 2NF：符合 1NF，而且如果你的主鍵是好幾個欄位組成的（複合主鍵），那其他非主鍵的欄位都必須完全依賴這個複合主鍵，不能只依賴其中一部分。
- 3NF：符合 2NF，而且非主鍵欄位不能依賴於其他的非主鍵欄位。
- 🗣️口語化回答：1NF 就是欄位值不可分，要有主鍵；2NF 是非主鍵要完全依賴主鍵（對複合主鍵來說）；3NF 是非主鍵之間不能互相依賴。

### Q3：正規化有哪些優點和缺點？
- 優點：
    - 減少資料冗餘，節省存儲空間。
    - 提高資料一致性，修改資料時只需要改一處。
    - 避免更新異常，資料完整性更好。
    - 結構更清晰，易於維護和擴展。
- 缺點：
    - 查詢時可能需要 JOIN 更多的表格，增加查詢的複雜度和執行時間。
    - 有時為了高度正規化會拆分出很多小表格。
- 🗣️口語化回答：好處是資料比較乾淨、不容易出錯、省空間，也好維護。但缺點是查資料時可能會需要把很多小表格 JOIN 起來，比較慢。

### Q4：什麼是反正規化 (Denormalization)？為什麼會使用它？
- 反正規化是指在已正規化的資料庫中，為了提高讀取效能，有意地引入一些冗餘數據或將表格合併。
- 目的：減少查詢時所需的 JOIN 操作，加速資料檢索。
- 使用時機：當正規化導致的 JOIN 操作成為查詢效能瓶頸，且讀取效能比寫入效能更關鍵時。
- 🗣️口語化回答：反正規化就是犧牲一點正規化原則（比如放一些重複資料），讓表格不要拆那麼散，這樣查詢資料時就不用 JOIN 那麼多表，速度會變快。通常是在發現效能瓶頸時才用。

## 資料表關聯設計情境（如訂單與會員）
- **會員 (Customers)** 與 **訂單 (Orders)** 的關聯：通常是 一對多 (One-to-Many)。一個會員可以有多個訂單，一個訂單只屬於一個會員。
    - 設計：在 `Orders` 表格中增加一個外部鍵 `CustomerID`，指向 `Customers` 表格的主鍵 `CustomerID`。
- **訂單 (Orders)** 與 **商品 (Products)** 的關聯：通常是 多對多 (Many-to-Many)。一個訂單可以包含多個商品，一個商品可以出現在多個訂單中。
    - 設計：需要一個 中介表格 (Junction Table) 來解決多對多關係，例如 `OrderItems` (或稱為 `OrderDetail`) 表格。
    - `OrderItems` 表格通常包含 `OrderID` (外部鍵指向 `Orders`) 和 `ProductID` (外部鍵指向 `Products`) 作為複合主鍵，以及 `Quantity`, `Price` 等欄位。
- **主鍵 (Primary Key)**：唯一識別表格中每一行的欄位或欄位組合，值不能為 NULL。
- **外部鍵 (Foreign Key)**：表格中的一個欄位，其值對應到另一個表格的主鍵。用於建立表格之間的關聯，維護資料的參照完整性。
- **欄位命名慣例**：通常使用小寫字母和底線 (`snake_case`) 或駝峰式命名 (`camelCase`)。主鍵常用 `id` 或 `tablename_id`。外部鍵常用 `referenced_table_id`。
- **資料一致性**：確保資料庫中的資料在所有相關表格中保持準確和同步。正規化和外部鍵約束 (Foreign Key Constraints) 是維護資料一致性的重要手段。

---

# 三、Java 核心觀念速讀與 Q&A（OOP + 其他）

## OOP 四大特性簡述
- **封裝 (Encapsulation)**：將數據（屬性）和操作數據的方法捆綁在一個單元（類別）中，並對外部隱藏內部實現細節，通過公共方法提供受控的訪問。
- **繼承 (Inheritance)**：允許一個類別（子類別）繼承另一個類別（父類別）的屬性和方法，實現程式碼重用。Java 支持單一繼承類別。
- **多型 (Polymorphism)**：指允許不同類型的物件對同一個方法呼叫作出不同的響應。主要體現在方法重載 (Overloading) 和方法覆寫 (Overriding)。
- **抽象 (Abstraction)**：隱藏複雜的實現細節，只展示必要的資訊給使用者。通過抽象類別和介面實現。

## 補充觀念 Q&A

### Q1：介面 (Interface) vs 抽象類別 (Abstract Class) 有什麼區別？
- **介面 (Interface)**：定義了一組方法的「契約」或「規格」，不包含具體實作（Java 8+ 可有 default/static 方法）。類別可以實作 (implement) 多個介面。主要用於定義行為規範、實現多重繼承的「類比」。
- **抽象類別 (Abstract Class)**：可以包含抽象方法（無實作）和具體方法（有實作）。不能直接實例化，只能被繼承 (extend)。類別只能繼承單一抽象類別。主要用於定義共同的基礎結構或部分實作，供子類別完善。
- 🗣️口語化回答：Interface 就像一份合約，只規定要做什麼，一個類別可以簽好幾份。Abstract Class 就像半成品，有些做好了有些沒做，一個類別只能繼承一份。

### Q2：請說明 `static`, `final`, `this`, `super` 的作用。
- `static`：
    - 用於成員變數：變數屬於類別本身，而非類別的任何特定物件。所有物件共享同一個 `static` 變數。
    - 用於方法：方法屬於類別本身，可以直接通過類別名稱呼叫，無需創建物件。`static` 方法只能訪問 `static` 成員。
    - 用於區塊 (`static {}`)：在類別載入時執行，用於初始化 `static` 成員。
- `final`：
    - 用於變數：變數的值一旦被賦予後不能再修改（常量）。對於引用類型，`final` 只保證引用本身不變，不保證物件內容不變。
    - 用於方法：方法不能被子類別覆寫 (Override)。
    - 用於類別：類別不能被繼承。
- `this`：
    - 在方法或建構子內部，指代當前物件的引用。
    - 可以用於區分成員變數和同名的局部變數（`this.memberVariable = localVariable;`）。
    - 可以用於在一個建構子中呼叫同一個類別的另一個建構子（`this(...)`）。
- `super`：
    - 在子類別中，指代父類別的引用。
    - 可以用於訪問父類別的成員變數或方法，即使子類別有同名的成員（`super.method()`）。
    - 可以用於在子類別的建構子中呼叫父類別的建構子（`super(...)`）。

### Q3：請說明物件導向（OOP）的三大特性：封裝、繼承、多型。(重複使用者提供內容，在此保留並精簡)
- **封裝**：資料和方法綁定，隱藏內部細節，通過公開方法控制訪問。
- **繼承**：子類別繼承父類別屬性與方法，程式碼重用。
- **多型**：同一個方法呼叫，因物件類型不同而有不同行為 (重載/覆寫)。

### Q4：Java 中的方法重載 (Overloading) 和方法覆寫 (Overriding) 有什麼區別？(重複使用者提供內容，在此保留並精簡)
- **重載 (Overloading)**：同類別內，方法名同，參數列表不同。編譯時決定。
- **覆寫 (Overriding)**：父子類別間，方法簽名完全相同，子類別提供不同實作。執行時決定。

### Q5：Primitive types (基本資料類型) 和 Reference types (引用資料類型) 有什麼區別？(重複使用者提供內容，在此保留並精簡)
- **基本類型**：直接存值 (`int`, `boolean` 等)，固定大小。
- **引用類型**：存物件的記憶體地址 (`String`, 物件等)，需要通過引用訪問實際物件。

## 記憶體管理與 Garbage Collection（GC）
- Java 通過垃圾回收機制自動管理 Heap 記憶體。
- 程式員無需手動分配和釋放物件記憶體。
- GC 會自動識別不再被引用的物件並回收其佔用的記憶體。
- 詳情請參考後續的「Java 垃圾回收」章節。

---

# 四、Java 筆試程式實作題

## 請依照以下格式整理每一題：

---

### 題目：判斷質數

#### 📋 題目說明：
請寫一個 Java 程式，輸入一個整數，判斷是否為質數（只能被 1 和自己整除的正整數，2 是最小質數）。

#### 📥 範例輸入：

輸入：7


#### 📤 預期輸出：

7 是質數


#### ✅ Java 解答：
java
import java.util.Scanner;

public class PrimeChecker {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("請輸入數字："); // 為了更好使用者體驗增加提示
        int num = scanner.nextInt();
        boolean isPrime = true;

        if (num <= 1) {
            isPrime = false;
        } else if (num == 2) {
            isPrime = true;
        } else if (num % 2 == 0) { // 排除所有大於2的偶數
            isPrime = false;
        }
        else {
            // 只檢查奇數因數，到平方根即可
            for (int i = 3; i * i <= num; i += 2) {
                if (num % i == 0) {
                    isPrime = false;
                    break;
                }
            }
        }

        System.out.println(num + (isPrime ? " 是質數" : " 不是質數"));
        scanner.close(); // 記得關閉資源
    }
}


#### 📌 重點解析：
- 使用 `Scanner` 讀取輸入。
- 根據質數定義，先處理 `num <= 1` 和 `num == 2` 的情況。
- 排除所有大於 2 的偶數，優化檢查範圍。
- 迴圈從 3 開始，每次增加 2 (`i += 2`)，只檢查奇數因數。
- 迴圈條件使用 `i * i <= num` (等價於 `i <= Math.sqrt(num)`) 提高效率，避免不必要的檢查。
- 使用 `break` 在找到第一個因數時立即終止迴圈。
- `boolean isPrime` 作為旗標控制結果。
- 使用三元運算符 `(isPrime ? " 是質數" : " 不是質數")` 簡潔輸出。

---

### 題目：印出直角三角形（靠左下）

#### 📋 題目說明：
請寫一個 Java 程式，根據輸入的行數 `n`，印出一個靠左下對齊的直角三角形。

#### 📥 範例輸入：

輸入行數：5


#### 📤 預期輸出：

*
**
***
****
*****


#### ✅ Java 解答：
java
import java.util.Scanner;

public class LeftTriangle {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("輸入行數：");
        int n = scanner.nextInt();

        if (n <= 0) {
            System.out.println("行數必須是正整數。");
        } else {
            // 外層迴圈控制行數
            for (int i = 1; i <= n; i++) {
                // 內層迴圈控制每行印出的星號數量，數量等於當前行數 i
                for (int j = 1; j <= i; j++) {
                    System.out.print("*");
                }
                // 每行結束後換行
                System.out.println();
            }
        }
        scanner.close();
    }
}


#### 📌 重點解析：
- 使用巢狀迴圈。
- 外層迴圈控制行數 `i` (1 到 n)。
- 內層迴圈控制每行印出的字元。對於靠左下三角形，每行的星號數量等於當前行號 `i`。
- `System.out.print("*")` 印出星號但不換行。
- 外層迴圈每次迭代結束後，使用 `System.out.println()` 進行換行。

---

### 題目：印出直角三角形（靠右下）

#### 📋 題目說明：
請寫一個 Java 程式，根據輸入的行數 `n`，印出一個靠右下對齊的直角三角形。

#### 📥 範例輸入：

輸入行數：5


#### 📤 預期輸出：

    *
   **
  ***
 ****
*****


#### ✅ Java 解答：
java
import java.util.Scanner;

public class RightTriangle {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("輸入行數：");
        int n = scanner.nextInt();

        if (n <= 0) {
            System.out.println("行數必須是正整數。");
        } else {
            // 外層迴圈控制行數
            for (int i = 1; i <= n; i++) {
                // 內層迴圈印出空格：第 i 行需要印出 n - i 個空格
                for (int j = 1; j <= n - i; j++) {
                    System.out.print(" ");
                }
                // 內層迴圈印出星號：第 i 行需要印出 i 個星號
                for (int k = 1; k <= i; k++) {
                    System.out.print("*");
                }
                // 每行結束後換行
                System.out.println();
            }
        }
        scanner.close();
    }
}


#### 📌 重點解析：
- 使用巢狀迴圈，外層控制行數。
- 每行包含兩部分：先印出空格，再印出星號。
- 第 `i` 行需要印出 `n - i` 個空格（例如，第 1 行需要 `n-1` 個空格，第 n 行需要 0 個空格）。
- 第 `i` 行需要印出 `i` 個星號。
- 兩個內層迴圈分別負責印出空格和星號。
- 每行結束後換行。

---

### 題目：印出直角三角形（等腰）

#### 📋 題目說明：
請寫一個 Java 程式，根據輸入的行數 `n`，印出一個等腰三角形（尖端向上）。

#### 📥 範例輸入：

輸入行數：5


#### 📤 預期輸出：

    *
   ***
  *****
 *******
*********


#### ✅ Java 解答：
java
import java.util.Scanner;

public class IsoscelesTriangle {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("輸入行數：");
        int n = scanner.nextInt();

        if (n <= 0) {
            System.out.println("行數必須是正整數。");
        } else {
            // 外層迴圈控制行數
            for (int i = 1; i <= n; i++) {
                // 內層迴圈印出空格：第 i 行需要印出 n - i 個空格
                for (int j = 1; j <= n - i; j++) {
                    System.out.print(" ");
                }
                // 內層迴圈印出星號：第 i 行需要印出 2*i - 1 個星號
                for (int k = 1; k <= 2 * i - 1; k++) {
                    System.out.print("*");
                }
                // 每行結束後換行
                System.out.println();
            }
        }
        scanner.close();
    }
}


#### 📌 重點解析：
- 使用巢狀迴圈，外層控制行數。
- 每行包含兩部分：先印出空格，再印出星號。
- 第 `i` 行需要印出 `n - i` 個空格。
- 等腰三角形的星號數量呈現規律：第 1 行 1 個 (`2*1 - 1`)，第 2 行 3 個 (`2*2 - 1`)，第 `i` 行 `2*i - 1` 個星號。
- 兩個內層迴圈分別負責印出空格和星號。
- 每行結束後換行。

---

### 題目：九九乘法表（排版整齊）

#### 📋 題目說明：
請寫一個 Java 程式，印出一個標準的九九乘法表，並排版整齊。

#### 預期輸出：

1 * 1 =  1   1 * 2 =  2   ... 1 * 9 =  9
2 * 1 =  2   2 * 2 =  4   ... 2 * 9 = 18
...
9 * 1 =  9   9 * 2 = 18   ... 9 * 9 = 81


#### ✅ Java 解答：
java
public class MultiplicationTable {
    public static void main(String[] args) {
        // 外層迴圈控制被乘數
        for (int i = 1; i <= 9; i++) {
            // 內層迴圈控制乘數
            for (int j = 1; j <= 9; j++) {
                // 使用 printf 格式化輸出
                // %d 是整數
                // %2d 表示數字至少佔用 2 個字元寬度並右對齊
                System.out.printf("%d * %d = %2d   ", i, j, i * j);
            }
            // 每行結束換行
            System.out.println();
        }
    }
}


#### 📌 重點解析：
- 使用巢狀迴圈，外層控制被乘數 `i` (1-9)，內層控制乘數 `j` (1-9)。
- 核心在於使用 `System.out.printf()` 進行格式化輸出。
- `%d * %d = %2d` 是格式字串，`%d` 會被後續的整數參數替換。
- `%2d` 會將整數以至少 2 個字元的寬度印出，不足兩位時會在前面補空格，實現乘積的右對齊，使表格整齊。
- `   ` 在每個乘法項後添加固定空格進行分隔。
- 內層迴圈結束後使用 `System.out.println()` 換行。

---

### 題目：印出前 N 個費式數列

#### 📋 題目說明：
請寫一個 Java 程式，輸入一個正整數 N，印出費式數列的前 N 個數字 (從 0, 1 開始)。

#### 📥 範例輸入：

輸入項數：10


#### 📤 預期輸出：

費式數列的前 10 項：0, 1, 1, 2, 3, 5, 8, 13, 21, 34


#### ✅ Java 解答：
java
import java.util.Scanner;

public class FibonacciSequence {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("輸入項數：");
        int n = scanner.nextInt();

        if (n <= 0) {
            System.out.println("項數必須是正整數。");
        } else {
            System.out.print("費式數列的前 " + n + " 項：");
            long num1 = 0, num2 = 1;

            if (n >= 1) {
                System.out.print(num1);
            }
            if (n >= 2) {
                System.out.print(", " + num2);
            }

            for (int i = 3; i <= n; i++) {
                long nextNum = num1 + num2;
                System.out.print(", " + nextNum);
                num1 = num2;
                num2 = nextNum;
            }
            System.out.println(); // 最後換行
        }
        scanner.close();
    }
}


#### 📌 重點解析：
- 費式數列從 0, 1 開始。需要維護兩個變數來儲存當前計算所需的「前兩項」。
- 初始化 `num1 = 0`, `num2 = 1`。
- 單獨處理 N=1 和 N=2 的情況。
- 對於 N > 2，使用迴圈從第三項開始計算到第 N 項。
- 在迴圈中，計算 `nextNum = num1 + num2`。
- 然後更新 `num1` 為原來的 `num2`，`num2` 為剛計算出的 `nextNum`。
- 每次計算後印出 `nextNum`，注意印出格式（逗號和空格）。
- 使用 `long` 型別避免數列增長過快導致 `int` 溢位。
- **比較：遞歸解法雖然直觀，但存在大量重複計算，效率極低，面試中通常期望迭代解法。**

---

### 題目：回文判斷（isPalindrome）

#### 📋 題目說明：
請寫一個 Java 程式，判斷輸入的一個字串是否為回文（正反讀都一樣）。

#### 📥 範例輸入：

輸入字串：level


#### 📤 預期輸出：

"level" 是回文字串


#### ✅ Java 解答：
java
import java.util.Scanner;

public class PalindromeChecker {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("輸入字串：");
        String inputString = scanner.nextLine();

        boolean isPalindrome = true;
        int length = inputString.length();

        // 使用雙指標或單指標遍歷前半部分與後半部分對應字元
        for (int i = 0; i < length / 2; i++) {
            // 比較從開頭算起第 i 個字元 和 從結尾算起第 i 個字元 (索引 length - 1 - i)
            if (inputString.charAt(i) != inputString.charAt(length - 1 - i)) {
                isPalindrome = false; // 發現不同，不是回文
                break; // 提前結束
            }
        }

        System.out.println("\"" + inputString + "\"" + (isPalindrome ? " 是回文字串" : " 不是回文字串"));
        scanner.close();
    }
}


#### 📌 重點解析：
- 回文的特徵是從兩端向中間對稱。
- 只需要比較字串的前半部分和後半部分對應位置的字元。
- 使用 `for` 迴圈，從索引 0 遍歷到 `length / 2 - 1` (即 `< length / 2`)。
- 在迴圈內，比較 `inputString.charAt(i)` 和 `inputString.charAt(length - 1 - i)`。`length - 1` 是最後一個字元的索引。
- 一旦發現任何一對對應字元不相同，即可確定不是回文，設置 `isPalindrome` 為 `false` 並 `break`。
- 如果迴圈正常結束，說明是回文。
- **注意：** 如果需要忽略大小寫和非字母字元，需要先對輸入字串進行預處理 (轉換為小寫，移除標點空格)。

---

### 題目：陣列最大值與最小值

#### 📋 題目說明：
請寫一個 Java 程式，找出一個整數陣列中的最大值和最小值。

#### 📥 範例輸入：

陣列: [12, 45, 6, 89, 23, 5, 90]


#### 📤 預期輸出：

陣列中的最大值是：90
陣列中的最小值是：5


#### ✅ Java 解答：
java
import java.util.Arrays; // 用於印出陣列

public class FindMinMax {
    public static void main(String[] args) {
        int[] numbers = {12, 45, 6, 89, 23, 5, 90};

        if (numbers == null || numbers.length == 0) {
            System.out.println("陣列為空。");
            return;
        }

        int max = numbers[0]; // 假設第一個元素是最大值
        int min = numbers[0]; // 假設第一個元素是最小值

        // 從第二個元素開始遍歷
        for (int i = 1; i <