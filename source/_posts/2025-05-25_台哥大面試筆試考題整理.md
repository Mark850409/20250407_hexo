好的，這是一份針對 Java 全端工程師面試設計的總複習筆記，內容涵蓋您指定的 9 個主題，並遵循指定的 Markdown 結構與撰寫要求。

---

# 一、資安（Web Security）

## 重點摘要
網頁資安是開發全端應用程式不可或缺的一環。了解常見的 Web 漏洞與攻擊手法，並知道如何在開發過程中採取防護措施，能有效保護使用者資料與系統穩定性。這包括了解 OWASP Top 10 等標準，並在前後端實作安全考量。

## 定義
- Web 資安：保護網站、Web 應用程式及其使用者免受網路威脅的實踐。
- 常見威脅：SQL Injection, XSS (Cross-Site Scripting), CSRF (Cross-Site Request Forgery), Broken Authentication 等。
- 防護策略：輸入驗證、輸出編碼、參數化查詢、使用 HTTPS、安全Session管理、權限控管等。

## 常考觀念 Q&A

### Q1：什麼是 SQL Injection 攻擊？
- 攻擊者將惡意 SQL 程式碼注入到應用程式的查詢語句中。
- 利用未經適當驗證的使用者輸入來操縱資料庫查詢。
- 可能導致資料洩露、修改或刪除。
- 🗣️口語化回答：就是駭客透過輸入框，把惡意指令塞進資料庫查詢裡，偷看或改資料。

### Q2：請說明 XSS (Cross-Site Scripting) 攻擊？
- 攻擊者將惡意腳本（通常是 JavaScript）注入到網頁中。
- 當其他使用者瀏覽該網頁時，惡意腳本會在他們的瀏覽器上執行。
- 可用於竊取 Session Cookies、劫持使用者 Session 或重新導向到惡意網站。
- 🗣️口語化回答：簡單說就是駭客在網頁裡藏一段壞壞的程式碼，別人一開網頁，程式碼就在他瀏覽器裡跑，可能資料就被偷了。

### Q3：HTTPS 比 HTTP 安全在哪裡？
- HTTPS 使用 SSL/TLS 加密協議在客戶端和伺服器之間傳輸資料。
- 確保資料傳輸的機密性（不易被竊聽）。
- 提供資料完整性（資料在傳輸過程中未被篡改）。
- 通常也包含伺服器身份驗證，確保你連接的是正確的網站。
- 🗣️口語化回答：HTTPS 就像 HTTP 加上一道鎖，傳輸的資料是加密的，不容易被偷看或修改。

## 重要語法或術語
- OWASP Top 10
- SQL Injection
- XSS (Cross-Site Scripting)
- CSRF (Cross-Site Request Forgery)
- HTTPS / SSL / TLS
- Session Hijacking
- Input Validation
- Output Encoding

## 面試常見問法與回答

### Q1：你在開發中會如何考慮資安問題？
- 會注意使用者輸入，進行適當的驗證和過濾，避免 SQL Injection 和 XSS。
- 傳輸敏感資料時，確保使用 HTTPS。
- 對使用者密碼等敏感資料進行加密儲存，而不是明文。
- 🗣️口語化回答：主要就是檢查使用者輸入、該加密的資料加密、該用 HTTPS 就用，避免一些基本的漏洞。

### Q2：你們專案有遇過資安相關的挑戰或考量嗎？
- 我們有針對特定 API 實作 Rate Limiting，防止惡意程式進行大量請求或猜測。
- 使用 Spring Security 等框架進行身份驗證和授權管理，確保只有合法用戶能存取特定資源。
- 定期掃描第三方函式庫的已知漏洞。
- 🗣️口語化回答：我們有用框架處理權限問題，也做了一些像限制訪問頻率的防護，確保系統不會被亂來。

# 二、RESTful API

## 重點摘要
RESTful API 是一種設計風格，它利用 HTTP 協定來建立 Web 服務。其核心在於將系統資源化，並透過標準的 HTTP 方法（GET, POST, PUT, DELETE）對資源進行操作。這種設計風格讓 API 具備高可讀性、易於理解和維護，是目前主流的後端 API 設計方式。

## 定義
- REST (Representational State Transfer)：一種軟體架構風格，而非標準。
- RESTful API：遵循 REST 風格設計的 Web API。
- 核心原則：資源導向（Resources）、統一介面（HTTP Methods）、無狀態（Stateless）、可快取（Cacheable）、分層系統（Layered System）等。
- 資源 (Resource)：URI (Uniform Resource Identifier) 表示的任何事物，如使用者、訂單。

## 常考觀念 Q&A

### Q1：什麼是 RESTful API？
- 它是一種設計 API 的風格，基於 HTTP 協定。
- 將後台的功能抽象成資源，透過 URI 來識別這些資源。
- 使用 HTTP 方法（GET, POST, PUT, DELETE）來表示對資源的操作。
- 🗣️口語化回答：就是一種比較標準、有規矩的方法來設計後端服務，讓網頁或 App 可以方便地跟後端互動。

### Q2：RESTful API 強調「無狀態」(Stateless) 是什麼意思？
- 指的是伺服器不會保留客戶端任何 Session 狀態資訊。
- 每次客戶端發送請求時，都必須包含伺服器處理該請求所需的所有資訊。
- 好處是伺服器更容易擴展（水平擴展），且服務更可靠。
- 🗣️口語化回答：服務器不會記得你之前做了什麼，每次你呼叫它，你都要把需要的資訊都給它，這樣伺服器比較輕鬆、也比較容易擴充。

### Q3：在 RESTful 設計中，什麼時候用 POST？什麼時候用 PUT？
- POST 通常用於「新建」資源，且可能是非冪等（多次請求結果不同）。例如：創建一篇新的部落格文章。
- PUT 通常用於「更新」或「替換」一個已存在的資源，且是冪等（多次請求結果相同）。例如：更新某個特定使用者的資料。
- 🗣️口語化回答：簡單說，POST 通常是新增東西，PUT 通常是更新某個已經有的東西。

## 重要語法或術語
- URI (Uniform Resource Identifier)
- Resource (資源)
- HTTP Methods (GET, POST, PUT, DELETE)
- Stateless (無狀態)
- Idempotent (冪等性)
- HATEOAS (Hypermedia as the Engine of Application State)
- JSON / XML

## 面試常見問法與回答

### Q1：請描述你在專案中如何設計和實作 RESTful API？
- 會先定義好資源（例如：/users, /products），並規劃好對應的 URI。
- 根據操作選擇合適的 HTTP 方法（GET 取資料、POST 新增、PUT 更新、DELETE 刪除）。
- 使用 Spring Boot 這類框架快速建立控制器 (`@RestController`) 來處理請求，並回傳 JSON 格式的資料。
- 🗣️口語化回答：我會先想好要提供哪些資料或功能（資源），然後用像 Spring Boot 這種框架，把每個資源對應到不同的網址和操作（GET, POST 那些）。

### Q2：你設計一個 API，如果客戶端發送了無效資料，你會如何回傳？
- 會回傳一個適當的 HTTP 狀態碼，例如 400 Bad Request。
- 在 Response Body 中提供更詳細的錯誤資訊，說明是哪個欄位有問題以及錯誤原因，方便客戶端修正。
- 🗣️口語化回答：我會給他一個像 400 這樣的錯誤碼，然後在訊息裡告訴他哪裡填錯了，讓他知道怎麼改。

# 三、HTTP 基本結構與方法

## 重點摘要
HTTP（超文本傳輸協定）是 Web 瀏覽器與伺服器溝通的基礎。了解 HTTP 的請求（Request）與回應（Response）結構，以及不同的請求方法（GET, POST 等）的用途，是理解前後端互動、RESTful API 設計的關鍵。

## 定義
- HTTP (Hypertext Transfer Protocol)：用於在網頁瀏覽器和伺服器之間傳輸超文本的應用層協定。
- 工作模式：客戶端（Client）發送請求（Request），伺服器（Server）回傳回應（Response）。
- 無狀態協定：伺服器不保留先前請求的狀態資訊。
- 常見方法：GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS。

## 常考觀念 Q&A

### Q1：HTTP GET 方法和 POST 方法的主要區別是什麼？
- GET：用於向伺服器「取得」資源。請求參數通常附加在 URL 後面（Query String）。
- POST：用於向伺服器「提交」資料以「處理」或「創建」資源。請求參數放在 Request Body 中。
- 安全性：GET 參數暴露在 URL 中，不適合傳輸敏感資料；POST 參數在 Body 中相對隱蔽。
- 冪等性：GET 通常是冪等的（重複發送多次不會改變伺服器狀態）；POST 通常是非冪等的。
- 🗣️口語化回答：GET 是去拿資料，參數會顯示在網址上；POST 是送資料給伺服器處理或新增，參數藏在看不到的地方。

### Q2：什麼是 HTTP 狀態碼？常見的狀態碼有哪些？
- 狀態碼是伺服器在回應中回傳的三位數字，表示請求的處理結果。
- 常見類別：
    - 1xx (Information): 收到請求，繼續處理。
    - 2xx (Success): 請求成功 (e.g., 200 OK, 201 Created)。
    - 3xx (Redirection): 需要進一步操作才能完成請求 (e.g., 301 Moved Permanently)。
    - 4xx (Client Error): 客戶端錯誤 (e.g., 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found)。
    - 5xx (Server Error): 伺服器錯誤 (e.g., 500 Internal Server Error, 502 Bad Gateway)。
- 🗣️口語化回答：就是伺服器告訴你這次請求是成功還是失敗，或者需要做什麼。像 200 通常是成功，404 是找不到網頁，500 是伺服器內部出錯。

### Q3：什麼是 HTTP 快取 (Caching)？它有什麼作用？
- 快取是指瀏覽器或代理伺服器儲存一份網頁資源的副本。
- 作用：減少對伺服器的請求次數，降低延遲，加快網頁載入速度，節省頻寬。
- 通過 HTTP Header (如 `Cache-Control`, `Expires`, `ETag`, `Last-Modified`) 來控制快取行為。
- 🗣️口語化回答：就是把一些常用的資料暫時存起來，下次再需要就不用每次都去問伺服器，可以更快拿到。

## 重要語法或術語
- HTTP Request
- HTTP Response
- HTTP Methods (GET, POST, PUT, DELETE)
- URL / URI
- HTTP Headers
- HTTP Body
- Status Code (200, 404, 500等)
- Stateless (無狀態)

## 面試常見問法與回答

### Q1：請描述一個客戶端發送 HTTP 請求到接收到回應的整個過程。
- 瀏覽器解析 URL，找到伺服器 IP 地址（DNS 查詢）。
- 建立 TCP 連線到伺服器。
- 瀏覽器發送 HTTP Request (包含 method, URL, headers, body)。
- 伺服器接收請求，處理後回傳 HTTP Response (包含 status code, headers, body)。
- 瀏覽器接收 Response，解析並顯示內容。
- 🗣️口語化回答：就像寫信一樣，瀏覽器把想知道的東西打包寄給伺服器（請求），伺服器處理完再寫信寄回來（回應），瀏覽器再把信打開看。

### Q2：你在開發 API 時，如何決定使用 GET 還是 POST？
- 如果只是單純地獲取資料、不改變伺服器狀態，就用 GET。
- 如果需要提交表單、上傳檔案或新增、修改資源（且操作非冪等），就用 POST。
- 總之就是根據操作是「取得」還是「提交/修改」，以及資料的敏感性和冪等性來決定。
- 🗣️口語化回答：看我這個功能是要拿資料還是要送資料進去，拿資料用 GET，送資料通常用 POST。

# 四、Request / Response 結構與用途

## 重點摘要
HTTP Request 和 Response 是 HTTP 通訊的兩大核心組成部分。它們都包含起始行、標頭（Headers）和主體（Body）。理解這些結構如何攜帶元資料和實際數據，對於除錯、處理前後端傳輸資料、實作身份驗證、快取控制等都至關重要。

## 定義
- HTTP Request (請求)：由客戶端發送給伺服器。包含：
    - Start Line: Method, URL, HTTP Version (e.g., `GET /users HTTP/1.1`).
    - Headers: 提供關於請求的元資料 (e.g., `Content-Type`, `Authorization`, `User-Agent`)。
    - Body (Optional): 包含實際傳送的數據 (e.g., POST 表單數據或 JSON)。
- HTTP Response (回應)：由伺服器發送給客戶端。包含：
    - Start Line: HTTP Version, Status Code, Status Text (e.g., `HTTP/1.1 200 OK`).
    - Headers: 提供關於回應的元資料 (e.g., `Content-Type`, `Cache-Control`, `Set-Cookie`)。
    - Body (Optional): 包含伺服器回傳的數據 (e.g., HTML 頁面、JSON 資料)。

## 常考觀念 Q&A

### Q1：HTTP Request Header 常見的用途有哪些？
- 告訴伺服器客戶端的資訊：如瀏覽器類型 (`User-Agent`)、接受的回應格式 (`Accept`)、語言偏好 (`Accept-Language`)。
- 傳遞認證資訊：如 `Authorization` Header 攜帶 Token 或憑證。
- 控制快取行為：如 `Cache-Control`。
- 傳遞請求 Body 的資訊：如 `Content-Type` (Body 是 JSON 還是表單數據)、`Content-Length`。
- 🗣️口語化回答：Header 就像信封上的資訊，告訴伺服器你是誰、你要什麼格式的資料、你有沒有帶通行證等等。

### Q2：HTTP Response Header 常見的用途有哪些？
- 告訴客戶端伺服器的資訊：如伺服器類型 (`Server`)、內容類型 (`Content-Type`)。
- 控制瀏覽器的行為：如 `Set-Cookie` 設定 Cookie、`Location` 用於重新導向、`Cache-Control` 控制快取。
- 關於 Response Body 的資訊：如 `Content-Length`。
- 🗣️口語化回答：Response Header 就像回信的信封，告訴你這封信是什麼類型（網頁還是資料）、要不要存起來（快取），或是要你在瀏覽器做些什麼（設定 Cookie）。

### Q3：Request Body 和 URL Query String 傳遞數據有什麼區別？
- Query String：數據附加在 URL 的 `?` 後面，以 `key=value` 形式組成。適合傳遞簡單、非敏感的參數，主要用於 GET 請求。數據大小通常有限制，且暴露在 URL 中。
- Request Body：數據放在 HTTP 請求的主體部分。適合傳遞大量數據、複雜結構（如 JSON）和敏感數據，主要用於 POST, PUT, PATCH 等請求。數據大小通常只受伺服器限制，不會暴露在 URL 中。
- 🗣️口語化回答：Query String 是把資料放在網址上傳，大家都看得到，而且有長度限制；Body 是把資料藏在請求裡面傳，比較安全，可以傳比較多東西。

## 重要語法或術語
- Request Header
- Request Body
- Response Header
- Response Body
- Content-Type
- Authorization
- Cache-Control
- Set-Cookie
- Query String
- HTTP Status Code

## 面試常見問法與回答

### Q1：如何在 Java 後端取得 Request 中的資料？
- 如果是 Query String 或 Path Variable，可以在 Spring MVC 的 Controller 方法參數上使用 `@RequestParam` 或 `@PathVariable` 註解來綁定。
- 如果是 Request Body (如 JSON)，可以使用 `@RequestBody` 註解將 Body 內容自動轉換成 Java 物件。
- 🗣️口語化回答：看資料是放在網址後面還是請求裡面。在網址上的用 `@RequestParam` 或 `@PathVariable`，在請求裡（比如 JSON）的用 `@RequestBody`。

### Q2：你如何控制伺服器回傳的 Response 格式？
- 通常會在 Response Header 中設定 `Content-Type` 來指定回傳的資料格式，例如 `application/json` 或 `text/html`。
- 在 Spring Boot 中，使用 `@RestController` 的方法預設會回傳 JSON，也可以透過 `@Produces` 或方法回傳型別來控制。
- 🗣️口語化回答：我會在回傳 Response 的時候，設定 Header 告訴瀏覽器我回傳的是 JSON 還是 HTML 或其他格式。

# 五、資料正規化（Database Normalization）

## 重點摘要
資料正規化是關聯式資料庫設計的重要步驟，目的是透過分解表格來減少數據冗餘（Redundancy），並提高數據完整性（Data Integrity）。正規化可以避免在資料庫操作時（新增、修改、刪除）產生異常（Anomalies），讓資料庫結構更清晰、易於維護。

## 定義
- 資料正規化：一個系統性的過程，用於優化關聯式資料庫的結構，通常涉及將大表分解為較小、更具體的表。
- 目標：減少數據冗餘，避免更新異常、插入異常和刪除異常。
- 範式 (Normal Form, NF)：正規化的不同等級，常見有第一正規化 (1NF)、第二正規化 (2NF)、第三正規化 (3NF)。
- 冗餘 (Redundancy)：同一數據在多個地方重複存儲。
- 異常 (Anomalies)：
    - 插入異常 (Insertion Anomaly)：無法插入某些數據，除非同時插入其他無關數據。
    - 更新異常 (Update Anomaly)：更新同一數據時，需要在多處修改，否則會出現數據不一致。
    - 刪除異常 (Deletion Anomaly)：刪除某條數據時，無意中刪除了其他重要數據。

## 常考觀念 Q&A

### Q1：為什麼需要資料正規化？
- 減少數據冗餘，節省存儲空間，並避免數據不一致。
- 避免插入、更新、刪除時產生的異常，確保數據的完整性。
- 使資料庫結構更清晰、邏輯更合理，方便維護和擴展。
- 🗣️口語化回答：正規化是為了讓資料庫的資料不會重複太多、不容易出錯，而且結構比較好管理。

### Q2：請簡述 1NF、2NF、3NF 的要求。
- 1NF：表格中的每個欄位值都必須是原子的（不可再分割），且不能有重複的行。
- 2NF：滿足 1NF，且非主鍵欄位必須完全依賴於**整個**主鍵（如果主鍵是複合鍵）。
- 3NF：滿足 2NF，且非主鍵欄位之間不能存在傳遞依賴（即非主鍵欄位不能依賴於另一個非主鍵欄位）。
- 🗣️口語化回答：1NF 是要求欄位值不能再分開，2NF 是非主鍵欄位要靠「全部」主鍵，3NF 是非主鍵欄位不能靠別的非主鍵欄位。正規化等級越高，重複越少。

### Q3：什麼是反正規化 (Denormalization)？什麼時候會考慮使用？
- 反正規化是故意在正規化後的表格中增加一些冗餘，通常是為了提高查詢性能。
- 會在查詢頻繁、需要 JOIN 多個表格才能獲取所需數據的情況下考慮。
- 這是用冗餘換取查詢速度的權衡。
- 🗣️口語化回答：反正規化就是故意讓資料重複一點點，是為了讓查詢速度變快，但可能會增加維護上的麻煩。

## 重要語法或術語
- Redundancy (冗餘)
- Data Integrity (數據完整性)
- Anomaly (異常)
- Normal Form (範式)
- 1NF, 2NF, 3NF
- Primary Key (主鍵)
- Foreign Key (外鍵)
- Dependency (依賴)
- Denormalization (反正規化)

## 面試常見問法與回答

### Q1：你在設計資料庫時，如何應用正規化概念？
- 我會先識別出系統中的實體（如使用者、產品、訂單）。
- 建立對應的表格，並確定主鍵。
- 檢查欄位是否符合 1NF (例如避免在單一欄位存儲多個值)。
- 考慮欄位之間的依賴關係，將表格分解到至少 3NF，避免更新異常等問題。
- 🗣️口語化回答：我會把資料拆成不同的表格，用主鍵和外鍵連起來，確保每個表格的資料都乾淨、不重複太多，至少做到 3NF。

### Q2：給一個實際例子，說明正規化如何避免問題。
- 假設有個訂單表 `(OrderID, OrderDate, CustomerName, CustomerAddress, ItemName, ItemPrice, Quantity)`。如果一個客戶有多個訂單，`CustomerName` 和 `CustomerAddress` 會重複多次（冗餘）。
- 如果客戶搬家了，你需要更新所有訂單的 `CustomerAddress`，容易漏改造成更新異常。
- 正規化會將其拆成 `Orders (OrderID, OrderDate, CustomerID)` 和 `Customers (CustomerID, CustomerName, CustomerAddress)` 以及 `OrderItems (OrderID, ItemName, ItemPrice, Quantity)`。這樣更新客戶地址只需改 `Customers` 表一次。
- 🗣️口語化回答：比如客戶地址，如果每個訂單都存一份，客戶搬家就要改很多地方。正規化後客戶資料獨立出來，只要改一次就好，不會出錯。

# 六、SQL 常見語法與概念（SELECT、JOIN、WHERE、GROUP BY、子查詢等）

## 重點摘要
SQL (Structured Query Language) 是與關聯式資料庫互動的標準語言。熟練掌握 SQL 的基本語法和常用子句（如 SELECT, JOIN, WHERE, GROUP BY），對於全端工程師進行資料查詢、修改和管理至關重要。理解如何合併表格（JOIN）和篩選/聚合資料是日常開發的必備技能。

## 定義
- SQL：用於管理關聯式資料庫的標準語言，包含數據定義語言 (DDL) 和數據操作語言 (DML)。
- DML (Data Manipulation Language)：用於查詢和修改數據，包括 `SELECT`, `INSERT`, `UPDATE`, `DELETE`。
- DDL (Data Definition Language)：用於定義資料庫結構，包括 `CREATE TABLE`, `ALTER TABLE`, `DROP TABLE`。
- 子句 (Clause)：SQL 語句中的組成部分，如 `FROM`, `WHERE`, `GROUP BY`, `ORDER BY`。

## 常考觀念 Q&A

### Q1：請說明 SELECT 語句中 WHERE 子句和 HAVING 子句的區別。
- WHERE 子句：用於在**分組之前**篩選**個別的行**。它不能使用聚合函數（如 SUM, COUNT, AVG）。
- HAVING 子句：用於在**分組之後**篩選**分組的結果**。它通常與 `GROUP BY` 一起使用，可以用聚合函數。
- 🗣️口語化回答：WHERE 是先過濾每一筆資料，不能用像 COUNT 這種統計；HAVING 是等資料分組完（用 GROUP BY）後，再過濾這些分組的結果，可以用統計函數。

### Q2：什麼是 SQL JOIN？常用的 JOIN 有哪些？
- JOIN：用於根據兩個或多個表格之間的相關欄位，將這些表格的行組合起來。
- 常用的 JOIN 類型：
    - INNER JOIN：回傳兩個表格中**都有**匹配值的行。
    - LEFT JOIN (或 LEFT OUTER JOIN)：回傳左邊表格的所有行，以及右邊表格中與左邊匹配的行。如果右邊沒有匹配，則右邊的欄位為 NULL。
    - RIGHT JOIN (或 RIGHT OUTER JOIN)：回傳右邊表格的所有行，以及左邊表格中與右邊匹配的行。如果左邊沒有匹配，則左邊的欄位為 NULL。
    - FULL JOIN (或 FULL OUTER JOIN)：回傳當左邊或右邊表格中存在匹配時的所有行。如果沒有匹配，另一邊的欄位為 NULL。
- 🗣️口語化回答：JOIN 就是把兩個表根據他們共有的東西（像 ID）連起來看。INNER JOIN 是只看兩個表都有對應上的；LEFT JOIN 是左邊的都看，右邊沒有就空著。

### Q3：什麼是子查詢 (Subquery)？
- 子查詢：嵌套在另一個 SQL 查詢語句中的查詢。
- 它可以出現在 `WHERE`, `FROM`, `SELECT` 子句中。
- 子查詢的結果可以用作外部查詢的條件或數據來源。
- 🗣️口語化回答：就是在一個 SQL 語句裡，再寫一個小的 SQL 去查東西，把小的查詢結果拿來給外面的查詢用。

## 重要語法或術語
- SELECT, INSERT, UPDATE, DELETE
- WHERE
- JOIN (INNER, LEFT, RIGHT, FULL)
- GROUP BY
- HAVING
- ORDER BY
- 子查詢 (Subquery)
- Primary Key, Foreign Key
- Aggregate Functions (COUNT, SUM, AVG, MAX, MIN)

## 面試常見問法與回答

### Q1：請寫一個 SQL 查詢，找出所有訂單金額大於 1000 元的客戶名稱和訂單總金額。(假設有 `Customers (CustomerID, CustomerName)` 和 `Orders (OrderID, CustomerID, Amount)`)
```sql
SELECT c.CustomerName, SUM(o.Amount) AS TotalAmount
FROM Customers c
JOIN Orders o ON c.CustomerID = o.CustomerID
GROUP BY c.CustomerName
HAVING SUM(o.Amount) > 1000;
```
- 解釋：先 JOIN `Customers` 和 `Orders` 表格，然後按照客戶名稱分組 (`GROUP BY`)，計算每個客戶的訂單總金額 (`SUM(o.Amount)`)，最後用 `HAVING` 過濾出總金額大於 1000 的分組。
- 🗣️口語化回答：我會先把客戶表和訂單表連起來，然後用客戶名稱分組，算出每個客戶的總訂單金額，最後篩選出總金額超過 1000 的。

### Q2：在你的專案中，最常用到的 SQL 操作是什麼？
- 最常用的是 `SELECT` 進行各種資料查詢，結合 `WHERE` 進行篩選，以及 `JOIN` 來連接相關表格獲取完整資訊。
- 也常用 `INSERT` 新增資料，`UPDATE` 修改資料，以及 `DELETE` 刪除資料。
- 有時會用到 `GROUP BY` 和聚合函數來做統計報表。
- 🗣️口語化回答：基本上就是查、增、改、刪這些基本操作，尤其是查資料，常常需要把不同表格的資料連起來看（JOIN）。

# 七、Spring Boot 架構與註解（Controller、Service、Repository 等）

## 重點摘要
Spring Boot 是基於 Spring 框架的快速開發框架，它簡化了 Spring 應用程式的設定和部署。了解 Spring Boot 的核心概念（如自動配置、起步依賴）以及常用的註解（如 `@Controller`, `@Service`, `@Repository`, `@Autowired`），對於開發 Java 後端應用程式至關重要，這也是面試中常考的實務技能。

## 定義
- Spring Boot：一個開源的 Java 框架，旨在簡化 Spring 應用程式的初始化和開發過程。
- 自動配置 (Auto-configuration)：Spring Boot 會根據你加入的函式庫自動配置應用程式的許多方面。
- 起步依賴 (Starter Dependencies)：預先配置好的依賴項集合，讓你快速引入所需功能（如 `spring-boot-starter-web`）。
- IoC (Inversion of Control) / DI (Dependency Injection)：控制反轉/依賴注入，Spring 容器負責建立和管理物件及其依賴關係。
- Component Scan：Spring 會掃描特定套件下的類別，找到 Spring 元件（Bean）。

## 常考觀念 Q&A

### Q1：什麼是 Spring Boot 的「自動配置」(Auto-configuration)？
- Spring Boot 會檢查你的專案依賴（JARs），並根據這些依賴自動配置 Spring 應用程式。
- 例如，如果你引入了 H2 資料庫依賴，Spring Boot 會自動配置一個 DataSource。
- 大大減少了傳統 Spring Framework 需要手動配置 XML 或 JavaConfig 的工作量。
- 🗣️口語化回答：它會自動偵測你用了哪些技術（像資料庫、網頁伺服器），然後幫你把大部分設定都配好，你不用自己寫一堆設定檔。

### Q2：請解釋 `@Autowired` 註解的作用？
- `@Autowired` 用於實現依賴注入（Dependency Injection）。
- 它告訴 Spring 容器，需要在這個位置注入一個特定型別的 Bean。
- Spring 會在應用程式啟動時，自動找到匹配的 Bean 並將其實例化後注入。
- 可以應用在建構子、 Setter 方法或欄位上。
- 🗣️口語化回答：這個註解是告訴 Spring，我這裡需要某個東西（另一個物件），請 Spring 幫我創建好並放進來，我不用自己去 new。

### Q3：在 Spring Boot 應用中，`@Controller`、`@Service` 和 `@Repository` 通常分別用於什麼層？
- `@Controller` (或 `@RestController`)：用於表示處理 Web 請求的類別，屬於**表現層 (Presentation Layer)** 或 **Web Layer**。負責接收客戶端請求，呼叫 Service 層處理，並回傳回應。
- `@Service`：用於表示業務邏輯處理的類別，屬於**業務邏輯層 (Business Logic Layer)**。封裝核心業務流程，通常會呼叫 Repository 層。
- `@Repository`：用於表示與資料存取相關的類別，屬於**資料存取層 (Data Access Layer)**。負責與資料庫或其他持久化存儲互動。
- 🗣️口語化回答：`@Controller` 處理網頁來的請求；`@Service` 處理主要的業務邏輯；`@Repository` 則負責跟資料庫打交道。這樣分層比較清楚。

## 重要語法或術語
- @SpringBootApplication
- Auto-configuration
- Starter Dependencies
- IoC Container
- DI (Dependency Injection)
- @Autowired
- @Controller / @RestController
- @Service
- @Repository
- Component Scan
- Bean

## 面試常見問法與回答

### Q1：請描述一個請求在你的 Spring Boot 應用中的處理流程。
- 客戶端發送 HTTP 請求。
- 請求首先到達 DispatcherServlet（Spring MVC 的核心）。
- DispatcherServlet 根據請求 URL 找到對應的 `@Controller` 或 `@RestController`。
- Controller 方法處理請求，可能會呼叫 `@Service` 層的業務邏輯。
- Service 層可能呼叫 `@Repository` 層與資料庫互動。
- 處理完成後，Service 將結果返回給 Controller。
- Controller 根據結果構建 HTTP Response，回傳給客戶端。
- 🗣️口語化回答：請求進來後，先到一個總管（DispatcherServlet），它找到對應的 Controller，Controller 再叫 Service 處理，Service 可能會去資料庫拿資料（Repository），最後結果回到 Controller 再回傳出去。

### Q2：你在專案中怎麼使用 Spring Boot 處理資料庫操作？
- 使用 Spring Data JPA (或其他 ORM 框架整合 Spring Boot)。
- 定義 Entity 類別映射資料庫表格。
- 建立繼承 `JpaRepository` 的 Interface 作為 Repository 層，Spring Data JPA 會自動生成基礎的 CRUD 方法。
- 在 Service 層注入 Repository 類別，呼叫其方法進行資料庫操作。
- 🗣️口語化回答：我主要用 Spring Data JPA，定義好資料的結構（Entity），然後寫一個 Repository Interface，Spring 就會自動幫我處理大部分跟資料庫互動的程式碼了。

### Q3：請分享一個你在使用 Spring Boot 遇到的問題及如何解決。
- 遇過啟動時 Bean 之間的依賴循環問題。
- 解決方法：分析 Bean 之間的依賴關係，找出循環點，重構程式碼設計，例如使用 Setter 注入代替建構子注入，或者將部分邏輯拆分到新的 Service 中，打破循環依賴。
- 🗣️口語化回答：有遇過程式啟動時，物件互相等對方創建好的循環問題，後來是調整一下程式結構或換個方式注入來解決的。

# 八、Java 垃圾回收（Garbage Collection）機制與優化策略

## 重點摘要
Java 的垃圾回收 (GC) 是自動化的記憶體管理機制，它負責回收不再使用的物件佔用的記憶體。雖然是自動的，但理解 GC 的工作原理、不同區域和常見演算法，有助於診斷記憶體洩漏、優化應用程式性能，並避免 `OutOfMemoryError` 等問題，這對於開發大型或長時間運行的 Java 應用程式非常重要。

## 定義
- 垃圾回收 (GC)：Java 虛擬機 (JVM) 的一項自動服務，用於識別和回收不再被程式引用的物件所佔用的記憶體空間。
- 記憶體區域：Java Heap 是 GC 主要工作區域，通常分為 Young Generation (新生代)、Old Generation (老年代)。有時還有 Permanent Generation (永久代) 或 Metaspace (元空間)。
- 可達性 (Reachability)：GC 判斷物件是否應被回收的依據。從 GC Roots (如執行緒、靜態變數) 無法到達的物件即是「不可達」的。
- Minor GC：發生在 Young Generation 的垃圾回收。
- Major GC / Full GC：發生在 Old Generation 或整個 Heap 的垃圾回收，通常伴隨較長時間的「Stop-The-World」停頓。

## 常考觀念 Q&A

### Q1：什麼是 Java 的垃圾回收？為什麼 Java 需要 GC？
- GC 是 JVM 自動清理不再使用的物件，釋放記憶體的過程。
- Java 需要 GC 是因為它解放了開發者手動管理記憶體的負擔（如 C++ 中的 `malloc`/`free`），降低了記憶體洩漏和懸掛指標等問題的風險，提高了開發效率和程式安全性。
- 🗣️口語化回答：GC 就是 Java 幫你自動清理沒在用的記憶體，這樣你就不用自己操心什麼時候要釋放空間了。

### Q2：請解釋 Java Heap 記憶體的新生代 (Young Gen) 和老年代 (Old Gen)。
- 新生代 (Young Gen)：新創建的物件首先會分配在這裡。新生代通常較小，並且經常發生 Minor GC。 Minor GC 速度快，且只影響新生代。
- 老年代 (Old Gen)：經過多次 Minor GC 後仍然存活的物件會被移動到老年代。老年代通常較大，發生 Full GC 的頻率較低，但 Full GC 成本較高（停頓時間長）。
- 🗣️口語化回答：新物件一開始會放在新生代，活得夠久的會被移到老年代。新生代比較小，清理很快；老年代比較大，清理比較慢。

### Q3：GC 是如何判斷一個物件是否可以被回收？`System.gc()` 會立即觸發 GC 嗎？
- GC 使用「可達性分析」(Reachability Analysis) 來判斷物件是否可被回收。如果從 GC Roots (如執行緒棧中的參考、靜態變數) 無法到達一個物件，則該物件被視為垃圾。
- `System.gc()` 只是向 JVM **建議**執行 GC，JVM 不保證會立即執行，甚至可能忽略這個建議。它主要用於除錯或測試目的。
- 🗣️口語化回答：GC 會看這個物件還有沒有地方能找到它，找不到就代表沒用了，可以清掉。呼叫 `System.gc()` 只是跟 JVM 說「欸，好像該清垃圾了喔」，但 JVM 不一定會馬上聽你的。

## 重要語法或術語
- Garbage Collection (GC)
- Java Heap
- Young Generation (新生代)
- Old Generation (老年代)
- Metaspace (元空間)
- Minor GC
- Major GC / Full GC
- GC Roots
- Reachability (可達性)
- Stop-The-World (STW)
- OutOfMemoryError

## 面試常見問法與回答

### Q1：你的應用程式是否遇過記憶體相關的問題？如何診斷與解決？
- 遇過 `OutOfMemoryError`，通常是記憶體洩漏導致老年代空間不足。
- 診斷方法：使用 JVM 監控工具（如 JConsole, VisualVM, Java Mission Control）查看 Heap 使用情況、GC 活動和執行緒狀態。分析 Heap Dump (例如使用 Eclipse Memory Analyzer Tool) 來找出是哪些物件佔用了大量記憶體且沒有被釋放。
- 解決方法：根據 Heap Dump 分析結果，修改程式碼中導致記憶體洩漏的部分，例如關閉不再使用的資源（文件流、資料庫連線）、移除集合中不再需要的物件等。
- 🗣️口語化回答：有遇過記憶體用光的問題，我會用工具看是哪些物件一直佔著記憶體沒放，然後去改程式碼，把那些沒用的物件釋放掉。

### Q2：在開發時，有哪些方式可以減少 GC 壓力或優化 GC 性能？
- 盡量減少創建短期存活的物件，特別是在迴圈或頻繁呼叫的方法中。
- 避免創建過多的大物件。
- 確保不再使用的物件能被正確地設置為 `null` 或從集合中移除，使其能被 GC 回收。
- 選擇合適的 GC 演算法（JVM 參數設定），根據應用程式特性調整 Young/Old Gen 的大小比例。
- 🗣️口語化回答：就是盡量少製造垃圾（少創建不必要的物件），特別是短暫用一下就丟的。還有就是確保用完的東西能被正確回收。

# 九、Java 基本語法與物件導向觀念（OOP，包括封裝、繼承、多型）

## 重點摘要
Java 是一門物件導向的語言，其核心概念包括封裝、繼承和多型 (OOP三大支柱)。理解這些基本語法和 OOP 觀念，是編寫結構清晰、易於維護、可重用程式碼的基礎。這部分是面試中最基礎但也最常考的觀念題。

## 定義
- 物件導向程式設計 (OOP)：一種程式設計範式，將程式組織為相互協作的物件集合。
- 物件 (Object)：具有狀態（屬性）和行為（方法）的實體。
- 類別 (Class)：物件的模板或藍圖，定義了物件的屬性和方法。
- 封裝 (Encapsulation)：將數據（屬性）和處理數據的方法捆綁在一起，形成一個獨立單元（類別）。通常通過存取修飾詞（如 `private`）隱藏內部細節，只暴露必要的介面。
- 繼承 (Inheritance)：一個類別（子類/派生類）可以繼承另一個類別（父類/基類）的屬性和方法，實現程式碼重用。
- 多型 (Polymorphism)：允許不同類型的物件對同一個方法呼叫做出不同的響應。主要體現在方法重載 (Overloading) 和方法重寫 (Overriding)。
- 抽象 (Abstraction)：隱藏複雜的實現細節，只向外部暴露必要的功能。可以通過抽象類別 (Abstract Class) 和介面 (Interface) 來實現。

## 常考觀念 Q&A

### Q1：請解釋什麼是封裝 (Encapsulation)？它的好處是什麼？
- 封裝是將資料（屬性）和操作這些資料的方法綁定在一個類別中。
- 通常會將屬性設為 `private`，然後提供公共的 `getter`/`setter` 方法來存取。
- 好處：
    - 提高安全性：控制外部對數據的存取權限。
    - 提高維護性：修改內部實現時，只要介面不變，外部程式碼不受影響。
    - 提高模組化：將複雜性隱藏起來，使類別成為一個獨立的模組。
- 🗣️口語化回答：封裝就是把資料和處理資料的方法包在一起，藏起來不讓外面直接亂動，只能透過我提供的方法來存取，這樣比較安全也比較好管理程式。

### Q2：請解釋什麼是繼承 (Inheritance)？什麼是方法重寫 (Method Overriding)？
- 繼承：讓一個類別（子類）可以從另一個類別（父類）獲得屬性和方法。子類可以重用父類的程式碼，也可以添加自己的獨有功能。
- 方法重寫：子類定義了一個與父類中方法「簽名」（方法名、參數列表、回傳類型）完全相同的方法。當通過父類型的引用指向子類物件並呼叫該方法時，執行的是子類的方法。
- 🗣️口語化回答：繼承就是讓新的類別可以用舊類別的東西。方法重寫是子類覺得父類的方法不好用，就自己寫一個一樣名字的來蓋掉它。

### Q3：請解釋什麼是多型 (Polymorphism)？請舉例說明。
- 多型：允許用父類型的引用來指向子類型的物件，並在執行時根據實際的物件類型來決定呼叫哪個方法。
- 例子：
    ```java
    Animal myPet = new Dog(); // 父類型引用指向子類物件
    myPet.makeSound(); // 執行的是 Dog 類別的 makeSound 方法
    myPet = new Cat();
    myPet.makeSound(); // 執行的是 Cat 類別的 makeSound 方法
    ```
- 🗣️口語化回答：多型就是同一個方法呼叫，根據實際的物件類型不同，會做出不同的事情。就像你叫動物叫，狗會汪汪叫，貓會喵喵叫。

### Q4：抽象類別 (Abstract Class) 和 介面 (Interface) 有什麼區別？
- 抽象類別：
    - 可以有抽象方法（沒有方法體）和具體方法（有方法體）。
    - 可以有實例變數。
    - 不能被直接實例化，必須被子類繼承。
    - 子類繼承抽象類別時，必須實現所有抽象方法（除非子類也是抽象類別）。
    - 一個類別只能繼承一個抽象類別。
- 介面：
    - 在 Java 8 之前只能有抽象方法（預設就是 public abstract）。Java 8+ 可以有 default 和 static 方法。Java 9+ 可以有 private 方法。
    - 在 Java 8 之前只能有常量（預設就是 public static final）。
    - 不能被實例化，必須被類別實現 (implement)。
    - 實現介面的類別必須實現所有抽象方法。
    - 一個類別可以實現多個介面。
- 🗣️口語化回答：抽象類別像是一個「半成品」的父類，裡面可以有已經寫好的方法。介面像是一個「規格表」，只定義了方法名，要實現的類別自己去完成所有方法。

## 重要語法或術語
- Class (類別)
- Object (物件)
- Encapsulation (封裝)
- Inheritance (繼承)
- Polymorphism (多型)
- Abstraction (抽象)
- Method Overloading (方法重載)
- Method Overriding (方法重寫)
- Abstract Class (抽象類別)
- Interface (介面)
- `private`, `public`, `protected` (存取修飾詞)
- `extends`, `implements`
- `super`, `this`

## 面試常見問法與回答

### Q1：請舉一個你在專案中應用物件導向三大支柱（封裝、繼承、多型）的例子。
- **封裝**：我會將類別的屬性設為 `private`，例如使用者物件的密碼屬性，只提供受控的 `getter` (可能沒有 `setter`)，避免外部直接修改。
- **繼承**：假設我有不同的產品類型（如數位產品、實體產品），它們有一些共同屬性（名稱、價格），我會定義一個 `Product` 父類，然後讓 `DigitalProduct` 和 `PhysicalProduct` 子類去繼承它，並添加各自特有的屬性（下載連結、運費）。
- **多型**：當處理不同類型的產品訂單時，我可以用一個 `List<Product>` 來存儲不同類型的產品物件。在計算總價時，呼叫它們共同的 `getPrice()` 方法，每個子類會根據自己的邏輯計算價格（例如數位產品沒有運費，實體產品有）。
- 🗣️口語化回答：像是用戶資料，我會把敏感資料藏起來（封裝）。如果有不同種類的產品，我會讓它們繼承一個共同的產品類別（繼承），然後處理這些產品時，不管它是哪種產品，我都可以用同一個方法去處理，它自己會知道怎麼做（多型）。

### Q2：當遇到一個複雜的需求時，你會如何開始設計你的 Java 類別結構？
- 會先識別出問題領域中的主要「實體」或「概念」，將它們設計成獨立的類別。
- 思考這些類別之間有什麼關係：是「is-a」（繼承）、「has-a」（組合/關聯）還是「uses-a」（依賴）？
- 考慮如何運用封裝來保護資料、多型來處理不同情況、抽象來隱藏複雜性。
- 畫類別圖或簡單的方塊圖來理清結構。
- 🗣️口語化回答：我會先想清楚有哪些主要的「東西」（實體），把它們變成類別，然後想這些類別之間怎麼互動、有沒有共同或不同的地方，再用繼承、介面那些概念去設計結構。

---
好的，身為資深 Java 軟體工程講師，很高興為您準備這些常見的 Java 程式筆試題教學內容。以下是針對您指定的題型，依照您要求的格式所產出的內容：

---

### 1️⃣ 題目說明（請以清楚的段落說明邏輯）

請撰寫一支 Java 程式，根據使用者輸入的高度 `N`，印出一個靠左下的直角三角形，由星號（`*`）組成。三角形共有 `N` 行，第一行有一個星號，第二行有兩個星號，依此類推，到第 `N` 行有 `N` 個星號。

這個題目旨在考驗使用者對巢狀迴圈（Nested Loops）的理解與運用，特別是如何控制內層迴圈的執行次數與外層迴圈的關係，以產生特定的圖案。

#### 範例輸入：

請輸入三角形的高度：5

#### 預期輸出：

```
*
**
***
****
*****
```

### 2️⃣ Java 解答程式碼

```java
import java.util.Scanner;

public class LeftAlignedTriangle {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("請輸入三角形的高度：");
        int height = scanner.nextInt();

        // 外層迴圈控制行數
        for (int i = 1; i <= height; i++) {
            // 內層迴圈控制每一行印出的星號數量
            // 第 i 行需要印出 i 個星號
            for (int j = 1; j <= i; j++) {
                System.out.print("*");
            }
            // 每一行印完後換行
            System.out.println();
        }

        scanner.close();
    }
}
```

### 3️⃣ 重點解析

*   **程式架構：** 程式主要分為幾個步驟：取得使用者輸入、使用迴圈產生圖案、以及在每行結束後換行。
*   **巢狀迴圈：** 本題的核心是使用巢狀迴圈。外層的 `for (int i = 1; i <= height; i++)` 負責控制總共有多少行輸出，`i` 代表當前是第幾行。內層的 `for (int j = 1; j <= i; j++)` 負責控制在當前這第 `i` 行要印出多少個星號。注意到內層迴圈的條件 `j <= i`，這確保了第 `i` 行剛好會印出 `i` 個星號。
*   **輸出控制：** `System.out.print("*")` 用於在同一行連續印出星號，而 `System.out.println()` 在內層迴圈結束後呼叫，用於將游標移到下一行，開始印製下一行的星號。
*   **語法選擇：** 使用 `for` 迴圈是因為我們明確知道迴圈需要執行的次數（外層迴圈執行 `height` 次，內層迴圈執行 `i` 次）。`Scanner` 類別是 Java 標準函式庫中處理使用者輸入的常用工具。
*   **陷阱/錯誤：**
    *   常見錯誤是混淆內外層迴圈的功能，或是設定錯誤的迴圈條件。
    *   忘記在內層迴圈結束後使用 `System.out.println()` 會導致所有星號印在同一行。
    *   在處理使用者輸入時，未考慮非整數或負數輸入的錯誤處理（本範例為簡化未包含，但在實際應用中需考慮）。

---

### 1️⃣ 題目說明（請以清楚的段落說明邏輯）

請撰寫一支 Java 程式，印出完整的九九乘法表。乘法表的格式需要整齊，確保個位數和十位數的對齊。

這個題目主要考驗巢狀迴圈的應用，以及如何使用輸出的格式控制來達到排版整齊的效果。

#### 範例輸入：

（無使用者輸入）

#### 預期輸出：

```
1 * 1 =  1   1 * 2 =  2   ... 1 * 9 =  9
2 * 1 =  2   2 * 2 =  4   ... 2 * 9 = 18
...
9 * 1 =  9   9 * 2 = 18  ... 9 * 9 = 81
```
（注意：實際輸出應包含所有 9x9 的結果並對齊）

### 2️⃣ Java 解答程式碼

```java
public class MultiplicationTable {
    public static void main(String[] args) {
        // 外層迴圈控制被乘數 (i)
        for (int i = 1; i <= 9; i++) {
            // 內層迴圈控制乘數 (j)
            for (int j = 1; j <= 9; j++) {
                int result = i * j;
                // 使用 printf 進行格式化輸出
                // %d 是整數格式符
                // %2d 表示輸出至少佔用兩個字元寬度，不足左邊補空格
                // %-2d 表示輸出至少佔用兩個字元寬度，不足右邊補空格 (這裡用不到)
                // 我們希望結果部分對齊，所以使用 %2d
                System.out.printf("%d * %d = %2d   ", i, j, result);
            }
            // 每印完一行的乘法後換行
            System.out.println();
        }
    }
}
```

### 3️⃣ 重點解析

*   **程式架構：** 程式使用兩個巢狀迴圈來遍歷所有可能的乘數與被乘數組合 (1到9)。
*   **巢狀迴圈：** 外層迴圈控制被乘數 `i` 從 1 到 9，代表乘法表中的每一行。內層迴圈控制乘數 `j` 從 1 到 9，代表每一行中的每一個乘法算式。
*   **格式化輸出：** 九九乘法表排版整齊是本題的重點之一。`System.out.printf()` 方法是處理格式化輸出的強大工具。
    *   `"%d * %d = %2d   "` 是一個格式字串。
    *   `%d` 是用來插入整數的佔位符。
    *   `%2d` 是指要插入的整數至少佔用兩個字元的寬度，如果不足，會在左邊補上空格。這對於結果部分（例如 1, 2,... 9, 10, 12...）的對齊非常重要。
    *   `"   "` 提供了算式之間的固定間隔，幫助排版。
*   **換行：** 內層迴圈（印製一行中的所有算式）結束後，使用 `System.out.println()` 進行換行，以開始印製下一行的乘法算式。
*   **語法選擇：** `for` 迴圈適合已知循環次數的情況。`System.out.printf` 是比單純使用 `System.out.print` 或 `System.out.println` 再加上字串拼接更能精確控制輸出的方式。
*   **陷阱/錯誤：**
    *   未正確使用格式化輸出（如 `printf` 或手動計算空格）會導致乘法表結果無法對齊。
    *   忘記在內層迴圈結束後換行會導致所有算式印在同一行。

---

### 1️⃣ 題目說明（請以清楚的段落說明邏輯）

請撰寫一支 Java 程式，判斷使用者輸入的一個正整數是否為質數。質數（Prime Number）是除了 1 和本身以外，無法被其他正整數整除的自然數。根據定義，1 不是質數，2 是最小的質數。

這個題目考驗使用者對質數定義的理解，以及如何使用迴圈和條件判斷來檢查一個數是否滿足質數的條件。

#### 範例輸入：

請輸入一個正整數：17

#### 預期輸出：

17 是質數

---

#### 範例輸入：

請輸入一個正整數：10

#### 預期輸出：

10 不是質數

### 2️⃣ Java 解答程式碼

```java
import java.util.Scanner;

public class PrimeChecker {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("請輸入一個正整數：");
        int num = scanner.nextInt();

        boolean isPrime = true; // 假設一開始是質數

        // 根據質數定義，小於等於 1 的數不是質數
        if (num <= 1) {
            isPrime = false;
        } else {
            // 從 2 開始檢查到這個數的平方根
            // 這樣可以減少檢查的次數，提高效率
            // 如果 num 有因數 k (k > sqrt(num))，那麼 num/k 一定小於 sqrt(num)
            // 所以我們只需要檢查到平方根即可
            for (int i = 2; i * i <= num; i++) { // 或者使用 Math.sqrt(num) 並將 i 轉為整數
                // 如果 num 可以被 i 整除，代表 num 有除了 1 和本身以外的因數 i
                if (num % i == 0) {
                    isPrime = false; // 不是質數
                    break; // 找到一個因數就可以確定不是質數，提前結束迴圈
                }
            }
        }

        if (isPrime) {
            System.out.println(num + " 是質數");
        } else {
            System.out.println(num + " 不是質數");
        }

        scanner.close();
    }
}
```

### 3️⃣ 重點解析

*   **程式架構：** 程式包含取得輸入、初始化質數判斷標誌、根據質數定義進行判斷，最後輸出結果。
*   **條件判斷：** 首先使用 `if (num <= 1)` 處理特殊情況。根據質數定義，小於等於 1 的數都不是質數。
*   **迴圈與檢查：** 對於大於 1 的數，使用 `for` 迴圈從 2 開始檢查到這個數的平方根。這是判斷質數的常見優化方法。如果一個數 `num` 在這個範圍內（從 2 到 `sqrt(num)`）找到了可以整除它的因數 `i`（即 `num % i == 0`），則 `num` 不是質數，我們就可以立即設定 `isPrime` 為 `false` 並使用 `break` 跳出迴圈，無需繼續檢查。
*   **布林旗標：** 使用 `boolean isPrime` 變數作為判斷的標誌，初始化為 `true`（假設是質數），如果在檢查過程中發現非質數的證據，就將其改為 `false`。這種模式在需要根據一系列條件來判斷最終狀態時很常用。
*   **效率優化：** 迴圈條件 `i * i <= num` 比 `i <= Math.sqrt(num)` 更常用於整數判斷，因為避免了浮點數運算可能帶來的精度問題，並且在某些情況下效率略高。
*   **語法選擇：** `if/else` 結構用於處理不同情況，`for` 迴圈用於迭代檢查，`%` 運算子用於判斷整除。
*   **陷阱/錯誤：**
    *   未處理 `num <= 1` 的情況。
    *   迴圈從 0 或 1 開始檢查（質數定義是不能被除了 1 和本身以外的*正整數*整除，所以檢查從 2 開始）。
    *   迴圈檢查範圍超過平方根，雖然結果正確，但效率較低。
    *   忘記在找到因數後使用 `break`，導致不必要的檢查。

---

### 1️⃣ 題目說明（請以清楚的段落說明邏輯）

請撰寫一支 Java 程式，印出費式數列（Fibonacci Sequence）的前 N 項。費式數列的定義是：第一項是 0，第二項是 1，之後的每一項都是前兩項的和。數列的前幾項為：0, 1, 1, 2, 3, 5, 8, 13, ...

這個題目考驗使用者如何通過迭代（Iterative）或遞迴（Recursive）的方式來產生數列。對於基礎筆試，通常考量迭代的效率較高且更容易理解其狀態轉移。

#### 範例輸入：

請輸入要印出的費式數列項數 N：10

#### 預期輸出：

費式數列的前 10 項是：
0 1 1 2 3 5 8 13 21 34

### 2️⃣ Java 解答程式碼

```java
import java.util.Scanner;

public class FibonacciSequence {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("請輸入要印出的費式數列項數 N：");
        int n = scanner.nextInt();

        // 處理 N <= 0 的情況
        if (n <= 0) {
            System.out.println("請輸入一個正整數。");
            scanner.close();
            return; // 結束程式
        }

        System.out.println("費式數列的前 " + n + " 項是：");

        // 初始化前兩項
        long firstTerm = 0;
        long secondTerm = 1;

        // 根據 N 的值來印出
        if (n >= 1) {
            System.out.print(firstTerm); // 印出第一項
        }
        if (n >= 2) {
            System.out.print(" " + secondTerm); // 印出第二項
        }

        // 如果 N > 2，則循環計算並印出後續項
        for (int i = 3; i <= n; i++) {
            long nextTerm = firstTerm + secondTerm; // 計算下一項
            System.out.print(" " + nextTerm); // 印出下一項
            // 更新 firstTerm 和 secondTerm，為下一次計算做準備
            firstTerm = secondTerm;
            secondTerm = nextTerm;
        }

        System.out.println(); // 最後換行

        scanner.close();
    }
}
```

### 3️⃣ 重點解析

*   **程式架構：** 程式包含取得輸入、處理邊界情況、初始化數列的前兩項、使用迴圈生成並印出後續項。
*   **迭代法：** 本範例使用迭代法來產生費式數列，這是比遞迴更有效率的方法（尤其對於較大的 N）。其核心思想是：只需要記住前兩項的值，就可以計算出下一項，然後滾動更新這兩個值。
*   **狀態變數：** 使用 `firstTerm` 和 `secondTerm` 兩個變數來儲存當前項和前一項的值。`nextTerm` 用於計算即將要印出的下一項。
*   **邊界處理：** 需要特別處理 `N=1` 和 `N=2` 的情況，因為前兩項是固定的 0 和 1，循環是從第三項開始計算。程式碼中先單獨印出前兩項，再使用迴圈從 `i=3` 開始。
*   **資料類型：** 使用 `long` 而不是 `int` 來儲存費式數列的項。這是因為費式數列增長非常快，即使 N 不太大，項的值也可能超出 `int` 的範圍。使用 `long` 可以處理更大的 N 值。
*   **循環邏輯：** 在迴圈中，`nextTerm = firstTerm + secondTerm;` 計算出新項。然後通過 `firstTerm = secondTerm;` 和 `secondTerm = nextTerm;` 將「視窗」向前移動一項，準備計算再下一項。
*   **輸出格式：** 使用 `System.out.print` 在同一行印出數字，並用空格分隔。迴圈結束後使用 `System.out.println` 進行最後的換行。
*   **陷阱/錯誤：**
    *   未處理 N <= 0 的情況。
    *   未正確初始化或更新 `firstTerm` 和 `secondTerm`，導致數列生成錯誤。
    *   使用 `int` 導致數字溢位（當 N 較大時）。
    *   遞迴實現如果沒有記憶化會非常低效，容易堆疊溢位（Stack Overflow）或運行緩慢。

---

### 1️⃣ 題目說明（請以清楚的段落說明邏輯）

請撰寫一支 Java 程式，判斷使用者輸入的一個字串是否為回文（Palindrome）。回文字串是指正著讀和反著讀都一樣的字串。例如 "madam", "level", "racecar" 都是回文。在本題中，我們考慮簡單的字串比較，不考慮大小寫、空格或標點符號。

這個題目考驗使用者對字串操作的熟悉程度，以及如何使用迴圈或雙指標（Two Pointers）的方法來比較字串的對稱性。

#### 範例輸入：

請輸入一個字串：level

#### 預期輸出：

"level" 是回文。

---

#### 範例輸入：

請輸入一個字串：hello

#### 預期輸出：

"hello" 不是回文。

### 2️⃣ Java 解答程式碼

```java
import java.util.Scanner;

public class PalindromeChecker {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("請輸入一個字串：");
        String inputString = scanner.nextLine();

        boolean isPalindrome = true; // 假設一開始是回文

        // 使用雙指標方法
        int left = 0; // 左邊指標，從字串開頭開始
        int right = inputString.length() - 1; // 右邊指標，從字串結尾開始

        // 當左邊指標小於右邊指標時，繼續比較
        while (left < right) {
            // 比較左右指標指向的字元
            if (inputString.charAt(left) != inputString.charAt(right)) {
                isPalindrome = false; // 如果字元不相等，則不是回文
                break; // 找到不匹配的字元，提前結束檢查
            }
            // 移動指標，向字串中心靠攏
            left++;
            right--;
        }

        if (isPalindrome) {
            System.out.println("\"" + inputString + "\" 是回文。");
        } else {
            System.out.println("\"" + inputString + "\" 不是回文。");
        }

        scanner.close();
    }
}
```

### 3️⃣ 重點解析

*   **程式架構：** 程式包含取得輸入、初始化判斷標誌和雙指標、使用迴圈比較字元、最後輸出結果。
*   **雙指標法：** 判斷回文字串的一個高效方法是使用雙指標。一個指標 (`left`) 從字串的開頭開始，另一個指標 (`right`) 從字串的結尾開始。在迴圈中，同時向字串的中心移動這兩個指標，並比較它們所指向的字元。
*   **迴圈與比較：** `while (left < right)` 迴圈會持續執行，直到左指標越過或等於右指標。在每次迭代中，使用 `inputString.charAt(left)` 和 `inputString.charAt(right)` 取得對應位置的字元進行比較。如果發現任何一對字元不相等，就可以確定它不是回文，設置 `isPalindrome` 為 `false` 並 `break` 跳出迴圈。
*   **判斷標誌：** 使用 `boolean isPalindrome` 作為邏輯旗標，初始化為 `true`，如果發現不是回文的情況則改為 `false`。
*   **語法選擇：** `Scanner.nextLine()` 用於讀取整行字串。`String.length()` 取得字串長度。`String.charAt(index)` 取得指定位置的字元。`while` 迴圈適合在不知道明確迭代次數（只知道終止條件是 `left < right`）的情況下使用。
*   **陷阱/錯誤：**
    *   迴圈條件設定錯誤，例如使用 `left <= right` 對於奇數長度字串會多比較中心字元（雖不影響結果，但多餘）。
    *   指標移動方向錯誤或未更新指標。
    *   考慮大小寫、空格或標點符號時未進行預處理（本題要求不考慮，但實際面試可能會要求）。
    *   使用 `String` 的反轉方法（如 `StringBuilder.reverse()`) 雖然簡單，但面試可能希望你展示基本的迴圈/指標邏輯。

---

### 1️⃣ 題目說明（請以清楚的段落說明邏輯）

請撰寫一支 Java 程式，找出一個給定整數陣列中的最大值和最小值。

這個題目考驗使用者對陣列的基本操作，特別是如何遍歷陣列並在遍歷過程中追蹤並更新最大值和最小值。

#### 範例輸入：

給定陣列：`[12, 5, 8, 25, 10, 3]`

#### 預期輸出：

陣列中的最大值是：25
陣列中的最小值是：3

### 2️⃣ Java 解答程式碼

```java
public class ArrayMinMax {
    public static void main(String[] args) {
        // 定義一個整數陣列
        int[] numbers = {12, 5, 8, 25, 10, 3};

        // 檢查陣列是否為空
        if (numbers.length == 0) {
            System.out.println("陣列是空的，無法找到最大值和最小值。");
            return; // 結束程式
        }

        // 初始化最大值和最小值
        // 一個常見且安全的做法是將第一個元素設定為初始的最大值和最小值
        int max = numbers[0];
        int min = numbers[0];

        // 遍歷陣列，從第二個元素開始
        for (int i = 1; i < numbers.length; i++) {
            // 如果當前元素比目前的最大值大，更新最大值
            if (numbers[i] > max) {
                max = numbers[i];
            }
            // 如果當前元素比目前的最小值小，更新最小值
            if (numbers[i] < min) {
                min = numbers[i];
            }
        }

        // 印出結果
        System.out.println("陣列中的最大值是：" + max);
        System.out.println("陣列中的最小值是：" + min);
    }
}
```

### 3️⃣ 重點解析

*   **程式架構：** 程式包含定義陣列、處理空陣列情況、初始化最大值和最小值、遍歷陣列進行比較和更新、最後印出結果。
*   **初始化策略：** 找到最大值和最小值的關鍵在於如何初始化。一個安全的做法是將陣列的第一個元素同時設定為目前的 `max` 和 `min`。這樣做的好處是，即使陣列只有一個元素，結果也是正確的；並且可以確保初始值來自於陣列本身，避免使用無限大/小或假定範圍可能導致的錯誤。
*   **陣列遍歷：** 使用一個簡單的 `for` 迴圈從陣列的*第二個*元素開始遍歷 (`i` 從 1 開始)，直到陣列結束。
*   **比較與更新：** 在迴圈的每一次迭代中，將當前元素 `numbers[i]` 與目前的 `max` 和 `min` 進行比較。如果 `numbers[i]` 大於 `max`，則更新 `max = numbers[i]`；如果 `numbers[i]` 小於 `min`，則更新 `min = numbers[i]`。
*   **邊界處理：** 在遍歷之前，先檢查陣列是否為空 (`numbers.length == 0`) 是很重要的。如果陣列是空的，嘗試訪問 `numbers[0]` 會拋出 `ArrayIndexOutOfBoundsException`。
*   **語法選擇：** `for` 迴圈非常適合遍歷已知長度的陣列。`if` 語句用於條件判斷和更新。
*   **陷阱/錯誤：**
    *   未處理空陣列的情況。
    *   初始化 `max` 為 0 或一個很小的數，`min` 為一個很大的數。如果陣列只包含負數（例如 `{-5, -10}`），初始化 `max = 0` 會得到錯誤的最大值 0。如果陣列只包含正數（例如 `{5, 10}`），初始化 `min` 為 `Integer.MAX_VALUE` 以外的一個隨機大數可能導致錯誤。將 `max` 和 `min` 都初始化為第一個元素是最健壯的方法。
    *   遍歷從索引 0 開始，但在迴圈內部將 `max` 和 `min` 與 `numbers[0]` 比較，這是多餘的比較。從索引 1 開始比較更有效率。

---

### 1️⃣ 題目說明（請以清楚的段落說明邏輯）

請撰寫一支 Java 程式，使用氣泡排序（Bubble Sort）演算法將一個給定整數陣列按升序排列。氣泡排序是一種簡單的排序演算法，它重複地走訪過要排序的數列，一次比較兩個元素，如果他們的順序錯誤就把他們交換過來。走訪數列的工作是重複地進行直到沒有再需要交換，也就是說該數列已經排序完成。

這個題目考驗使用者對基本排序演算法的理解和實現能力，特別是巢狀迴圈的應用以及元素交換的操作。

#### 範例輸入：

給定陣列：`[64, 34, 25, 12, 22, 11, 90]`

#### 預期輸出：

排序後的陣列：`[11, 12, 22, 25, 34, 64, 90]`

### 2️⃣ Java 解答程式碼

```java
import java.util.Arrays; // 引入 Arrays 類別以便於印出陣列

public class BubbleSort {
    public static void main(String[] args) {
        // 定義一個整數陣列
        int[] arr = {64, 34, 25, 12, 22, 11, 90};

        System.out.println("原始陣列：" + Arrays.toString(arr));

        // 氣泡排序
        int n = arr.length;
        boolean swapped; // 優化：如果某一趟沒有發生交換，表示陣列已經有序，可以提前結束

        // 外層迴圈控制趟數
        // n-1 趟足以保證排序完成
        for (int i = 0; i < n - 1; i++) {
            swapped = false; // 每趟開始前重設標誌

            // 內層迴圈進行比較和交換
            // j < n - 1 - i：每趟結束，最大的元素會被「冒泡」到最後，所以下一趟需要比較到陣列的範圍減少
            for (int j = 0; j < n - 1 - i; j++) {
                // 如果當前元素比下一個元素大，就交換它們
                if (arr[j] > arr[j + 1]) {
                    // 交換 arr[j] 和 arr[j+1]
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true; // 發生了交換
                }
            }

            // 如果這一趟沒有發生任何交換，表示陣列已經排序完成
            if (!swapped) {
                break; // 提前結束外層迴圈
            }
        }

        System.out.println("排序後的陣列：" + Arrays.toString(arr));
    }
}
```

### 3️⃣ 重點解析

*   **程式架構：** 程式包含定義陣列、使用巢狀迴圈實現氣泡排序邏輯，最後印出排序後的陣列。
*   **氣泡排序原理：** 氣泡排序的核心是透過重複比較相鄰元素並進行交換，將較大的元素逐步「冒泡」到陣列的末尾。
*   **巢狀迴圈：**
    *   外層迴圈 `for (int i = 0; i < n - 1; i++)` 控制總共需要進行多少趟排序。對於 `n` 個元素的陣列，最多需要 `n-1` 趟就能完成排序。
    *   內層迴圈 `for (int j = 0; j < n - 1 - i; j++)` 負責在每一趟中遍歷未排序的部分，比較相鄰元素並進行交換。`n - 1 - i` 是因為在第 `i` 趟結束後，最後 `i` 個元素已經是正確的順序，無需再比較。
*   **元素交換：** 當發現 `arr[j] > arr[j + 1]` 時，表示這兩個元素的順序錯誤，需要交換。交換兩個變數的值需要一個暫存變數 `temp` 來實現：先將 `arr[j]` 的值存到 `temp`，然後將 `arr[j+1]` 的值賦給 `arr[j]`，最後將 `temp` 的值賦給 `arr[j+1]`。
*   **優化：** 加入 `boolean swapped` 旗標是一個常見的優化。如果在某一趟內層迴圈中沒有發生任何交換，這意味著陣列已經是完全有序的，無需再進行後續的趟數，可以直接 `break` 外層迴圈，提高效率。
*   **語法選擇：** 巢狀 `for` 迴圈是實現氣泡排序的標準方式。`if` 語句用於判斷是否需要交換。暫存變數是實現交換的必要工具。
*   **陷阱/錯誤：**
    *   內層迴圈的範圍計算錯誤 (`j < n - 1` 而非 `j < n - 1 - i`)，導致不必要的比較。
    *   交換邏輯錯誤，可能導致元素值丟失。
    *   未實現優化標誌，導致即使陣列已經有序，也會執行完所有趟數。

---

### 1️⃣ 題目說明（請以清楚的段落說明邏輯）

請撰寫一支 Java 程式，交換兩個整數變數 `a` 和 `b` 的值，但**不允許使用額外的第三個變數**來作為暫存空間。

這個題目考驗使用者對基本數學運算或位元運算的理解，以及如何巧妙地利用現有的變數來完成值的交換。

#### 範例輸入：

初始變數值：
a = 10
b = 5

#### 預期輸出：

交換後變數值：
a = 5
b = 10

### 2️⃣ Java 解答程式碼

```java
public class SwapWithoutTemp {
    public static void main(String[] args) {
        int a = 10;
        int b = 5;

        System.out.println("交換前：a = " + a + ", b = " + b);

        // 使用數學運算來交換值
        // 注意：這種方法在數字過大時可能導致溢位，但對於一般整數範圍是有效的。
        a = a + b; // a 現在是原始 a 和 b 的和 (10 + 5 = 15)
        b = a - b; // b 現在是 (原始 a + 原始 b) - 原始 b = 原始 a (15 - 5 = 10)
        a = a - b; // a 現在是 (原始 a + 原始 b) - 原始 a = 原始 b (15 - 10 = 5)

        // 另一種更安全的位元運算方法 (使用 XOR ^)
        /*
        a = a ^ b; // a = 原始a ^ 原始b
        b = a ^ b; // b = (原始a ^ 原始b) ^ 原始b = 原始a
        a = a ^ b; // a = (原始a ^ 原始b) ^ 原始a = 原始b
        */

        System.out.println("交換後：a = " + a + ", b = " + b);
    }
}
```

### 3️⃣ 重點解析

*   **程式架構：** 程式包含初始化兩個變數、執行交換邏輯、最後印出交換後的變數值。
*   **數學運算交換法：**
    1.  `a = a + b;`：將 `a` 更新為原始 `a` 與 `b` 的和。此時 `a` 暫存了兩個原始值的總和。
    2.  `b = a - b;`：由於此時的 `a` 是原始 `a + b`，用它減去原始 `b`，結果就是原始的 `a`。這樣就將原始 `a` 的值賦給了 `b`。
    3.  `a = a - b;`：此時的 `a` 仍然是原始 `a + b`，而 `b` 已經是原始 `a` 的值。用此時的 `a` 減去此時的 `b`，結果就是原始的 `b`。這樣就將原始 `b` 的值賦給了 `a`。
*   **位元運算交換法 (XOR)：**
    1.  `a = a ^ b;`：將 `a` 更新為原始 `a` 與 `b` 的 XOR 結果。
    2.  `b = a ^ b;`：由於 XOR 的性質 `(x ^ y) ^ y = x`，用此時的 `a` (`原始a ^ 原始b`) 與原始 `b` 進行 XOR，結果就是原始 `a`。這樣就將原始 `a` 的值賦給了 `b`。
    3.  `a = a ^ b;`：由於 XOR 的性質 `(x ^ y) ^ x = y`，用此時的 `a` (`原始a ^ 原始b`) 與此時的 `b` (`原始a`) 進行 XOR，結果就是原始 `b`。這樣就將原始 `b` 的值賦給了 `a`。
*   **選擇理由：** 數學運算方法直觀易懂，適合初學者。位元運算方法更為底層且在整數範圍內不會有溢位問題（除非是資料類型本身的上下限），通常被認為是更強健的選擇。在面試中兩種方法都能體現解決問題的能力，但位元運算方法可能更令人印象深刻。
*   **陷阱/錯誤：**
    *   數學運算方法：如果 `a` 和 `b` 的值非常大，相加 `a + b` 可能導致整數溢位，從而得到錯誤的結果。位元運算則沒有這個問題。
    *   對於非數字類型（如字串），這兩種方法都不適用。

---

希望這些詳細的教學內容對您和學習者有所幫助！