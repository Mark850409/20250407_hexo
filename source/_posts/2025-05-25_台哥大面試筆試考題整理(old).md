---
title: 後端開發面試準備筆記
date: 2024-07-26T12:00:00.000Z
tags:
- SQL
- Web Security
- RESTful API
- HTTP
- 資料庫正規化
- Java
- Spring Boot
- 垃圾回收
- 物件導向
- JavaScript
categories:
- 後端開發
- 資料庫
- Web技術
- Java
- JavaScript
---

# 一、SQL 語法重點整理

## 常用語法與說明

### 📌 SELECT + WHERE + ORDER BY
- 用於查詢資料、條件過濾、排序結果

#### 範例：
```sql
SELECT name, age FROM users WHERE age > 30 ORDER BY age DESC;
```

#### 解說：
- 查詢 `users` 表中，年齡 `age` 大於 30 的所有使用者。
- `SELECT name, age` 指定要取得的欄位是 `name` 和 `age`。
- `FROM users` 指定資料來源是 `users` 表。
- `WHERE age > 30` 設定過濾條件，只選擇 `age` 欄位值大於 30 的列。
- `ORDER BY age DESC` 對結果集按照 `age` 欄位進行排序，`DESC` 表示遞減排序（從大到小），`ASC` 表示遞增排序（從小到大，為預設）。

---

### 📌 JOIN（INNER / LEFT / RIGHT / FULL）
- 用於將兩個或多個表格基於相關列連接起來，從中查詢數據。

#### 範例（INNER JOIN）：
```sql
SELECT users.name, orders.order_id
FROM users
INNER JOIN orders ON users.user_id = orders.user_id;
```

#### 解說：
- 查出所有有訂單的使用者姓名及他們的訂單 ID。
- `INNER JOIN` 連接 `users` 表和 `orders` 表。
- `ON users.user_id = orders.user_id` 指定連接條件，即當兩個表的 `user_id` 欄位值相等時，將這些列合併。
- `INNER JOIN` 只會回傳在兩個表中都找到匹配記錄的列。

#### 範例（LEFT JOIN）：
```sql
SELECT users.name, orders.order_id
FROM users
LEFT JOIN orders ON users.user_id = orders.user_id;
```

#### 解說：
- 查出所有使用者姓名，以及他們擁有的訂單 ID。
- `LEFT JOIN` 連接 `users` 表 (左表) 和 `orders` 表 (右表)。
- `ON users.user_id = orders.user_id` 指定連接條件。
- `LEFT JOIN` 會回傳左表 (`users`) 中的所有記錄。如果右表 (`orders`) 中沒有匹配的記錄，則右表對應的欄位（`orders.order_id`）會顯示為 `NULL`。

#### 範例（RIGHT JOIN）：
```sql
SELECT users.name, orders.order_id
FROM users
RIGHT JOIN orders ON users.user_id = orders.user_id;
```

#### 解說：
- 查出所有訂單 ID，以及擁有這些訂單的使用者姓名。
- `RIGHT JOIN` 連接 `users` 表 (左表) 和 `orders` 表 (右表)。
- `ON users.user_id = orders.user_id` 指定連接條件。
- `RIGHT JOIN` 會回傳右表 (`orders`) 中的所有記錄。如果左表 (`users`) 中沒有匹配的記錄，則左表對應的欄位（`users.name`）會顯示為 `NULL`。

#### 範例（FULL JOIN）：
```sql
SELECT users.name, orders.order_id
FROM users
FULL OUTER JOIN orders ON users.user_id = orders.user_id;
```

#### 解說：
- 查出所有使用者姓名和所有訂單 ID，無論它們是否在另一個表中有匹配的記錄。
- `FULL OUTER JOIN` (或 `FULL JOIN`) 會回傳左表 (`users`) 和右表 (`orders`) 中的所有記錄。如果某行在另一個表中沒有匹配項，則另一表對應的欄位會顯示為 `NULL`。

---

### 📌 GROUP BY + HAVING
- `GROUP BY` 用於將結果集按照一個或多個欄位的值分組。
- `HAVING` 用於在分組後，過濾符合特定條件的分組。

#### 範例：
```sql
SELECT department_id, COUNT(*) AS employee_count
FROM employees
GROUP BY department_id
HAVING COUNT(*) > 5;
```

#### 解說：
- 統計每個部門的員工數量，並只顯示員工數量大於 5 的部門。
- `FROM employees` 從 `employees` 表獲取數據。
- `GROUP BY department_id` 按照 `department_id` 欄位將員工分組。
- `SELECT department_id, COUNT(*) AS employee_count` 選取部門 ID 和使用聚合函數 `COUNT(*)` 計算每個組的員工數量，並將其命名為 `employee_count`。
- `HAVING COUNT(*) > 5` 在分組後應用條件，只保留員工數量 (`COUNT(*)`) 大於 5 的那些組。注意 `HAVING` 用於過濾分組，而 `WHERE` 用於過濾行。

---

### 📌 LIMIT
- 用於限制查詢結果集的行數。常用於分頁或獲取頂部/底部 N 條記錄。

#### 範例：
```sql
SELECT * FROM products ORDER BY price DESC LIMIT 10;
```

#### 解說：
- 查詢價格最高的 10 件商品的所有欄位信息。
- `FROM products` 從 `products` 表獲取數據。
- `ORDER BY price DESC` 按照價格遞減排序。
- `LIMIT 10` 限制結果集只回傳前 10 行。
- 不同的資料庫系統可能有不同的語法，例如 SQL Server 使用 `TOP`，Oracle 使用 `ROWNUM`。

#### 範例（分頁 - MySQL/PostgreSQL）：
```sql
SELECT * FROM users ORDER BY user_id LIMIT 10 OFFSET 20;
```

#### 解說：
- 查詢 `users` 表中，按照 user_id 排序後，從第 21 條記錄開始的 10 條記錄 (即第 21 到 30 條記錄)。
- `LIMIT 10` 表示最多回傳 10 條記錄。
- `OFFSET 20` 表示跳過前面的 20 條記錄。

---

### 📌 子查詢（Subquery）
- 嵌套在另一個 SQL 語句（SELECT, INSERT, UPDATE, DELETE）內部的查詢。

#### 範例（作為 WHERE 條件）：
```sql
SELECT product_name, price
FROM products
WHERE price > (SELECT AVG(price) FROM products);
```

#### 解說：
- 查詢價格高於所有產品平均價格的產品名稱和價格。
- 內層子查詢 `(SELECT AVG(price) FROM products)` 計算所有產品的平均價格。
- 外層查詢使用 `WHERE price > (...)` 條件來篩選價格高於子查詢結果的產品。

#### 範例（作為 FROM 子句 - 衍生表格）：
```sql
SELECT department_name, employee_count
FROM (
    SELECT department_id, COUNT(*) AS employee_count
    FROM employees
    GROUP BY department_id
) AS dept_counts
JOIN departments ON dept_counts.department_id = departments.department_id;
```

#### 解說：
- 查詢每個部門的員工數量，並顯示部門名稱。
- 內層子查詢創建一個衍生表格 `dept_counts`，包含每個部門的 ID 和員工數量。
- 外層查詢將此衍生表格與 `departments` 表連接，以獲取部門名稱。

---

### 📌 COUNT(), AVG(), SUM(), MAX(), MIN() 聚合函數
- 用於對一組值執行計算並回傳單個值。通常與 `GROUP BY` 一起使用。

#### 範例：
```sql
SELECT
    COUNT(*) AS total_employees,
    AVG(salary) AS average_salary,
    SUM(salary) AS total_payroll,
    MAX(salary) AS max_salary,
    MIN(salary) AS min_salary
FROM employees;
```

#### 解說：
- 查詢 `employees` 表中所有員工的總人數、平均薪資、總薪資、最高薪資和最低薪資。
- `COUNT(*)` 計算行數。
- `AVG(salary)` 計算 `salary` 欄位的平均值。
- `SUM(salary)` 計算 `salary` 欄位的總和。
- `MAX(salary)` 找出 `salary` 欄位的最大值。
- `MIN(salary)` 找出 `salary` 欄位的最小值。
- 這些函數可以單獨使用，也可以與 `GROUP BY` 一起使用來計算每個組的聚合值。

#### 範例（與 GROUP BY 結合）：
```sql
SELECT department_id, AVG(salary) AS average_department_salary
FROM employees
GROUP BY department_id;
```

#### 解說：
- 查詢每個部門的平均薪資。
- `GROUP BY department_id` 將員工按部門分組。
- `AVG(salary)` 計算每個部門組內的平均薪資。

---

### 📌 資料更新/刪除語法（UPDATE, DELETE）
- `UPDATE` 用於修改表格中現有的數據。
- `DELETE` 用於從表格中刪除現有的記錄。

#### 範例（UPDATE 單行）：
```sql
UPDATE users
SET email = 'new.email@example.com', updated_at = CURRENT_TIMESTAMP
WHERE user_id = 123;
```

#### 解說：
- 更新 `users` 表中 `user_id` 為 123 的那一行記錄。
- `SET` 指定要修改的欄位及其新值。可以同時更新多個欄位，用逗號分隔。
- `WHERE user_id = 123` 設定條件，只更新符合此條件的行。**注意：如果省略 `WHERE` 子句，將會更新表中的所有記錄！**

#### 範例（UPDATE 多行）：
```sql
UPDATE products
SET price = price * 1.10
WHERE category = 'Electronics';
```

#### 解說：
- 將 `products` 表中所有類別為 'Electronics' 的商品的價格提高 10%。
- `WHERE category = 'Electronics'` 條件篩選出要更新的記錄。

#### 範例（DELETE 單行）：
```sql
DELETE FROM orders
WHERE order_id = 456;
```

#### 解說：
- 刪除 `orders` 表中 `order_id` 為 456 的那一行記錄。
- `WHERE order_id = 456` 設定條件，只刪除符合此條件的行。**注意：如果省略 `WHERE` 子句，將會刪除表中的所有記錄！**

#### 範例（DELETE 多行）：
```sql
DELETE FROM users
WHERE status = 'Inactive';
```

#### 解說：
- 刪除 `users` 表中所有狀態為 'Inactive' 的記錄。

---

## 常考觀念 Q&A
(Copied from user's input)

### Q1：什麼是 Web 安全性？在開發中為何重要？
- 保護網站及應用程式免受惡意攻擊。
- 確保資料的機密性、完整性與可用性。
- 保護使用者隱私及信任。
- 避免潛在的法律風險與名譽損失。
- 🗣️口語化回答：Web 資安就是確保你的網站不會被駭客入侵、資料被偷或破壞，保護使用者很重要的。

### Q2：請說明 SQL Injection（隱碼攻擊）是什麼？如何防範？
- 攻擊者透過在使用者輸入欄位注入惡意的 SQL 語句。
- 利用程式未對使用者輸入進行充分過濾，導致惡意 SQL 語句被資料庫執行。
- 可能導致資料洩漏、竄改甚至刪除。
- 防範方法：使用參數化查詢（Prepared Statements）或ORM 框架、避免使用字串拼接 SQL 語句、對所有使用者輸入進行嚴格的驗證與過濾。
- 🗣️口語化回答：駭客在輸入框偷塞資料庫指令，利用程式漏洞讓資料庫執行。最簡單的防範就是用參數化查詢，不要直接把輸入跟 SQL 連起來。

### Q3：什麼是 XSS（跨站腳本攻擊）？有幾種？如何防範？
- 攻擊者將惡意腳本注入到網頁中，當其他使用者瀏覽該網頁時，惡意腳本就會在他們的瀏覽器上執行。
- 類型：儲存型 XSS（Stored XSS）、反射型 XSS（Reflected XSS）、DOM 型 XSS。
- 可能導致竊取 Cookie、Session、偽造請求等。
- 防範方法：對使用者輸入進行驗證與清理；在輸出到網頁前對所有不可信任的資料進行適當的 HTML 實體編碼（Output Encoding）。
- 🗣️口語化回答：就是駭客把惡意程式碼藏在網頁裡，當你打開網頁時程式碼就在你瀏覽器跑起來了。防範方法是在顯示使用者輸入的內容時，把一些特殊符號轉掉。

### Q4：什麼是 CSRF（跨站請求偽造）？如何防範？
- 攻擊者誘騙使用者點擊連結或圖片，利用使用者已登入的身份，在使用者不知情的情況下發送偽造的請求到目標網站。
- 目標網站會認為這是使用者自己的合法請求並執行。
- 防範方法：使用 CSRF Token（伺服器生成一個隨機 token 放入表單或 header，客戶端提交時帶回驗證）、檢查 Referer Header、使用 SameSite Cookie 屬性。
- 🗣️口語化回答：駭客騙你點一個連結，利用你網站登入中的狀態，去做一些你沒授權的事情。可以用一個只有你知道的特殊驗證碼（CSRF token）來防。

## 重要語法或術語
(Copied from user's input)
- SQL Injection
- XSS (Cross-Site Scripting)
- CSRF (Cross-Site Request Forgery)
- HTTPS / SSL/TLS
- OWASP Top 10
- Input Validation
- Output Encoding
- Parameterized Query
- CSRF Token
- Authentication
- Authorization
- Session Management

## 面試常見問法與回答
(Copied from user's input)

### Q1：你在過去的專案中，是如何考慮和實作資安的？
- Q：你在過去的專案中，是如何考慮和實作資安的？
- 針對使用者輸入，實作嚴格的驗證與清理，防止常見的注入攻擊。
- 對於資料庫操作，全部使用參數化查詢或 ORM，避免 SQL Injection。
- 開發 RESTful API 時，實作適當的身份驗證（Authentication）和權限控管（Authorization）。
- 在敏感操作上，實作 CSRF 防護（如使用框架提供的 CSRF Token）。
- 網站部署使用 HTTPS，加密傳輸過程。
- 🗣️口語化回答：主要是對所有使用者輸入都檢查和過濾，資料庫操作用安全的寫法。前後端溝通走 HTTPS，敏感操作會加上 CSRF 防護。

### Q2：如果發現專案有資安漏洞，你的處理流程是什麼？
- Q：如果發現專案有資安漏洞，你的處理流程是什麼？
- 確認漏洞的存在與影響範圍，判斷嚴重程度。
- 立刻制定修補方案並盡快實作。
- 修補完成後進行嚴格測試，確保漏洞確實被修補且未引入新的問題。
- 視情況通知相關人員（團隊、主管、使用者）。
- 檢討原因，並將防範措施納入開發流程或code review規範。
- 🗣️口語化回答：先確認漏洞，馬上修好，然後測試確保修好了，最後討論怎麼避免下次再發生。

---

# 二、RESTful API

## 重點摘要
(Copied from user's input)
RESTful API 是一種設計 Web 服務介面的架構風格，基於 HTTP 協定，強調以「資源」為中心，並透過標準的 HTTP 方法（GET, POST, PUT, DELETE 等）來操作這些資源。它的主要優點是架構清晰、易於理解和擴展，無狀態性使其 scalable，是目前主流的 API 設計方式，廣泛應用於前後端分離、微服務等場景。

## 定義
(Copied from user's input)
- REST：Representational State Transfer 的縮寫，一種用於分散式系統的架構風格。
- RESTful API：遵循 REST 原則設計的 Web API。
- 核心原則：
    - **資源 (Resource)**：網路上的實體，用 URI (Uniform Resource Identifier) 表示，如 `/users`, `/products/123`。
    - **統一介面 (Uniform Interface)**：使用標準的 HTTP 方法操作資源。
    - **無狀態 (Stateless)**：伺服器不保留客戶端狀態，每個請求都包含處理所需的所有資訊。
    - **客戶端-伺服器 (Client-Server)**：關注點分離，客戶端和伺服器獨立發展。
    - **可快取 (Cacheable)**：客戶端可以快取伺服器的響應，提升效能。
    - **分層系統 (Layered System)**：伺服器和客戶端之間的通訊可以經過多個中間層。
    - **按需程式碼 (Code on Demand)**：伺服器可以暫時擴展或自訂客戶端的功能 (可選)。

## 常考觀念 Q&A
(Copied from user's input)

### Q1：什麼是 RESTful API？它和 SOAP 有什麼主要區別？
- RESTful API 是一種基於 HTTP 的架構風格，以資源為中心，輕量級且彈性高，常用於 Web 和行動應用。
- SOAP 是基於 XML 的協定，相對重量級，通常使用 WSDL 描述服務，常用於企業級應用或遺留系統。
- RESTful API 更依賴 HTTP 方法，SOAP 則使用 XML 信封。
- RESTful API 無狀態，SOAP 可以是有狀態的。
- 🗣️口語化回答：RESTful 就是一種用 HTTP 方法來操作「資源」的介面設計方式，比較輕巧好用。SOAP 比較老牌、重量級，通常用 XML 來傳資料。

### Q2：GET, POST, PUT, DELETE 這幾個 HTTP 方法在 RESTful API 中通常代表什麼操作？
- GET：用於獲取資源。
- POST：用於建立新的資源。
- PUT：用於完整更新資源。
- DELETE：用於刪除資源。
- 還有 PATCH：用於部分更新資源。
- 🗣️口語化回答：GET 就是查資料，POST 是新增一筆，PUT 是把一整筆資料換新的，DELETE 是刪掉。

### Q3：RESTful API 的「無狀態」是什麼意思？為什麼重要？
- 指伺服器不會在兩次請求之間保留客戶端的任何狀態資訊。每個請求都必須包含處理該請求所需的所有資訊。
- 重要性：提高擴展性（Scaling），伺服器更容易分散到多台機器；提高可靠性，單個伺服器失敗不影響其他請求；簡化伺服器設計。
- 🗣️口語化回答：就是伺服器不會記住你上次做了什麼。每次請求都要告訴伺服器足夠的資訊讓它處理，這樣伺服器比較好擴展。

### Q4：什麼是冪等性 (Idempotence)？哪些 HTTP 方法是冪等的？
- 指對同一 URI 的同一請求執行多次，會產生相同的結果（儘管伺服器狀態可能改變）。
- 冪等方法：GET, PUT, DELETE, HEAD, OPTIONS。
- 非冪等方法：POST (多次 POST 同一數據可能建立多個資源)。PATCH 通常也非冪等，除非特別設計。
- 🗣️口語化回答：冪等就是重複發送同一個請求，產生的結果會是一樣的。像 GET、PUT、DELETE 都是，重複呼叫也不會出問題。

## 重要語法或術語
(Copied from user's input)
- REST
- Resource (資源)
- URI (Uniform Resource Identifier)
- Endpoint
- HTTP Methods (GET, POST, PUT, DELETE, PATCH)
- Stateless (無狀態)
- Idempotent (冪等性)
- HATEOAS (Hypermedia as the Engine of Application State) - 進階概念
- JSON / XML (資料格式)

## 面試常見問法與回答
(Copied from user's input)

### Q1：你在專案中是怎麼設計 RESTful API 的？請舉例說明一個資源的設計。
- Q：你在專案中是怎麼設計 RESTful API 的？請舉例說明一個資源的設計。
- 識別核心「資源」，通常用名詞表示，且常用複數 (e.g., `/users`, `/orders`)。
- 使用子資源表達關係 (e.g., `/users/{userId}/orders`)。
- 根據操作類型使用正確的 HTTP 方法 (GET 獲取、POST 建立、PUT 完整更新、DELETE 刪除)。
- 使用 HTTP Status Code 表示結果 (200 OK, 201 Created, 400 Bad Request, 404 Not Found, 500 Internal Server Error)。
- 例如：會員資源 (`/users`)。
    - `GET /users`：獲取所有會員列表。
    - `GET /users/{id}`：獲取特定 ID 的會員資料。
    - `POST /users`：新增會員。
    - `PUT /users/{id}`：完整更新特定 ID 會員資料。
    - `DELETE /users/{id}`：刪除特定 ID 會員。
- 🗣️口語化回答：我會先把系統裡的「東西」（資源）找出來，用像 `/users` 這樣名詞當網址。然後根據要做什麼動作，用對 GET/POST/PUT/DELETE 方法。

### Q2：如何在 RESTful API 中處理版本控制？
- Q：如何在 RESTful API 中處理版本控制？
- URL Path Versioning (e.g., `/v1/users`, `/v2/users`)：最直觀但修改 URI 會影響所有客戶端。
- Query Parameter Versioning (e.g., `/users?version=v1`)：對客戶端影響較小，但可能與其他參數混淆。
- Header Versioning (e.g., `Accept: application/vnd.myapp.v1+json`)：符合 REST 原則中透過 Header 進行內容協商，但客戶端實作稍複雜。
- 🗣️口語化回答：有幾種方法，最常見的是在網址裡加版本號，像是 `/v1/users`。或是放在 Header 裡，只是 Header 比較難測。

---

# 三、HTTP 基本結構與方法

## 重點摘要
(Copied from user's input)
HTTP (Hypertext Transfer Protocol) 是 Web 資料傳輸的基礎協定。理解 HTTP 的基本結構（請求與回應）以及常用的方法（GET, POST 等）是進行 Web 開發的根本。它定義了客戶端（瀏覽器或其他應用）如何向伺服器發送請求，以及伺服器如何回傳響應，包括狀態碼表示處理結果。

## 定義
(Copied from user's input)
- HTTP：超文本傳輸協定，應用層協定，用於在客戶端和伺服器之間傳輸超文本（如 HTML）和其他資源。
- 請求-回應模型：客戶端發送請求給伺服器，伺服器處理後回傳回應。
- HTTP 請求 (Request) 的基本結構：
    - **起始行 (Start Line / Request Line)**：包含請求方法 (Method)、請求 URI 和 HTTP 版本。
    - **請求標頭 (Headers)**：提供關於請求、客戶端或資源的元數據，如 `Content-Type`, `User-Agent`, `Cookie` 等。
    - **請求體 (Body)**：包含請求的實際數據，例如 POST 請求提交的表單數據或 JSON 數據 (GET, HEAD 等請求通常沒有 Body)。
- HTTP 回應 (Response) 的基本結構：
    - **起始行 (Start Line / Status Line)**：包含 HTTP 版本、狀態碼 (Status Code) 和狀態文本 (Reason Phrase)。
    - **回應標頭 (Headers)**：提供關於回應、伺服器或資源的元數據，如 `Content-Type`, `Set-Cookie`, `Cache-Control` 等。
    - **回應體 (Body)**：包含伺服器回傳的實際數據，例如 HTML 頁面、JSON 資料、圖片等 (HEAD 請求通常沒有 Body)。
- 常見 HTTP 方法：GET, POST, PUT, DELETE, HEAD, OPTIONS, PATCH。
- 常見 HTTP 狀態碼：1xx (資訊)、2xx (成功)、3xx (重定向)、4xx (客戶端錯誤)、5xx (伺服器錯誤)。

## 常考觀念 Q&A
(Copied from user's input)

### Q1：請說明 HTTP Request 的三個主要組成部分。
- **起始行 (Start Line)**：包含請求方法 (GET/POST 等)、資源路徑 (URI) 和 HTTP 版本。
- **標頭 (Headers)**：提供額外的資訊，例如客戶端的類型、接受的內容格式、Cookies 等。
- **請求體 (Body)**：包含要發送給伺服器的實際數據，POST 或 PUT 請求通常有 Body。
- 🗣️口語化回答：主要就是最上面一行說明要做什麼（GET/POST）、找哪個網址，再來是一堆 Header 描述細節，最後是可能會有個 Body 放要送的資料。

### Q2：請說明 HTTP Response 的三個主要組成部分。
- **起始行 (Status Line)**：包含 HTTP 版本、一個數字的狀態碼 (Status Code) 和狀態文字說明。
- **標頭 (Headers)**：提供額外的資訊，例如回傳內容的類型、Cookie 設定、快取指示等。
- **回應體 (Body)**：包含伺服器回傳的主要內容，像是網頁內容、圖片或 JSON 資料。
- 🗣️口語化回答：跟 Request 類似，有第一行狀態碼（成功還是失敗），再來是一堆 Header 描述回傳內容，最後是 Body 放實際的網頁或資料。

### Q3：GET 和 POST 方法有什麼主要區別？請從多個角度說明。
- **傳送數據方式**：GET 將數據放在 URI 的 query string 中，POST 將數據放在請求體 (Request Body) 中。
- **安全性 (數據暴露)**：GET 數據顯示在 URL 中，可能被記錄在瀏覽器歷史或伺服器日誌，不適合傳輸敏感資訊；POST 數據在 Body 中，相對較隱私。
- **數據大小限制**：GET 受限於 URL 長度 (因瀏覽器和伺服器而異)，POST 沒有嚴格限制。
- **緩存 (Caching)**：GET 請求可以被瀏覽器緩存，POST 請求通常不會被緩存。
- **冪等性**：GET 是冪等的（重複請求結果一致），POST 不是冪等的。
- **用途**：GET 主要用於獲取數據，POST 主要用於提交數據以建立或修改資源。
- 🗣️口語化回答：GET 的資料顯示在網址上，POST 藏在內容裡。GET 比較適合拿資料，POST 適合送資料去新增或修改。GET 可以被快取和重複呼叫，POST 則通常不行。

### Q4：HTTP 狀態碼 200, 404, 500 各代表什麼意思？請再舉兩個常見的狀態碼並說明。
- **200 OK**：請求成功。
- **404 Not Found**：伺服器找不到請求的資源。
- **500 Internal Server Error**：伺服器在處理請求時發生了內部錯誤。
- **201 Created**：請求成功，並建立了一個新的資源 (常用於 POST 請求)。
- **400 Bad Request**：伺服器無法理解客戶端發送的請求，請求語法錯誤。
- **401 Unauthorized**：請求需要身份驗證，但使用者尚未提供憑證或憑證無效。
- **403 Forbidden**：伺服器理解請求，但拒絕執行（沒有權限）。
- **301 Moved Permanently**：資源被永久移動到新的位置，客戶端應更新其連結。
- 🗣️口語化回答：200 是成功，404 是找不到東西，500 是伺服器自己出錯了。還有 201 是新增成功，400 是你發的請求有問題。

## 重要語法或術語
(Copied from user's input)
- HTTP/1.1, HTTP/2
- HTTP Request
- HTTP Response
- HTTP Method (GET, POST, PUT, DELETE, etc.)
- Status Code (狀態碼)
- Headers (標頭)
- Body (內容)
- URI / URL
- Query String
- Idempotence (冪等性)
- Cache (快取)

## 面試常見問法與回答
(Copied from user's input)

### Q1：你在開發後端 API 時，如何根據業務邏輯回傳正確的 HTTP Status Code？
- Q：你在開發後端 API 時，如何根據業務邏輯回傳正確的 HTTP Status Code？
- 成功讀取：回傳 200 OK。
- 成功建立資源（如註冊會員）：回傳 201 Created。
- 成功刪除或修改（無內容回傳）：回傳 204 No Content。
- 客戶端請求數據格式錯誤、缺少必要參數等：回傳 400 Bad Request。
- 請求的資源找不到：回傳 404 Not Found。
- 使用者未登入或身份驗證失敗：回傳 401 Unauthorized。
- 使用者已登入但沒有權限執行操作：回傳 403 Forbidden。
- 伺服器內部發生未預期的錯誤：回傳 500 Internal Server Error。
- 🗣️口語化回答：根據處理結果回傳不同的狀態碼，像查到東西就給 200，找不到就 404，新增成功給 201，程式自己錯了就給 500。

### Q2：HTTP 是無狀態的，那 Session 是怎麼實現的？
- Q：HTTP 是無狀態的，那 Session 是怎麼實現的？
- Session 是在伺服器端儲存客戶端狀態的一種方式。
- 為了讓伺服器「識別」是哪個客戶端的請求，通常會在客戶端和伺服器之間交換一個 Session ID。
- 常見做法是伺服器在使用者首次訪問或登入成功後，生成一個唯一的 Session ID，並將其透過 `Set-Cookie` Header 發送給客戶端。
- 客戶端（瀏覽器）收到後會將 Session ID 存儲在 Cookie 中。
- 之後客戶端每次發送請求給同一個網站時，都會自動在 `Cookie` Header 中帶上這個 Session ID。
- 伺服器收到請求後，根據 Cookie 中的 Session ID 找到對應的伺服器端 Session 數據，從而恢復客戶端的狀態。
- 🗣️口語化回答：雖然 HTTP 本身沒記憶，但我們可以用 Cookie 來記住使用者。伺服器給客戶端一個 Session ID 存在 Cookie 裡，之後客戶端每次來都帶著這個 ID，伺服器就知道你是誰了。

---

# 四、Request / Response 結構與用途

## 重點摘要
(Copied from user's input)
深入了解 HTTP Request 和 Response 的詳細結構，特別是 Header 和 Body 的具體內容及其用途。這對於 API 開發、除錯、了解前後端溝通機制、甚至資安分析都非常關鍵。理解 Request 攜帶了什麼資訊給伺服器，以及 Response 又回傳了哪些資訊給客戶端，是全端工程師的必備知識。

## 定義
(Copied from user's input)
- Request 結構：
    - Start Line: Method URL HTTP/Version
    - Headers: 鍵值對，提供請求的元數據，如 `Host`, `User-Agent`, `Accept`, `Content-Type`, `Content-Length`, `Authorization`, `Cookie` 等。
    - Body: 攜帶 POST/PUT 等方法實際要提交的數據。
- Response 結構：
    - Start Line: HTTP/Version Status Code Reason Phrase
    - Headers: 鍵值對，提供回應的元數據，如 `Content-Type`, `Content-Length`, `Server`, `Set-Cookie`, `Cache-Control` 等。
    - Body: 攜帶伺服器回傳的實際數據，如 HTML、JSON、圖片等。
- 用途：
    - Request：客戶端告知伺服器要做什麼 (Method)、對哪個資源做 (URI)、傳遞什麼數據 (Body)、以及關於客戶端或請求的其他資訊 (Headers)。
    - Response：伺服器告知客戶端請求處理的結果 (Status Code)、回傳的數據內容 (Body)、以及關於伺服器或回應的其他資訊 (Headers)。

## 常考觀念 Q&A
(Copied from user's input)

### Q1：Request Headers 中常見的 `Content-Type` 和 `Accept` 有什麼不同？
- `Content-Type` (在 Request Body 存在時使用)：告知伺服器 **請求體** 中的數據是什麼格式。例如：`application/json`, `application/x-www-form-urlencoded`。
- `Accept`：告知伺服器 **客戶端期望接收** 的回應數據是什麼格式。例如：`application/json`, `text/html`, `image/png`。伺服器會嘗試回傳客戶端可接受的格式。
- 🗣️口語化回答：`Content-Type` 是告訴伺服器「我給你的資料」是什麼格式，`Accept` 是告訴伺服器「我想要你給我的資料」是什麼格式。

### Q2：Response Headers 中 `Set-Cookie` 的用途是什麼？
- `Set-Cookie` 是伺服器在 Response Header 中發送給客戶端的一個指令。
- 用於指示客戶端（通常是瀏覽器）在本地儲存一個 Cookie。
- 儲存後，客戶端在之後發送給同一個網站的 Request 中，會自動在 `Cookie` Header 中帶上這個 Cookie。
- 常見用途是儲存 Session ID、使用者偏好設定等狀態資訊。
- 🗣️口語化回答：這是伺服器告訴你的瀏覽器「請幫我存一個 Cookie 起來」，這樣你下次來的時候瀏覽器就會把這個 Cookie 自動帶給我，我就知道你是誰了。

### Q3：Request Body 主要用於哪些 HTTP 方法？為什麼？
- 主要用於 POST, PUT, PATCH 方法。
- GET 和 HEAD 方法理論上也可以有 Body，但語義上不建議，且多數伺服器會忽略。
- 原因：POST, PUT, PATCH 用於向伺服器提交數據以建立或修改資源，這些數據通常較大或包含敏感資訊，不適合放在 URL 中傳輸，故放在 Body 中。
- 🗣️口語化回答：主要是 POST 和 PUT，因為這些方法是要送比較多或比較私密的資料給伺服器，放在 Body 裡比較適合。

## 重要語法或術語
(Copied from user's input)
- Request Header
- Response Header
- Request Body
- Response Body
- Content-Type
- Accept
- Authorization
- Cookie
- Set-Cookie
- User-Agent
- Referer
- Location
- Cache-Control

## 面試常見問法與回答
(Copied from user's input)

### Q1：你在開發中，如何從 HTTP Request 中取得前端傳來的 JSON 資料？
- Q：你在開發中，如何從 HTTP Request 中取得前端傳來的 JSON 資料？
- 確保前端在 Request Headers 中設置 `Content-Type: application/json`。
- 在後端程式中，讀取 Request Body 的內容。
- 使用 JSON 解析函式庫（如 Jackson, Gson）或框架提供的機制（如 Spring 的 `@RequestBody` 註解）。
- 將解析後的 JSON 數據映射到後端對應的 Java 物件（POJO）。
- 🗣️口語化回答：我會確保前端送資料時有說這是 JSON，然後在後端讀取它送過來的內容，用程式把 JSON 字串轉成我們可以用的物件。在 Spring Boot 裡用 `@RequestBody` 很方便。

### Q2：你在回傳 HTTP Response 給前端時，通常會設定哪些重要的 Header？
- Q：你在回傳 HTTP Response 給前端時，通常會設定哪些重要的 Header？
- `Content-Type`：指定回傳內容的格式，例如 `application/json` (最常用於 API) 或 `text/html`。
- `Content-Length`：指定回傳 Body 的大小（雖然框架通常會自動設定）。
- `Status Code`：這是 Status Line 的一部分，但非常關鍵，表示請求的處理結果。
- `Set-Cookie`：如果需要讓前端儲存 Cookie (如 Session ID或 Token)。
- `Cache-Control`：控制瀏覽器或代理伺服器如何快取這個回應。
- 🗣️口語化回答：一定會設 `Content-Type` 告訴前端資料是什麼格式，還有狀態碼（200, 404 之類的）。如果需要前端存 Cookie 或處理快取，也會設定相關的 Header。

---

# 五、資料庫設計與正規化

## 正規化說明（1NF～3NF）
(Copied from user's input)
- 1NF：每個表格必須有主鍵，每個欄位的值都必須是原子的（不可再分割）。
- 2NF：滿足 1NF，且所有非主鍵欄位都必須完全依賴於主鍵（針對複合主鍵）。
- 3NF：滿足 2NF，且所有非主鍵欄位不能透過其他非主鍵欄位來依賴主鍵（消除傳遞依賴）。

## 定義
(Copied from user's input - reordered for flow)
- 資料正規化：一個系統化的過程，用於設計關聯式資料庫的結構，以減少資料冗餘和提高資料完整性。
- 目的：
    - 減少資料的重複存儲。
    - 避免更新異常 (Insertion, Update, Deletion Anomaly)。
    - 提高資料的一致性。
    - 使資料庫結構更易於維護和修改。
- 更新異常：
    - 插入異常 (Insertion Anomaly)：無法在不輸入某個相關資訊的情況下插入新資料。
    - 更新異常 (Update Anomaly)：修改一個資料需要在多處進行，否則會導致不一致。
    - 刪除異常 (Deletion Anomaly)：刪除某個資料時，不小心刪除了其他不應被刪除的相關資訊。
- 正規形式 (Normal Forms, NF)：衡量資料庫表格正規化程度的標準，越高階的正規形式要求越嚴格。（參見上方 1NF～3NF 說明）
- BCNF (Boyce-Codd Normal Form)：比 3NF 更嚴格的形式，處理主鍵的一部分依賴於其他欄位的情況。

## 常考觀念 Q&A
(Copied from user's input)

### Q1：什麼是資料正規化？它的主要目的是什麼？
- 資料正規化是一種設計資料庫表格結構的方法。
- 主要目的是減少資料重複（冗餘）和避免資料更新時發生的異常（插入、修改、刪除異常）。
- 確保資料的一致性與完整性。
- 🗣️口語化回答：就是把資料庫表格整理乾淨，減少重複放一樣的東西，讓資料更一致，修改或刪除時比較不會出錯。

### Q2：請用簡單的話說明 1NF, 2NF, 3NF 各是什麼？
- 1NF：表格裡的每個欄位值都不能再被分割了，而且要有個唯一識別這筆資料的主鍵。
- 2NF：符合 1NF，而且如果你的主鍵是好幾個欄位組成的（複合主鍵），那其他非主鍵的欄位都必須完全依賴這個複合主鍵，不能只依賴其中一部分。
- 3NF：符合 2NF，而且非主鍵欄位不能依賴於其他的非主鍵欄位。
- 🗣️口語化回答：1NF 就是欄位值不可分，要有主鍵；2NF 是非主鍵要完全依賴主鍵（對複合主鍵來說）；3NF 是非主鍵之間不能互相依賴。

### Q3：正規化有哪些優點和缺點？
- 優點：
    - 減少資料冗餘，節省存儲空間。
    - 提高資料一致性，修改資料時只需要改一處。
    - 避免更新異常，資料完整性更好。
    - 結構更清晰，易於維護和擴展。
- 缺點：
    - 查詢時可能需要 JOIN 更多的表格，增加查詢的複雜度和執行時間。
    - 有時為了高度正規化會拆分出很多小表格。
- 🗣️口語化回答：好處是資料比較乾淨、不容易出錯、省空間，也好維護。但缺點是查資料時可能會需要把很多小表格 JOIN 起來，比較慢。

### Q4：什麼是反正規化 (Denormalization)？為什麼會使用它？
- 反正規化是指在已正規化的資料庫中，為了提高讀取效能，有意地引入一些冗餘數據或將表格合併。
- 目的：減少查詢時所需的 JOIN 操作，加速資料檢索。
- 使用時機：當正規化導致的 JOIN 操作成為查詢效能瓶頸，且讀取效能比寫入效能更關鍵時。
- 🗣️口語化回答：反正規化就是犧牲一點正規化原則（比如放一些重複資料），讓表格不要拆那麼散，這樣查詢資料時就不用 JOIN 那麼多表，速度會變快。通常是在發現效能瓶頸時才用。

## 重要語法或術語
(Copied from user's input)
- Normalization (正規化)
- Denormalization (反正規化)
- Redundancy (冗餘)
- Data Integrity (資料完整性)
- Insertion Anomaly (插入異常)
- Update Anomaly (更新異常)
- Deletion Anomaly (刪除異常)
- Normal Form (NF)
- 1NF, 2NF, 3NF, BCNF
- Primary Key (主鍵)
- Foreign Key (外部鍵)
- Dependency (依賴)
- JOIN (資料庫操作)

## 關聯設計情境範例
### 題目：設計會員與訂單資料表
(Copied from user's input)
應包含：
- users（會員）
- orders（訂單）
- products（商品）
- order_items（訂單明細）

### 建議表格關聯設計：
(Copied from user's input)
- users 1:N orders
- orders N:M products（透過 order_items）

#### 表格結構建議：

- `users` 表：
    - `user_id` (主鍵)
    - `username` (唯一)
    - `password_hash`
    - `email` (唯一)
    - `registration_date`
    - `address`
    - `phone`
    - ...其他會員信息

- `products` 表：
    - `product_id` (主鍵)
    - `product_name`
    - `description`
    - `price`
    - `stock_quantity`
    - ...其他商品信息

- `orders` 表：
    - `order_id` (主鍵)
    - `user_id` (外部鍵，參考 `users` 表的 `user_id`)
    - `order_date`
    - `total_amount`
    - `shipping_address`
    - `status` (e.g., Pending, Shipped, Delivered)
    - ...其他訂單總結信息

- `order_items` 表 (用於解決 orders 和 products 之間的 N:M 關係)：
    - `order_item_id` (主鍵，或者使用複合主鍵 `(order_id, product_id)`)
    - `order_id` (外部鍵，參考 `orders` 表的 `order_id`)
    - `product_id` (外部鍵，參考 `products` 表的 `product_id`)
    - `quantity` (該商品在此訂單中的數量)
    - `unit_price` (購買時的單價，因為商品價格可能會變動)
    - `subtotal` (quantity * unit_price)
    - ...其他訂單明細信息

#### 關聯性說明：
- `users` 和 `orders` 是一對多 (1:N) 關係：一個使用者可以有多個訂單，但每個訂單只屬於一個使用者。在 `orders` 表中使用 `user_id` 作為外部鍵指向 `users` 表。
- `orders` 和 `products` 是多對多 (N:M) 關係：一個訂單可以包含多種商品，一種商品也可以出現在多個訂單中。這種關係通過一個中間表 `order_items` 來實現。`order_items` 表中包含 `order_id` 和 `product_id` 作為外部鍵，同時也儲存該商品在特定訂單中的購買數量和單價等信息。

---

## 面試常見問法與回答
(Copied from user's input)

### Q1：你在設計資料庫 Schema 時，通常會正規化到哪個程度？為什麼？
- Q：你在設計資料庫 Schema 時，通常會正規化到哪個程度？為什麼？
- 通常會設計到至少 3NF。
- 原因是 3NF 已經能夠消除大部分常見的更新異常和冗餘，提供一個結構清晰且資料完整性較好的基礎。
- BCNF 雖然更嚴格，但在大多數業務場景下，3NF 已足夠，且過度正規化可能導致 JOIN 過多影響效能。
- 如果後續發現特定查詢存在嚴重效能問題，可能會針對該部分考慮進行反正規化。
- 🗣️口語化回答：我通常會正規化到 3NF。這樣大部分資料重複和更新的問題都能避免了，基礎會比較好。如果真的遇到效能瓶頸，才會考慮為了查詢速度做一些反正規化。

### Q2：請舉例說明一個你需要正規化的場景，以及正規化後的表格結構。
- Q：請舉例說明一個你需要正規化的場景，以及正規化後的表格結構。
- 假設有一個訂單表格 `Orders`，一開始包含了訂單資訊和客戶資訊：`OrderID`, `OrderDate`, `CustomerID`, `CustomerName`, `CustomerAddress`, `ProductName`, `Quantity`, `Price`。
- 這個表格存在冗餘：同一個客戶的姓名和地址會重複出現在每筆訂單中。
- 存在更新異常：如果客戶地址變了，需要更新該客戶的所有訂單記錄；如果刪除一個客戶的所有訂單，客戶資訊也會遺失。
- 正規化：
    - 拆分成 `Customers` 表 (`CustomerID` (PK), `CustomerName`, `CustomerAddress`)。
    - `Orders` 表只保留訂單和商品資訊，並透過外部鍵關聯客戶表 (`OrderID` (PK), `OrderDate`, `CustomerID` (FK), `ProductName`, `Quantity`, `Price`)。
    - 如果多個商品在同一訂單，商品資訊可能仍冗餘，可以進一步拆分出 `OrderItems` 表和 `Products` 表來達到更高的正規化。
- 🗣️口語化回答：像訂單表，如果客戶資料跟訂單放一起，同個客戶買很多次，他的名字地址就重複很多遍。我會把它拆成「客戶表」和「訂單表」，訂單表只記錄是哪個客戶下的單，這樣客戶資料就只存一次。

---

# 六、SQL 常見語法與概念（SELECT、JOIN、WHERE、GROUP BY、子查詢等）

## 常考觀念 Q&A
(Copied from user's input)

### Q1：請說明 SELECT, FROM, WHERE, ORDER BY 的用途。
- SELECT：選擇你想要顯示哪些欄位。
- FROM：告訴資料庫你要從哪個表格裡面抓資料。
- WHERE：設定條件，只抓符合特定條件的那些資料行。
- ORDER BY：設定資料要按照哪個欄位排序（升冪或降冪）。
- 🗣️口語化回答：SELECT 是選要看哪些欄位，FROM 是選哪個表，WHERE 是篩選資料，ORDER BY 是排序結果。

### Q2：請說明 INNER JOIN 和 LEFT JOIN 的區別，並舉例。
- INNER JOIN：只返回兩個表格中連接條件匹配的那些行。
- LEFT JOIN：返回左表格中的所有行，即使右表格中沒有匹配的行（右表對應的欄位會顯示 NULL）。
- 例子：`SELECT * FROM Orders LEFT JOIN Customers ON Orders.CustomerID = Customers.CustomerID;` 會列出所有訂單，即使有些訂單找不到對應的客戶；`SELECT * FROM Orders INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;` 只列出有客戶的訂單。
- 🗣️口語化回答：INNER JOIN 只拿兩個表都有匹配到的資料，LEFT JOIN 是左邊那個表的資料全部都要，右邊沒對到的就補 NULL。

### Q3：GROUP BY 的用途是什麼？HAVING 和 WHERE 有什麼不同？
- GROUP BY：用於將結果集按照一個或多個欄位的相同值分組，通常用於搭配聚合函數（如 COUNT, SUM, AVG, MAX, MIN）來計算每個組的統計值。
- WHERE：用於在資料從表格中被分組之前篩選「行」。
- HAVING：用於在資料被 GROUP BY 分組之後，篩選符合特定條件的「分組」。
- 🗣️口語化回答：GROUP BY 是把資料分成一組一組的，方便你算每個組的總數或平均。WHERE 是在分組「之前」篩選單筆資料，HAVING 是在分組「之後」篩選分好的那一組組。

### Q4：什麼是子查詢？它的用途是什麼？
- 子查詢：一個 SQL 查詢語句被嵌套在另一個 SQL 語句內部。
- 用途：
    - 作為 WHERE 條件的一部分，用於過濾數據。
    - 作為 FROM 子句的一部分，建立一個臨時的衍生表格。
    - 作為 SELECT 子句的一部分，計算單個值。
- 🗣️口語化回答：就是把一個查詢包在另一個查詢裡面用，可以用來篩選資料，或是做出一個暫時的表格來查。

## 重要語法或術語
(Copied from user's input)
- SELECT, FROM, WHERE
- JOIN (INNER, LEFT, RIGHT, FULL)
- GROUP BY, HAVING
- ORDER BY (ASC, DESC)
- LIMIT, OFFSET
- Subquery (子查詢)
- Aggregate Functions (COUNT, SUM, AVG, MAX, MIN)
- Primary Key, Foreign Key
- Index (索引)
- UNION, UNION ALL

## 面試常見問法與回答
(Copied from user's input)

### Q1：請寫一個 SQL 查詢：從 `employees` 表和 `departments` 表中，找出所有位於 'Sales' 部門的員工姓名和部門名稱。
- Q：請寫一個 SQL 查詢：從 `employees` 表和 `departments` 表中，找出所有位於 'Sales' 部門的員工姓名和部門名稱。（假設 `employees` 表有 `employee_name`, `department_id` 欄位，`departments` 表有 `department_id`, `department_name` 欄位）
- ```sql
  SELECT
      e.employee_name,
      d.department_name
  FROM
      employees e
  JOIN
      departments d ON e.department_id = d.department_id
  WHERE
      d.department_name = 'Sales';
  ```
- 說明：使用 JOIN 連接員工表和部門表，連接條件是部門 ID 相同，然後用 WHERE 過濾出部門名稱是 'Sales' 的記錄，最後選取員工姓名和部門名稱。
- 🗣️口語化回答：把員工表跟部門表 JOIN 起來，用部門 ID 連接，然後篩選出部門名稱是 Sales 的員工，取出姓名和部門名。

### Q2：請寫一個 SQL 查詢：找出每個部門的員工數量。
- Q：請寫一個 SQL 查詢：找出每個部門的員工數量。（使用 `employees` 表，假設有 `department_id` 欄位）
- ```sql
  SELECT
      department_id,
      COUNT(*) AS employee_count
  FROM
      employees
  GROUP BY
      department_id;
  ```
- 說明：使用 GROUP BY 將員工按照部門 ID 分組，然後使用 COUNT(*) 計算每個組（即每個部門）的員工數量。可以 JOIN `departments` 表來顯示部門名稱而非 ID。
- 🗣️口語化回答：把員工按照部門 ID 分組，然後計算每一組裡面有多少人，就是每個部門的員工數了。

### Q3：在處理大量數據的查詢時，你會考慮哪些 SQL 效能優化？
- Q：在處理大量數據的查詢時，你會考慮哪些 SQL 效能優化？
- **索引 (Indexing)**：檢查 WHERE 和 JOIN 條件中常用的欄位是否有建立索引。
- **查詢計畫分析**：使用資料庫提供的工具（如 MySQL 的 `EXPLAIN`）分析查詢語句的執行計畫，看是否使用了正確的索引、JOIN 順序是否合理。
- **優化 JOIN**：選擇最適合的 JOIN 類型（INNER, LEFT 等），確保 JOIN 條件使用了索引。
- **避免 SELECT ***：只選擇需要的欄位，減少資料傳輸和處理量。
- **合理使用子查詢**：有時子查詢效率不高，可以考慮改寫為 JOIN。
- **反正規化**：對於頻繁讀取且 JOIN 過多的情況，考慮在效能關鍵點引入少量冗餘。
- **資料庫設計**：確保資料庫 schema 本身是合理的正規化或反正規化。
- 🗣️口語化回答：我會先看查詢計畫，檢查有沒有用到索引，通常會對常用來篩選或 JOIN 的欄位加索引。也會盡量避免 `SELECT *`，只抓需要的欄位。

---

# 七、Spring Boot 架構與註解（Controller、Service、Repository 等）

## 重點摘要
(Copied from user's input)
Spring Boot 是一個基於 Spring 框架的快速開發工具，它通過「約定大於配置」的方式，極大地簡化了 Spring 應用程式的搭建和開發過程。理解 Spring Boot 的核心概念（IoC、DI）以及常用的註解（Annotation），是掌握現代 Java 後端開發的關鍵。它提供了成熟的 Web、資料庫、安全等解決方案。

## 定義
(Copied from user's input)
- Spring Boot：一個開源的 Java 框架，用於快速建立獨立、可生產級別的 Spring 應用程式。
- 特性：
    - **自動配置 (Auto-configuration)**：根據 classpath 中的函式庫自動配置 Spring 應用，減少手動配置。
    - **Starter Dependencies**：提供一組預先配置好的依賴，簡化依賴管理。
    - **嵌入式伺服器 (Embedded Servers)**：預設內嵌 Tomcat, Jetty 或 Undertow，可直接運行 JAR 文件，無需外部伺服器。
    - **無需 XML 配置**：廣泛使用 Java Configuration 和註解。
    - **生產級功能**：如健康檢查、指標收集 (Actuator)。
- 核心概念：
    - **IoC (Inversion of Control)**：控制反轉，Spring Container 負責管理物件的生命週期和依賴關係。
    - **DI (Dependency Injection)**：依賴注入，IoC Container 將物件所需的依賴自動注入給它，而非由物件自行創建或查找。
- 常見註解：
    - `@SpringBootApplication`：標記 Spring Boot 主應用類別，包含 `@Configuration`, `@EnableAutoConfiguration`, `@ComponentScan`。
    - `@Controller`：標記類別為 Spring MVC 控制器，處理 Web 請求。
    - `@RestController`：組合了 `@Controller` 和 `@ResponseBody`，用於建立 RESTful API。
    - `@Service`：標記類別為服務層組件，包含業務邏輯。
    - `@Repository`：標記類別為資料訪問層組件，通常處理資料庫操作，具有異常轉譯功能。
    - `@Component`：通用的 Spring 組件註解，其他如 `@Service`, `@Repository` 都是它的衍生物。
    - `@Autowired`：用於自動注入依賴。
    - `@Configuration`：標記類別為配置類，其中定義 `@Bean`。
    - `@Bean`：標記方法，其回傳值將註冊為 Spring IoC Container 中的一個 Bean。

## 常考觀念 Q&A
(Copied from user's input)

### Q1：什麼是 Spring Boot？為什麼在開發中選擇使用它？
- Spring Boot 是一個讓開發 Spring 應用更容易、更快速的框架。
- 它提供了自動配置、Starter 依賴和內嵌伺服器，可以大幅減少配置工作，直接運行 JAR 文件。
- 加速開發效率，易於部署和維護。
- 🗣️口語化回答：Spring Boot 就是讓你可以很快地建一個 Spring 專案，很多配置都幫你做好了，可以直接跑一個 JAR 檔，開發和部署都變簡單很多。

### Q2：請解釋 IoC (控制反轉) 和 DI (依賴注入) 的概念，以及 `@Autowired` 的作用。
- IoC：意思是物件的建立和管理不由程式碼自己控制，而是交給 Spring 容器來處理。
- DI：是實現 IoC 的一種方式，Spring 容器會自動幫你把物件所需要的其他物件（依賴）「注入」進來。
- `@Autowired`：這個註解就是告訴 Spring 容器，這裡需要一個某種類型的物件，請幫我從容器裡找一個合適的並注入進來。
- 🗣️口語化回答：IoC 是控制權交給 Spring，DI 是 Spring 幫你把需要的東西自動送給你。@Autowired 就是跟 Spring 說「這裡我需要那個物件，請給我」。

### Q3：請說明 `@Controller`, `@RestController`, `@Service`, `@Repository` 這幾個註解在分層架構中的作用。
- `@Controller` / `@RestController`：用於 Web 層，處理進來的 HTTP 請求，呼叫 Service 層的方法，並準備回傳 Response。`@RestController` 專門用於 RESTful API，直接回傳數據 (JSON/XML)。
- `@Service`：用於業務邏輯層，包含核心業務處理程式碼，通常會呼叫 Repository 層。
- `@Repository`：用於資料訪問層，負責與資料庫或其他數據源交互，進行 CRUD (Create, Read, Update, Delete) 操作。
- `@Component`：通用的 Spring 組件註解，其他如 `@Service`, `@Repository` 都是它的衍生物。
- 🗣️口語化回答：Controller 處理前端請求，Service 處理業務邏輯，Repository 處理資料庫存取。他們是把程式碼切成不同部分的標籤，讓程式碼更清楚。

### Q4：什麼是 Spring Boot 的自動配置 (Auto-configuration)？
- 是 Spring Boot 的核心功能之一。
- Spring Boot 會根據你專案中加入的函式庫（dependencies），自動判斷並配置 Spring 應用程式。
- 例如，如果你加了 `spring-boot-starter-web`，它會自動配置 Tomcat 和 Spring MVC；如果你加了 `spring-boot-starter-data-jpa` 和資料庫驅動，它會自動配置 JPA 和數據源。
- 減少了大量的 XML 或 JavaConfig 手動配置工作。
- 🗣️口語化回答：就是 Spring Boot 很聰明，看你專案裡加了哪些東西，就會自動幫你把大部分基本的配置都設好，你就不需要自己寫一堆設定了。

## 重要語法或術語
(Copied from user's input)
- Spring IoC Container
- Dependency Injection (DI)
- Auto-configuration (自動配置)
- Starter Dependencies
- Embedded Server (內嵌伺服器)
- `@SpringBootApplication`
- `@Controller`, `@RestController`
- `@Service`
- `@Repository`
- `@Component`
- `@Autowired`
- `@Configuration`, `@Bean`
- Spring MVC
- Spring Data JPA
- Spring Security
- Actuator

## 面試常見問法與回答
(Copied from user's input)

### Q1：你在專案中主要是怎麼使用 Spring Boot 的？請描述一個你負責的功能是如何利用 Spring Boot 實現的。
- Q：你在專案中主要是怎麼使用 Spring Boot 的？請描述一個你負責的功能是如何利用 Spring Boot 實現的。
- 主要用於建立後端 RESTful API 服務。
- 以會員註冊功能為例：
    - 建立一個 `@RestController` 處理 `/register` 的 POST 請求。
    - 請求進來後，Controller 將接收到的會員資料 (JSON) 傳給 `@Service` 層的會員服務。
    - Service 層進行業務邏輯檢查（如用戶名是否已存在），然後呼叫 `@Repository` 層的 DAO (Data Access Object)。
    - Repository 層使用 Spring Data JPA 將會員資料存入資料庫。
    - Service 層根據結果回傳成功或失敗訊息給 Controller。
    - Controller 再以 JSON 格式回傳給前端，並設置適當的 HTTP Status Code。
- 🗣️口語化回答：我主要是用它來開發後端 API。比如做會員註冊，我就寫一個 Controller 接收請求，交給 Service 處理業務邏輯，Service 再叫 Repository 存到資料庫，最後把結果回傳給前端。

### Q2：你在使用 Spring Boot 時，覺得最方便或最有挑戰性的是什麼？
- Q：你在使用 Spring Boot 時，覺得最方便或最有挑戰性的是什麼？
- **最方便**：自動配置和 Starter 依賴，可以非常快速地啟動一個功能齊全的專案原型，省去大量配置時間。內嵌伺服器讓部署也很簡單。
- **最有挑戰性**：有時候自動配置會「過度」配置了一些不需要的功能，需要手動排除或調整。理解底層的 Spring 如何運作，以及各種 Starter 依賴之間的關係，在遇到複雜問題時需要花一些時間深入研究。GC 和效能調優在大型應用中也是需要關注的點。
- 🗣️口語化回答：最方便的是它自動幫我把很多東西都設好了，可以很快開始寫程式。比較有挑戰的是，有時候它「太」自動了，出問題時可能需要花點時間去搞清楚它到底怎麼配置的。

---

# 八、Java 垃圾回收（Garbage Collection）機制與優化策略

## 重點摘要
(Copied from user's input)
Java 的垃圾回收 (GC) 是一種自動化的記憶體管理機制，負責回收不再使用的物件所佔用的記憶體。理解 GC 的工作原理、不同區域（Young/Old Generation）以及常見的 GC 演算法和類型（Minor/Major/Full GC），對於診斷記憶體問題（如記憶體洩漏）和優化 Java 應用程式的效能至關重要。

## 定義
(Copied from user's input)
- 垃圾回收 (Garbage Collection, GC)：JVM (Java Virtual Machine) 提供的一種自動記憶體管理功能，用於自動回收不再被程式引用的物件所佔用的記憶體。
- 目的：減少程式員手動管理記憶體的負擔，避免記憶體洩漏 (Memory Leak) 和釋放後使用 (Use After Free) 等問題。
- 記憶體區域：
    - **Heap (堆)**：Java 物件主要存儲的區域，是 GC 工作的主要區域。 Heap 又分為：
        - **Young Generation (新生代)**：新創建的物件首先分配在這裡。包含 Eden Space 和兩個 Survivor Spaces (S0, S1)。
        - **Old Generation (老年代/舊生代)**：經過多次 Minor GC 仍存活的物件會晉升到這裡。
    - **Stack (棧)**：存儲局部變數和方法呼叫資訊，這部分記憶體由 JVM 自動管理，不是 GC 的重點。
    - **Method Area (方法區) / Metaspace (元空間)**：存儲類別結構資訊、靜態變數、常量等。GC 也可以對此區域進行回收，但在 Java 8 及之後主要管理 Metaspace。
- GC 類型：
    - **Minor GC (新生代 GC)**：只清理 Young Generation，發生頻率高，速度快。
    - **Major GC (老年代 GC)**：只清理 Old Generation，發生頻率低。
    - **Full GC (全 GC)**：清理整個 Heap (Young + Old) 和 Method Area/Metaspace，發生頻率最低，耗時最長，可能導致應用暫停 ("Stop-the-world" pause)。
- 判斷物件是否可回收：通過可達性分析 (Reachability Analysis)，從 GC Roots (如活動線程的局部變數、靜態變數等) 出發，任何不可達的物件都被視為垃圾。
- GC 演算法：Mark-Sweep (標記清除), Copying (複製), Mark-Compact (標記整理), Generational GC (分代 GC), Concurrent GC (並發 GC), Parallel GC (並行 GC)。

## 常考觀念 Q&A
(Copied from user's input)

### Q1：什麼是 Java 垃圾回收？它解決了什麼問題？
- Java 垃圾回收是 JVM 自動幫我們管理記憶體的功能。
- 它會自動找到那些程式已經不再使用的物件，並回收它們佔用的記憶體空間。
- 解決了程式員需要手動分配和釋放記憶體的問題，避免了記憶體洩漏或釋放後使用等錯誤。
- 🗣️口語化回答：就是 Java 不用你自己清記憶體，JVM 會自動找到沒用的物件並收走，讓你可以專心寫程式。

### Q2：Java 記憶體區域中，哪些是 GC 的主要工作對象？請說明 Young Gen 和 Old Gen 的區別。
- GC 主要工作對象是 Heap 區域。
- Heap 分為 Young Generation (新生代) 和 Old Generation (老年代)。
- Young Gen 用來存放新創建的物件，通常生命週期較短，GC 頻率高（Minor GC）。
- Old Gen 用來存放那些在 Young Gen 經過多次 GC 後仍然存活的物件，通常生命週期較長。
- 🗣️口語化回答：GC 主要清 Heap 區。Heap 分年輕代和老年代，新物件放年輕代，活比較久的物件會搬到老年代。

### Q3：Minor GC, Major GC, Full GC 有什麼不同？哪個影響效能最大？
- Minor GC：只清理 Young Generation，發生很頻繁，但速度很快，對應用影響小。
- Major GC：只清理 Old Generation，頻率較低，比 Minor GC 慢。
- Full GC：清理整個 Heap (Young + Old) 和 Metaspace，頻率最低，但會導致應用程式完全暫停 ("Stop-the-world")，是影響效能最大的 GC 類型。
- 🗣️口語化回答：Minor GC 是清年輕代，很快。Major GC 清老年代。Full GC 是清整個 Heap，最慢，可能會讓程式卡住一下。

### Q4：如何判斷一個 Java 物件是否「存活」（不會被 GC 回收）？
- Java 使用「可達性分析」來判斷物件是否存活。
- 從一系列稱為 "GC Roots" 的起始點（例如正在執行的線程中的局部變數、靜態變數、Native 方法堆疊的物件等）出發，遍歷所有引用的物件。
- 任何從 GC Roots 不可達的物件，都會被視為垃圾，可以被回收。
- 🗣️口語化回答：JVM 會從一些起點（像是你程式正在跑的地方）去找物件，只要能找到連過去的物件就是活著的，找不到連線的就是沒用的，可以被收走。

## 重要語法或術語
(Copied from user's input)
- Garbage Collection (GC)
- JVM (Java Virtual Machine)
- Heap, Stack
- Young Generation, Old Generation
- Eden Space, Survivor Spaces
- Minor GC, Major GC, Full GC
- Stop-the-world
- GC Roots
- Reachability Analysis (可達性分析)
- Memory Leak (記憶體洩漏)
- GC Algorithms (e.g., G1, Parallel, CMS)
- JVisualVM, JProfiler (GC 監控工具)

## 面試常見問法與回答
(Copied from user's input)

### Q1：你在開發中，如何避免或減少記憶體洩漏？
- Q：你在開發中，如何避免或減少記憶體洩漏？
- 確保不再使用的物件，其引用能夠被正確釋放或設為 null，使其變得不可達。
- 避免集合類 (Collection) 在不再需要時仍持有大量物件的引用。
- 謹慎使用靜態集合或長生命週期的物件引用。
- 如果使用了資源（如檔案流、網路連線），確保在不再需要時呼叫 close() 方法釋放。
- 使用弱引用 (WeakReference) 或軟引用 (SoftReference) 在特定場景下允許 GC 回收物件。
- 定期使用記憶體分析工具 (如 JVisualVM, Eclipse Memory Analyzer) 檢查 Heap Dump，查找未釋放的物件和引用鏈。
- 🗣️口語化回答：我會注意用完的物件要讓它能被 GC 收到，特別是集合類和長生命週期的物件。也會確保資源（像檔案連線）有確實關掉。必要時會用工具檢查是不是有物件一直佔著記憶體。

### Q2：你遇過 GC 造成的效能問題嗎？是如何診斷和解決的？
- Q：你遇過 GC 造成的效能問題嗎？是如何診斷和解決的？
- 遇過的問題：應用程式突然停頓很長時間（Full GC 停頓），或 CPU 使用率異常高且頻繁 GC。
- 診斷方法：
    - 啟用 GC 日誌，分析 GC 的頻率、類型和每次耗時。
    - 使用 JVisualVM, JProfiler 等工具連接到運行中的應用，監控 Heap 使用率、GC 活動和線程狀態。
    - 導出 Heap Dump，使用分析工具查找是否存在記憶體洩漏或過大的物件，識別是哪些物件佔用了大量記憶體且未被釋放。
- 解決方法：
    - 根據診斷結果，優化程式碼：減少不必要的物件創建，改進資料結構使用，釋放不再使用的引用。
    - 如果是 GC 演算法不適合應用場景，可以嘗試調整 JVM 參數，更換 GC 演算法（例如從 ParNew/CMS 換到 G1）。
    - 調整 Heap 大小或 Young/Old Gen 比例，但這通常是最後手段且需要仔細測試。
- 🗣️口語化回答：遇過程式突然卡住很久，發現是 Full GC 造成的。我會先開 GC 日誌或用監控工具看是哪裡記憶體用太多，是不是有物件沒被收走，然後去優化程式碼，或是調整 JVM 的 GC 參數和策略。

---

# 九、Java 基本語法與物件導向觀念（OOP）

## OOP 四大特性簡述
- **封裝（Encapsulation）**：將數據（成員變數）和處理數據的方法（成員方法）綁定在一個單元（類別）中，並通過存取修飾詞控制對內部數據的訪問，隱藏內部實現細節。
- **繼承（Inheritance）**：允許一個類別（子類別）繼承另一個類別（父類別）的屬性和方法，實現程式碼重用。
- **多型（Polymorphism）**：允許不同的物件對同一個方法調用做出不同的響應。主要體現在方法重載和覆寫。
- **抽象（Abstraction）**：隱藏複雜的實現細節，只展示必要的信息。通過抽象類別和介面實現。

## 補充觀念
- **static**：用於修飾成員變數、方法、內部類別和初始化塊。`static` 成員屬於類別本身，而非類的任何特定實例。靜態變數在類別加載時初始化一次；靜態方法可以直接通過類別名稱調用，不能訪問非靜態成員。
- **final**：用於修飾變數、方法和類別。
    - `final` 變數：其值一旦被賦予就不能再改變（對於引用類型，是引用本身不能變，指向的對象內容可以變）。
    - `final` 方法：不能在子類別中被覆寫。
    - `final` 類別：不能被繼承。
- **this**：在類別內部使用，引用當前物件的實例。可以用於訪問當前物件的成員（變數或方法），區分成員變數和局部變數（當同名時），或在建構子中調用另一個建構子 (`this()`)。
- **super**：在子類別中使用，引用其直接父類別的實例。可以用於訪問父類別的成員（變數或方法），或在子類別建構子中調用父類別的建構子 (`super()`)。
- **建構子 overloading (方法重載)**：在同一個類別中定義多個建構子，它們有不同的參數列表。這使得在創建物件時可以有多種不同的初始化方式。
- **抽象類別 vs 介面**：
    - **抽象類別**：可以有抽象方法（無實作）和具體方法（有實作）。可以有成員變數。不能直接實例化。用於表示「is-a」關係中的共同基礎結構，允許部分實作。一個類別只能繼承一個抽象類別。
    - **介面**：在 Java 8 之前只能定義抽象方法（無實作）和常量。Java 8 後可以有 `default` 和 `static` 方法，Java 9 後可以有 `private` 方法。主要用於定義行為規格或協定。一個類別可以實作多個介面。
- **記憶體管理與 Garbage Collection（GC）**：(參見第八章) Java 透過自動垃圾回收來管理堆記憶體，回收不再被引用的物件。

## 常考觀念 Q&A
(Copied from user's input)

### Q1：請說明物件導向（OOP）的三大特性：封裝、繼承、多型。
- 封裝：就像把資料和處理資料的方法包在一個箱子裡（物件），箱子外面只留一些開關讓你操作，裡面的細節你看不到也動不了。這樣資料比較安全，程式也比較模組化。
- 繼承：就像兒子繼承爸爸的財產和能力。一個子類別可以繼承父類別的屬性和方法，這樣就不用重複寫很多程式碼，提高程式碼的重用性。
- 多型：意思是用同一個名稱呼叫方法，但因為物件類型不同，實際執行的行為會不一樣。例如，父類別有個 `draw()` 方法，子類別（如圓形、方形）覆寫了它，呼叫 `draw()` 時圓形畫圓、方形畫方。
- 🗣️口語化回答：封裝是把東西包起來藏細節，繼承是複製老爸的能力，多型是同一個指令不同物件有不同反應。

### Q2：Java 中的方法重載 (Overloading) 和方法覆寫 (Overriding) 有什麼區別？
- 重載 (Overloading)：發生在同一個類別中。多個方法有相同的方法名稱，但它們的參數列表（參數數量、類型或順序）不同。回傳類型和存取修飾詞可以不同，但不是判斷重載的依據。這是編譯時的多型 (Compile-time Polymorphism / Static Polymorphism)。
- 覆寫 (Overriding)：發生在父類別和子類別之間（繼承關係）。子類別定義了一個和父類別完全相同的方法簽名（方法名稱、參數列表、回傳類型），但提供不同的實作。子類別覆寫方法的存取修飾詞不能比父類別更嚴格。這是執行時的多型 (Runtime Polymorphism / Dynamic Polymorphism)。
- 🗣️口語化回答：重載是同一個類別裡，方法名一樣但參數不一樣；覆寫是子類別寫了一個跟父類別一模一樣的方法，把父類別的換掉。

### Q3：`interface` 和 `abstract class` 有什麼區別？分別用在什麼場景？
- `interface` (介面)：定義了一組方法的規格（協定），但不提供方法的具體實作（Java 8 後可以有 default/static 方法）。一個類別可以實作 (implement) 多個介面。主要用於定義行為標準或協定。
- `abstract class` (抽象類別)：可以包含抽象方法（沒有實作）和具體方法（有實作）。不能被直接實例化，只能被繼承。一個類別只能繼承 (extend) 一個抽象類別。主要用於定義共同的基礎結構或部分實作，供子類別繼承並完成剩餘部分。
- 🗣️口語化回答：Interface 就像一份合約或規格書，只說要做什麼（不能寫怎麼做），一個類別可以簽很多份。Abstract Class 就像半成品，有些做好了有些沒做，只能繼承一個。Interface 強調「能做什麼」，Abstract Class 強調「是什麼」。

### Q4：Primitive types (基本資料類型) 和 Reference types (引用資料類型) 有什麼區別？
- Primitive types：直接存儲實際的值在變數中。包括 `byte`, `short`, `int`, `long`, `float`, `double`, `char`, `boolean`。它們佔用固定大小的記憶體空間。
- Reference types：變數中存儲的是對物件在 Heap 記憶體中的引用（地址），而不是實際的物件本身。包括類別、介面、陣列、枚舉、字符串 (雖然有特殊處理，但 `String` 是物件)。需要通過引用來訪問實際的物件。
- 🗣️口語化回答：基本類型變數裡直接存值，像數字 5 或 True/False。引用類型變數裡存的是物件的「地址」，你要透過這個地址才能找到實際的物件。

## 重要語法或術語
(Copied from user's input)
- Class (類別), Object (物件)
- Encapsulation (封裝), Inheritance (繼承), Polymorphism (多型), Abstraction (抽象)
- Method Overloading (方法重載), Method Overriding (方法覆寫)
- `public`, `private`, `protected` (存取修飾詞)
- `static`, `final`
- `abstract class`, `interface`
- Primitive Types (基本資料類型), Reference Types (引用資料類型)
- Constructor (建構子)
- `super`, `this`
- `new` (創建物件)

## 面試常見問法與回答
(Copied from user's input)

### Q1：請用一個現實世界的例子，說明如何用物件導向概念來描述它。
- Q：請用一個現實世界的例子，說明如何用物件導向概念來描述它。（例如：寵物系統）
- 例子：寵物系統。
    - 定義一個 `Animal` 抽象類別，包含 `name` 屬性和抽象方法 `makeSound()`。
    - 定義 `Dog` 和 `Cat` 類別，繼承自 `Animal`。它們繼承了 `name` 屬性。
    - `Dog` 覆寫 `makeSound()` 方法為「汪汪」，`Cat` 覆寫 `makeSound()` 方法為「喵喵」。 (多型, 繼承)
    - 在 `Animal` 類別中，可能將 `name` 設定為 `private`，通過 `public` 的 getter/setter 方法訪問。 (封裝)
    - 我們可以創建一個 `List<Animal>` 集合，裡面可以放 `Dog` 和 `Cat` 的物件。遍歷列表呼叫 `makeSound()` 時，會根據實際物件類型發出不同的聲音。 (多型)
- 🗣️口語化回答：想像一個寵物系統。我們可以有個「動物」的基底，有名字和叫聲，然後「狗」和「貓」繼承動物，但它們的叫聲方法（多型）不一樣。你可以把所有狗和貓都放進一個「動物列表」，一個個叫它們發出聲音，它們就會發出各自的叫聲。

### Q2：你在開發中，如何應用物件導向原則來提升程式碼品質？
- Q：你在開發中，如何應用物件導向原則來提升程式碼品質？
- **封裝**：將相關的數據和行為放在同一個類別中，對外提供清晰的介面，隱藏內部實現細節。這讓程式碼更容易理解和修改，不容易誤用。
- **繼承/組合**：利用繼承（謹慎使用）或更傾向使用組合 (Composition over Inheritance)，來重用程式碼和建立類別之間的關係，避免重複寫輪子。
- **多型/介面**：面向介面程式設計，使用多型來處理不同類型的物件。這樣可以寫出更彈性、更易於擴展的程式碼。當需要新增新的類型時，只需實作介面或繼承抽象類別，而不需要修改現有程式碼。
- 提高可讀性、可維護性和可擴展性。
- 🗣️口語化回答：我會盡量把功能切成有意義的物件，用封裝藏好內部細節。也會多用介面和多型，這樣以後要加新功能或改東西時，程式碼會比較好修改，不用動到太多地方。

---

# 十、Java 筆試程式實作題

---

### 題目：判斷質數

#### 📋 題目說明：
請寫一個 Java 程式，輸入一個整數，判斷是否為質數（只能被 1 和自己整除的正整數，2 是最小質數）。

#### 📥 範例輸入：
```
輸入：7
```

#### 📤 預期輸出：
```
7 是質數
```

#### ✅ Java 解答：
```java
import java.util.Scanner;

public class PrimeChecker {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("請輸入數字："); // Added prompt for clarity
        int num = scanner.nextInt();
        boolean isPrime = true; // Assume prime initially

        if (num <= 1) { // Numbers less than or equal to 1 are not prime
            isPrime = false;
        } else if (num == 2) { // 2 is the only even prime number
            isPrime = true;
        } else if (num % 2 == 0) { // All other even numbers are not prime
            isPrime = false;
        } else {
            // Check for odd divisors starting from 3 up to the square root of num
            // Optimized loop: i*i <= num is faster than Math.sqrt(num)
            for (int i = 3; i * i <= num; i = i + 2) {
                if (num % i == 0) { // If num is divisible by any i, it's not prime
                    isPrime = false;
                    break; // Exit loop early if a divisor is found
                }
            }
        }

        System.out.println(num + (isPrime ? " 是質數" : " 不是質數"));
        scanner.close();
    }
}
```

#### 📌 重點解析：
- 使用 `Scanner` 從標準輸入讀取整數。
- 使用 `boolean isPrime` 旗標來追蹤數字是否為質數。
- **基本條件判斷**：首先檢查邊界情況：小於等於 1 的數不是質數。單獨處理數字 2 (它是唯一的偶數質數)。排除所有大於 2 的偶數，它們肯定不是質數。
- **優化迴圈**：對於奇數，從 3 開始檢查奇數因子 (`i = i + 2`)。只需要檢查到該數字的平方根 (`i * i <= num`) 即可，因為如果一個數有大於其平方根的因子，必然也有一個小於其平方根的因子。
- `num % i == 0` 檢查是否能被整除。
- `break` 語句用於在找到第一個因子時立即終止迴圈，提高效率。
- 最後根據 `isPrime` 的狀態印出結果。

---

### 題目：印出直角三角形（靠左下）

#### 📋 題目說明：
請寫一個 Java 程式，輸入一個整數 `n`，印出一個靠左下對齊、高度為 `n` 的星號直角三角形。

#### 📥 範例輸入：
```
輸入：5
```

#### 📤 預期輸出：
```
*
**
***
****
*****
```

#### ✅ Java 解答：
```java
import java.util.Scanner;

public class LeftBottomTriangle {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("請輸入三角形的行數：");
        int numRows = scanner.nextInt();

        if (numRows <= 0) {
            System.out.println("行數必須是正整數。");
        } else {
            // 外層迴圈控制行數
            for (int i = 1; i <= numRows; i++) {
                // 內層迴圈控制每行印出的星號數量
                // 第 i 行印出 i 個星號
                for (int j = 1; j <= i; j++) {
                    System.out.print("*");
                }
                // 每行結束後換行
                System.out.println();
            }
        }

        scanner.close();
    }
}
```

#### 📌 重點解析：
- 使用 `Scanner` 讀取使用者輸入的行數 `numRows`。
- 使用**巢狀 `for` 迴圈**。
- **外層迴圈** `for (int i = 1; i <= numRows; i++)` 控制要印製的總行數，`i` 代表當前是第幾行（從 1 開始）。
- **內層迴圈** `for (int j = 1; j <= i; j++)` 控制在當前行 `i` 要印出多少個星號。由於是靠左下的直角三角形，第 `i` 行需要印出 `i` 個星號。
- `System.out.print("*")` 在同一行印出星號。
- `System.out.println()` 在內層迴圈（印完一行的星號）結束後調用，用於換行，開始印製下一行。
- 程式包含了對輸入行數是否為正整數的基本驗證。

---

### 題目：印出直角三角形（靠右上）

#### 📋 題目說明：
請寫一個 Java 程式，輸入一個整數 `n`，印出一個靠右上對齊、高度為 `n` 的星號直角三角形。

#### 📥 範例輸入：
```
輸入：5
```

#### 📤 預期輸出：
```
    *
   **
  ***
 ****
*****
```

#### ✅ Java 解答：
```java
import java.util.Scanner;

public class RightTopTriangle {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("請輸入三角形的行數：");
        int numRows = scanner.nextInt();

        if (numRows <= 0) {
            System.out.println("行數必須是正整數。");
        } else {
            // 外層迴圈控制行數
            for (int i = 1; i <= numRows; i++) {
                // 內層迴圈印出空格
                // 第 i 行需要印出 numRows - i 個空格
                for (int j = 1; j <= numRows - i; j++) {
                    System.out.print(" ");
                }
                // 內層迴圈印出星號
                // 第 i 行印出 i 個星號
                for (int k = 1; k <= i; k++) {
                    System.out.print("*");
                }
                // 每行結束後換行
                System.out.println();
            }
        }

        scanner.close();
    }
}
```

#### 📌 重點解析：
- 使用 `Scanner` 讀取使用者輸入的行數 `numRows`。
- 使用**巢狀 `for` 迴圈**，但這次需要兩個內層迴圈：一個印空格，一個印星號。
- **外層迴圈** `for (int i = 1; i <= numRows; i++)` 控制總行數。
- **第一個內層迴圈** `for (int j = 1; j <= numRows - i; j++)` 印出當前行 `i` 前面的空格。靠右上對齊的三角形，第 1 行需要 `n-1` 個空格，第 2 行需要 `n-2` 個空格，...，第 `n` 行需要 0 個空格。所以第 `i` 行需要 `numRows - i` 個空格。
- **第二個內層迴圈** `for (int k = 1; k <= i; k++)` 印出當前行 `i` 的星號。第 `i` 行印出 `i` 個星號。
- `System.out.print(" ")` 印出空格，`System.out.print("*")` 印出星號，都在同一行不換行。
- `System.out.println()` 在印完當前行的所有空格和星號後換行。
- 程式包含輸入驗證。

---

### 題目：印出等腰三角形

#### 📋 題目說明：
請寫一個 Java 程式，輸入一個整數 `n`，印出一個高度為 `n` 的等腰三角形（尖朝上，底邊靠下）。

#### 📥 範例輸入：
```
輸入：5
```

#### 📤 預期輸出：
```
    *
   ***
  *****
 *******
*********
```

#### ✅ Java 解答：
```java
import java.util.Scanner;

public class IsoscelesTriangle {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("請輸入三角形的行數：");
        int numRows = scanner.nextInt();

        if (numRows <= 0) {
            System.out.println("行數必須是正整數。");
        } else {
            // 外層迴圈控制行數
            for (int i = 1; i <= numRows; i++) {
                // 內層迴圈印出空格
                // 第 i 行需要印出 numRows - i 個空格以實現居中對齊
                for (int j = 1; j <= numRows - i; j++) {
                    System.out.print(" ");
                }
                // 內層迴圈印出星號
                // 第 i 行印出 2*i - 1 個星號 (1, 3, 5, 7, ...)
                for (int k = 1; k <= 2 * i - 1; k++) {
                    System.out.print("*");
                }
                // 每行結束後換行
                System.out.println();
            }
        }

        scanner.close();
    }
}
```

#### 📌 重點解析：
- 使用 `Scanner` 讀取使用者輸入的行數 `numRows`。
- 使用**巢狀 `for` 迴圈**，一個印空格，一個印星號。
- **外層迴圈** `for (int i = 1; i <= numRows; i++)` 控制總行數。
- **第一個內層迴圈** `for (int j = 1; j <= numRows - i; j++)` 印出當前行 `i` 前面的空格。要實現等腰三角形的居中效果，需要根據行數印出適量的縮進空格。第 1 行需要 `n-1` 個空格，第 2 行需要 `n-2` 個，...，第 `n` 行需要 0 個空格。這與靠右上直角三角形的空格數量相同。
- **第二個內層迴圈** `for (int k = 1; k <= 2 * i - 1; k++)` 印出當前行 `i` 的星號。等腰三角形的星號數量呈奇數序列增長：第 1 行 1 個，第 2 行 3 個，第 3 行 5 個，...，第 `i` 行印出 `2 * i - 1` 個星號。
- `System.out.print(" ")` 印出空格，`System.out.print("*")` 印出星號，都在同一行不換行。
- `System.out.println()` 在印完當前行的所有空格和星號後換行。
- 程式包含輸入驗證。

---

### 題目：九九乘法表（排版整齊）

#### 📋 題目說明：
請撰寫一個 Java 程式，印出一個標準的九九乘法表（從 1x1 到 9x9），要求輸出格式整齊對齊。

#### 📥 範例輸入：
(無使用者輸入)

#### 📤 預期輸出：
```
1 * 1 =  1   1 * 2 =  2   ... 1 * 9 =  9
2 * 1 =  2   2 * 2 =  4   ... 2 * 9 = 18
...
9 * 1 =  9   9 * 2 = 18   ... 9 * 9 = 81
```
（實際輸出應包含所有 81 個乘積並整齊對齊）

#### ✅ Java 解答：
```java
public class MultiplicationTable {
    public static void main(String[] args) {
        // 外層迴圈控制被乘數 (1 到 9)
        for (int i = 1; i <= 9; i++) {
            // 內層迴圈控制乘數 (1 到 9)
            for (int j = 1; j <= 9; j++) {
                // 使用 printf 進行格式化輸出
                // %d 表示整數
                // %2d 表示至少佔用 2 個字元寬度，不足則在前面補空格 (右對齊)
                // "   " 額外加上三個空格，用於分隔每列
                System.out.printf("%d * %d = %2d   ", i, j, i * j);
            }
            // 每行結束後換行
            System.out.println();
        }
    }
}
```

#### 📌 重點解析：
- 使用**巢狀 `for` 迴圈**。外層迴圈用於控制被乘數 `i` (1-9)，內層迴圈用於控制乘數 `j` (1-9)。
- 核心是使用 `System.out.printf()` 方法進行**格式化輸出**。
- 格式字串 `"%d * %d = %2d   "` 的解釋：
    - `%d`：用於輸出整數，分別對應 `i` 和 `j`。
    - `%2d`：用於輸出整數，**並指定輸出寬度至少為 2 個字元**。如果數字不足 2 位（如 1 到 9），會在前面自動補空格，實現右對齊。這確保了像 " 1" 和 "10" 這樣的數字在同一列中對齊。
    - `   `：後面額外加上空格，用於在每個乘法結果之間提供間隔，使表格更清晰。
- `System.out.println()` 在內層迴圈完成後執行，用於在一行的乘法結果印出完畢後換行。

---

### 題目：印出前 N 個費式數列

#### 📋 題目說明：
請撰寫一個 Java 程式，輸入一個正整數 `N`，印出費式數列（Fibonacci Sequence）的前 `N` 個數字。費式數列從 0 和 1 開始，後續每個數字是前兩個數字的和。

#### 📥 範例輸入：
```
輸入：10
```

#### 📤 預期輸出：
```
費式數列的前 10 項為：0, 1, 1, 2, 3, 5, 8, 13, 21, 34
```

#### ✅ Java 解答：
```java
import java.util.Scanner;

public class FibonacciSequence {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("請輸入要印出的費式數列項數 (N)：");
        int n = scanner.nextInt();

        if (n <= 0) {
            System.out.println("項數必須是正整數。");
        } else {
            System.out.print("費式數列的前 " + n + " 項為：");

            // 初始化前兩個費式數
            long num1 = 0;
            long num2 = 1;

            // 處理 N=1 和 N=2 的情況，以及後續的迭代
            if (n >= 1) {
                System.out.print(num1); // 印出第一項 (0)
            }
            if (n >= 2) {
                System.out.print(", " + num2); // 印出第二項 (1)
            }

            // 從第三項開始計算並印出
            for (int i = 3; i <= n; i++) {
                long nextNum = num1 + num2; // 計算下一項
                System.out.print(", " + nextNum); // 印出下一項，前面加逗號和空格

                // 更新 num1 和 num2，為下一次計算做準備
                num1 = num2;
                num2 = nextNum;
            }

            System.out.println(); // 最後換行

        }

        scanner.close();
    }
}
```

#### 📌 重點解析：
- 使用 `Scanner` 讀取使用者輸入的項數 `n`。
- 使用**迭代**的方式計算費式數列，而非遞歸（遞歸效率低，易堆疊溢位）。
- 初始化兩個變數 `num1` 和 `num2` 分別為費式數列的前兩項 0 和 1。使用 `long` 型別以防止大數溢位。
- 單獨處理 `n=1` 和 `n=2` 的情況，直接印出對應的項。
- 對於 `n > 2`，使用 `for` 迴圈從第 3 項遍歷到第 `n` 項。
- 在迴圈中，計算下一項 `nextNum` 為 `num1 + num2`。
- **關鍵步驟**：更新 `num1 = num2;` 和 `num2 = nextNum;`，以便在下一次迴圈中能正確計算再下一項。
- 使用 `System.out.print()` 配合逗號和空格印出每項，最後用 `println()` 換行。
- 程式包含輸入驗證。

---

### 題目：回文判斷（isPalindrome）

#### 📋 題目說明：
請撰寫一個 Java 程式，輸入一個字串，判斷它是否為回文（正讀反讀都相同）。不考慮大小寫、空格或標點符號，只比較字母本身。

#### 📥 範例輸入：
```
輸入：Madam
```

#### 📤 預期輸出：
```
"Madam" 是回文字串
```

#### 📥 範例輸入：
```
輸入：Race car
```

#### 📤 預期輸出：
```
"Race car" 是回文字串
```

#### ✅ Java 解答：
```java
import java.util.Scanner;

public class PalindromeChecker {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("請輸入一個字串：");
        String input = scanner.nextLine();

        if (isPalindrome(input)) {
            System.out.println("\"" + input + "\" 是回文字串");
        } else {
            System.out.println("\"" + input + "\" 不是回文字串");
        }

        scanner.close();
    }

    // 判斷是否為回文的方法
    public static boolean isPalindrome(String str) {
        // 預處理字串：轉換為小寫並移除所有非字母數字字元
        String cleanedStr = str.toLowerCase().replaceAll("[^a-z0-9]", "");

        int left = 0;
        int right = cleanedStr.length() - 1;

        // 使用雙指標從兩端向中間檢查
        while (left < right) {
            // 比較左右兩端的字元
            if (cleanedStr.charAt(left) != cleanedStr.charAt(right)) {
                return false; // 發現不匹配的字元，不是回文
            }
            // 移動指標
            left++;
            right--;
        }

        return true; // 遍歷完成，所有對稱字元都匹配，是回文
    }
}
```

#### 📌 重點解析：
- 使用 `Scanner` 讀取使用者輸入的字串。
- 核心邏輯封裝在 `isPalindrome(String str)` 方法中。
- **字串預處理**：為符合「不考慮大小寫、空格或標點符號」的要求，先將字串轉換為小寫 (`toLowerCase()`)，然後使用正規表達式 `replaceAll("[^a-z0-9]", "")` 移除所有非字母數字的字元，得到一個乾淨的字串 `cleanedStr`。
- 使用**雙指標** (`left` 和 `right`) 分別指向處理後字串的開頭和結尾。
- 使用 `while (left < right)` 迴圈，只要左指標仍在右指標左邊，就繼續比較。當指標相遇或交叉時，表示檢查完成一半，可以停止。
- 在迴圈中，比較 `cleanedStr.charAt(left)` 和 `cleanedStr.charAt(right)`。
- 如果字元不匹配，立即返回 `false`。
- 如果匹配，則將 `left` 向右移動 (`left++`)，`right` 向左移動 (`right--`)，繼續檢查下一對字元。
- 如果迴圈正常結束而沒有返回 `false`，說明所有對稱位置的字元都匹配，字串是回文，返回 `true`。

---

### 題目：陣列最大值與最小值

#### 📋 題目說明：
請撰寫一個 Java 程式，找出給定整數陣列中的最大值和最小值。

#### 📥 範例輸入：
假設陣列為：`[12, 45, 6, 89, 23, 5, 90]`

#### 📤 預期輸出：
```
陣列中的最大值是：90
陣列中的最小值是：5
```

#### ✅ Java 解答：
```java
import java.util.Arrays;

public class FindMinMax {
    public static void main(String[] args) {
        int[] numbers = {12, 45, 6, 89, 23, 5, 90};

        // 檢查陣列是否為空或 null
        if (numbers == null || numbers.length == 0) {
            System.out.println("陣列為空，無法找到最大值和最小值。");
            return;
        }

        // 初始化最大值和最小值為陣列的第一個元素
        int max = numbers[0];
        int min = numbers[0];

        // 從陣列的第二個元素開始遍歷
        for (int i = 1; i < numbers.length; i++) {
            // 比較當前元素與最大值
            if (numbers[i] > max) {
                max = numbers[i];
            }
            // 比較當前元素與最小值
            if (numbers[i] < min) {
                min = numbers[i];
            }
        }

        System.out.println("陣列為：" + Arrays.toString(numbers));
        System.out.println("陣列中的最大值是：" + max);
        System.out.println("陣列中的最小值是：" + min);
    }
}
```

#### 📌 重點解析：
- 定義一個整數陣列 `numbers`。
- 檢查陣列是否為空或 `null`，避免運行時錯誤。
- **初始化**：將變數 `max` 和 `min` 的初始值都設定為陣列的第一個元素 (`numbers[0]`)。這是一個穩健的方法，因為無論陣列中是正數、負數還是混合，第一個元素都是陣列中的一個有效值。
- 使用 `for` 迴圈**遍歷**陣列，從索引 1 開始 (`i = 1`)，遍歷到最後一個元素。從索引 1 開始是因為索引 0 的元素已經用於初始化了。
- 在迴圈內部，使用 `if` 語句比較當前元素 `numbers[i]` 與目前的 `max` 和 `min`。
- 如果 `numbers[i]` 大於 `max`，則更新 `max = numbers[i]`。
- 如果 `numbers[i]` 小於 `min`，則更新 `min = numbers[i]`。
- 經過一次遍歷，`max` 和 `min` 就會儲存陣列中的最大值和最小值。
- 使用 `Arrays.toString(numbers)` 方便印出陣列內容。

---

### 題目：氣泡排序

#### 📋 題目說明：
請撰寫一個 Java 程式，使用氣泡排序（Bubble Sort）演算法對一個整數陣列進行升序排序。

#### 📥 範例輸入：
假設陣列為：`[64, 34, 25, 12, 22, 11, 90]`

#### 📤 預期輸出：
```
原始陣列: [64, 34, 25, 12, 22, 11, 90]
排序後的陣列: [11, 12, 22, 25, 34, 64, 90]
```

#### ✅ Java 解答：
```java
import java.util.Arrays;

public class BubbleSort {

    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        // 外層迴圈控制排序的趟數
        // 每趟結束後，最大的未排序元素會"浮"到其最終位置
        for (int i = 0; i < n - 1; i++) {
            boolean swapped = false; // 標記，用於提前結束排序（優化）

            // 內層迴圈用於比較和交換相鄰元素
            // j 的範圍會隨著外層迴圈的 i 減少 (n-1-i)，因為後面 i 個元素已經有序
            for (int j = 0; j < n - 1 - i; j++) {
                // 如果當前元素比下一個元素大，則交換它們
                if (arr[j] > arr[j + 1]) {
                    // 交換 arr[j] 和 arr[j+1]
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true; // 發生了交換
                }
            }

            // 如果在一趟排序中沒有發生任何交換，說明陣列已經有序
            if (!swapped) {
                break; // 提前結束外層迴圈
            }
        }
    }

    public static void main(String[] args) {
        int[] data = {64, 34, 25, 12, 22, 11, 90};

        System.out.println("原始陣列: " + Arrays.toString(data));

        bubbleSort(data); // 調用排序方法

        System.out.println("排序後的陣列: " + Arrays.toString(data));
    }
}
```

#### 📌 重點解析：
- 排序邏輯封裝在 `bubbleSort(int[] arr)` 方法中。Java 陣列是引用類型，直接修改傳入的陣列即可。
- 使用**巢狀 `for` 迴圈**實現氣泡排序的核心邏輯。
- **外層迴圈** `for (int i = 0; i < n - 1; i++)`：控制排序的趟數。對於長度為 `n` 的陣列，最多需要 `n-1` 趟。每一趟會將當前未排序部分的最大元素「冒泡」到正確的位置。
- **內層迴圈** `for (int j = 0; j < n - 1 - i; j++)`：遍歷未排序的部分，比較相鄰元素 `arr[j]` 和 `arr[j + 1]`。
    - 隨著外層迴圈的 `i` 增加，內層迴圈的範圍 `n - 1 - i` 減小，因為後 `i` 個元素已經排序完成。
    - 如果 `arr[j] > arr[j + 1]` (對於升序排序)，則說明順序錯誤，需要**交換**這兩個元素的值。使用一個臨時變數 `temp` 來實現交換。
- **優化**：添加一個 `boolean swapped` 旗標。在內層迴圈開始前設為 `false`，如果在該趟排序中發生了任何交換，就設為 `true`。內層迴圈結束後，如果 `swapped` 仍然是 `false`，說明本趟沒有任何交換，陣列已經有序，可以直接 `break` 跳出外層迴圈，提前結束排序。

---

### 題目：不使用第三變數交換兩數

#### 📋 題目說明：
請撰寫一個 Java 程式，交換兩個整數變數的值，但不能使用額外的第三個變數來暫存值。

#### 📥 範例輸入：
```
交換前：a = 10, b = 20
```

#### 📤 預期輸出：
```
交換後：a = 20, b = 10
```

#### ✅ Java 解答：
```java
public class SwapWithoutTemp {

    public static void main(String[] args) {
        int a = 10;
        int b = 20;

        System.out.println("交換前：a = " + a + ", b = " + b);

        // 使用算術運算交換兩個數
        // 步驟 1: 將 a 變成兩個數的和
        a = a + b;  // a = 10 + 20 = 30
        // 步驟 2: 將 b 變成原來的 a
        b = a - b;  // b = 30 - 20 = 10 (現在 b 儲存了原來的 a 的值)
        // 步驟 3: 將 a 變成原來的 b
        a = a - b;  // a = 30 - 10 = 20 (現在 a 儲存了原來的 b 的值)

        System.out.println("交換後：a = " + a + ", b = " + b);

        // 另一種方法：使用位元運算 (XOR)
        /*
        int x = 10;
        int y = 20;
        System.out.println("交換前 (XOR): x = " + x + ", y = " + y);
        x = x ^ y; // x = 10 ^ 20 = 30 (二進制 01010 ^ 10100 = 11110)
        y = x ^ y; // y = 30 ^ 20 = 10 (二進制 11110 ^ 10100 = 01010)
        x = x ^ y; // x = 30 ^ 10 = 20 (二進制 11110 ^ 01010 = 10100)
        System.out.println("交換後 (XOR): x = " + x + ", y = " + y);
        */
    }
}
```

#### 📌 重點解析：
- 目標是交換兩個變數 `a` 和 `b` 的值，但不允許使用第三個臨時變數。
- **方法一：使用算術運算**
    1.  `a = a + b;`：將 `a` 的值更新為原來的 `a` 和 `b` 的總和。此時 `a` 暫時儲存了兩個數的信息。
    2.  `b = a - b;`：將 `b` 的值更新為當前的 `a` (總和) 減去原來的 `b`。結果就是原來的 `a` 的值。此時 `b` 已經被賦予了正確的新值。
    3.  `a = a - b;`：將 `a` 的值更新為當前的 `a` (總和) 減去當前的 `b` (原來的 `a`)。結果就是原來的 `b` 的值。此時 `a` 也被賦予了正確的新值。
    - **注意事項**：這種方法可能會有**整數溢位**的風險，如果 `a + b` 超出了 `int` 的最大值範圍。
- **方法二：使用位元運算 (XOR)**
    - XOR 運算 (^) 的特性：`A ^ A = 0`, `A ^ 0 = A`, `(A ^ B) ^ B = A`.
    1.  `x = x ^ y;`：`x` 現在儲存了 `x` 和 `y` 的 XOR 結果。
    2.  `y = x ^ y;`：相當於 `y = (原來的 x ^ 原來的 y) ^ 原來的 y`。根據 XOR 特性，結果就是原來的 `x`。此時 `y` 已被賦予正確的新值。
    3.  `x = x ^ y;`：相當於 `x = (原來的 x ^ 原來的 y) ^ (原來的 x)`。根據 XOR 特性，結果就是原來的 `y`。此時 `x` 也被賦予正確的新值。
    - **優點**：這種方法**不會導致溢位**問題，且在底層通常效率更高。
    - **限制**：兩個變數不能引用**同一個記憶體位置**（例如陣列中的 `arr[i]` 和 `arr[i]`），否則所有值會變成 0。但在交換兩個獨立變數時沒有這個問題。
- 面試中通常考驗的是算術運算方法，但了解 XOR 方法會更受青睞，因其更穩健。

---

# 十、JavaScript 語法重點

## 常用語法：
- **宣告：var / let / const 差異**
    - `var`：舊有的宣告方式。存在**變數提升 (hoisting)**，作用域為**函式作用域 (function scope)**。可以重複宣告同一個變數，也可以重新賦值。
    - `let`：ES6 引入。作用域為**塊級作用域 (block scope)**。存在變數提升，但有**暫時性死區 (Temporal Dead Zone, TDZ)**，在宣告前不能使用。不能重複宣告同一個變數，但可以重新賦值。
    - `const`：ES6 引入。作用域為**塊級作用域 (block scope)**。存在暫時性死區。宣告時**必須賦予初始值**，且之後不能重新賦值。對於基本類型，值不可變；對於物件或陣列，引用不可變，但物件/陣列內部屬性/元素可以修改。
- **非同步處理：Promise vs async/await**
    - **Promise**：處理非同步操作的標準方式。代表一個非同步操作的最終完成（或失敗）的結果。可以鏈式調用 `.then()` 處理成功，`.catch()` 處理失敗。解決了傳統回調函式 (callback) 可能導致的「回調地獄 (callback hell)」問題。
    - **async/await**：基於 Promise 的語法糖 (syntactic sugar)。讓非同步程式碼寫起來像同步程式碼一樣直觀。`async` 函式返回一個 Promise。`await` 只能在 `async` 函式中使用，它會暫停函式的執行，直到 Promise 解決 (resolve)，然後繼續執行並返回 Promise 的解決值。如果 Promise 拒絕 (reject)，`await` 會拋出錯誤。
- **this 的作用域變化**
    - `this` 的值在 JavaScript 中取決於函式被調用的方式（執行上下文）。
    - **全域作用域**：在瀏覽器中通常指向 `window` 物件，在 Node.js 中指向 `global` 物件或 `undefined` (嚴格模式)。
    - **函式調用**：非嚴格模式下指向全域物件，嚴格模式下指向 `undefined`。
    - **方法調用**：指向調用該方法的物件。
    - **建構函式調用**：指向新創建的物件實例。
    - **事件處理函式**：通常指向觸發事件的元素。
    - **箭頭函式 (Arrow Function)**：箭頭函式**沒有自己的 `this`**，它會捕獲其所在**詞法作用域 (lexical scope)** 的 `this` 值。這是它與普通函式最大的區別之一。
    - 可以使用 `call()`, `apply()`, `bind()` 方法來手動改變 `this` 的指向。
- **型別比較：== vs ===**
    - `==` (相等運算子)：**比較時會進行強制型別轉換 (type coercion)**。如果比較雙方的型別不同，JavaScript 會嘗試將它們轉換為相同型別再進行比較。這可能導致一些非預期的結果，例如 `false == 0` 為 `true`，`"5" == 5` 為 `true`。
    - `===` (嚴格相等運算子)：**比較時不會進行強制型別轉換**。只有當比較雙方的**值**和**型別**都完全相同時，才會返回 `true`。這是 JavaScript 中推薦的比較方式，可以避免型別轉換帶來的潛在問題。

## 範例：
```js
// Arrow function example
const greet = (name) => `Hello, ${name}`;
console.log(greet("World")); // Output: Hello, World

// Promise example
function fetchData() {
  return new Promise((resolve, reject) => {
    // Simulate async operation
    setTimeout(() => {
      resolve("Data fetched successfully!");
    }, 1000);
  });
}

fetchData()
  .then(data => console.log(data)) // Output: Data fetched successfully! (after 1 second)
  .catch(error => console.error(error));

// async/await example
async function processData() {
  try {
    const data = await fetchData(); // Wait for the promise to resolve
    console.log(data); // Output: Data fetched successfully! (after 1 second)
  } catch (error) {
    console.error(error);
  }
}
processData();

// == vs === example
console.log(5 == "5");   // Output: true (string "5" is coerced to number 5)
console.log(5 === "5");  // Output: false (number 5 and string "5" are different types)
console.log(0 == false); // Output: true (false is coerced to number 0)
console.log(0 === false);// Output: false (number 0 and boolean false are different types)
```
```
